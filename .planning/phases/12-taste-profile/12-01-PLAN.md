---
phase: 12-taste-profile
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/taste_profile/domain/taste_profile.dart
  - lib/features/taste_profile/data/taste_profile_preferences.dart
  - lib/features/taste_profile/providers/taste_profile_providers.dart
  - test/features/taste_profile/domain/taste_profile_test.dart
autonomous: true

must_haves:
  truths:
    - "TasteProfile model can represent 1-5 genres, 0-10 artists, and an energy level"
    - "TasteProfile survives JSON round-trip with all fields preserved"
    - "EnergyLevel enum serializes by name and deserializes back"
    - "RunningGenre enum has exactly 15 values with display names"
    - "TasteProfilePreferences persists and loads a TasteProfile via SharedPreferences"
    - "TasteProfileNotifier loads from preferences on construction and auto-persists on mutation"
    - "Notifier enforces max 5 genres and max 10 artists"
    - "Notifier rejects empty/whitespace-only artist names and case-insensitive duplicates"
  artifacts:
    - path: "lib/features/taste_profile/domain/taste_profile.dart"
      provides: "TasteProfile class, EnergyLevel enum, RunningGenre enum"
      contains: "class TasteProfile"
    - path: "lib/features/taste_profile/data/taste_profile_preferences.dart"
      provides: "Static load/save/clear for TasteProfile"
      contains: "class TasteProfilePreferences"
    - path: "lib/features/taste_profile/providers/taste_profile_providers.dart"
      provides: "TasteProfileNotifier and tasteProfileNotifierProvider"
      contains: "final tasteProfileNotifierProvider"
    - path: "test/features/taste_profile/domain/taste_profile_test.dart"
      provides: "Unit tests for domain model serialization and notifier logic"
      contains: "void main()"
  key_links:
    - from: "taste_profile_preferences.dart"
      to: "taste_profile.dart"
      via: "imports TasteProfile, calls toJson/fromJson"
      pattern: "TasteProfile\\.fromJson"
    - from: "taste_profile_providers.dart"
      to: "taste_profile_preferences.dart"
      via: "calls TasteProfilePreferences.load/save/clear"
      pattern: "TasteProfilePreferences\\.(load|save|clear)"
    - from: "taste_profile_providers.dart"
      to: "taste_profile.dart"
      via: "StateNotifier<TasteProfile?> uses domain model"
      pattern: "StateNotifier<TasteProfile\\?>"
---

<objective>
Create the taste profile domain model, SharedPreferences persistence layer, Riverpod state notifier with granular mutation methods, and comprehensive unit tests.

Purpose: Establish the data backbone for the taste profile feature so the UI (Plan 12-02) and downstream playlist generation (Phase 14) can read and write user music preferences.

Output: Four files -- domain model, preferences adapter, provider, and unit tests -- all following established codebase patterns exactly.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-taste-profile/12-RESEARCH.md

# Pattern references (read these to match exact style)
@lib/features/run_plan/domain/run_plan.dart
@lib/features/run_plan/data/run_plan_preferences.dart
@lib/features/run_plan/providers/run_plan_providers.dart
@test/features/run_plan/domain/run_plan_calculator_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Domain model -- TasteProfile, EnergyLevel, RunningGenre</name>
  <files>lib/features/taste_profile/domain/taste_profile.dart</files>
  <action>
Create `lib/features/taste_profile/domain/taste_profile.dart` following the exact pattern from `run_plan.dart`.

Start with the library directive (pure Dart, NO Flutter imports):

```dart
/// Pure Dart domain model for taste profiles. No Flutter dependencies.
library;
```

**EnergyLevel enum** (matches RunType pattern):

```dart
/// Energy level preference for running music.
enum EnergyLevel {
  chill,
  balanced,
  intense;

  /// Deserializes from a JSON string (enum name).
  static EnergyLevel fromJson(String name) =>
      EnergyLevel.values.firstWhere((e) => e.name == name);
}
```

**RunningGenre enum** with exactly 15 values and `displayName` getter:

```dart
/// Curated list of 15 running-relevant music genres.
///
/// Identifiers align with Spotify genre seed slugs for future API integration.
enum RunningGenre {
  pop('Pop'),
  hipHop('Hip-Hop / Rap'),
  electronic('Electronic'),
  edm('EDM'),
  rock('Rock'),
  indie('Indie'),
  dance('Dance'),
  house('House'),
  drumAndBass('Drum & Bass'),
  rnb('R&B / Soul'),
  latin('Latin / Reggaeton'),
  metal('Metal'),
  punk('Punk Rock'),
  funk('Funk / Disco'),
  kPop('K-Pop');

  const RunningGenre(this.displayName);

  /// Human-readable name for UI display.
  final String displayName;

  /// Deserializes from a JSON string (enum name).
  static RunningGenre fromJson(String name) =>
      RunningGenre.values.firstWhere((e) => e.name == name);
}
```

**TasteProfile class** with const constructor, final fields, `toJson()`, `fromJson()` factory, and `copyWith()`:

```dart
/// The user's running music taste preferences.
///
/// Stores genre preferences (1-5 from [RunningGenre]), favorite artists
/// (0-10 strings), and an [EnergyLevel] preference. Persisted as a single
/// JSON blob via SharedPreferences.
class TasteProfile {
  const TasteProfile({
    this.genres = const [],
    this.artists = const [],
    this.energyLevel = EnergyLevel.balanced,
  });

  factory TasteProfile.fromJson(Map<String, dynamic> json) {
    return TasteProfile(
      genres: (json['genres'] as List<dynamic>)
          .map((g) => RunningGenre.fromJson(g as String))
          .toList(),
      artists: (json['artists'] as List<dynamic>)
          .map((a) => a as String)
          .toList(),
      energyLevel: EnergyLevel.fromJson(json['energyLevel'] as String),
    );
  }

  /// Selected running genres (1-5).
  final List<RunningGenre> genres;

  /// Favorite running artists (0-10).
  final List<String> artists;

  /// Preferred energy level for playlists.
  final EnergyLevel energyLevel;

  Map<String, dynamic> toJson() => {
        'genres': genres.map((g) => g.name).toList(),
        'artists': artists,
        'energyLevel': energyLevel.name,
      };

  TasteProfile copyWith({
    List<RunningGenre>? genres,
    List<String>? artists,
    EnergyLevel? energyLevel,
  }) {
    return TasteProfile(
      genres: genres ?? this.genres,
      artists: artists ?? this.artists,
      energyLevel: energyLevel ?? this.energyLevel,
    );
  }
}
```

IMPORTANT: Genres are stored as `List<RunningGenre>` (typed enum), NOT `List<String>`. The JSON serialization converts to/from enum names. This gives type safety and prevents invalid genre strings.
  </action>
  <verify>
Run `dart analyze lib/features/taste_profile/domain/taste_profile.dart` -- zero errors, zero warnings.
Verify no Flutter imports: `grep -c 'flutter' lib/features/taste_profile/domain/taste_profile.dart` returns 0.
Verify exactly 15 RunningGenre values: `grep -c "'" lib/features/taste_profile/domain/taste_profile.dart` should show the display names.
  </verify>
  <done>
- taste_profile.dart exists with EnergyLevel (3 values), RunningGenre (15 values with displayName), and TasteProfile (genres, artists, energyLevel, toJson, fromJson, copyWith)
- Pure Dart, no Flutter imports
- Matches run_plan.dart pattern exactly (library directive, enum with fromJson, class with const constructor)
  </done>
</task>

<task type="auto">
  <name>Task 2: Persistence and provider -- TasteProfilePreferences and TasteProfileNotifier</name>
  <files>
    lib/features/taste_profile/data/taste_profile_preferences.dart
    lib/features/taste_profile/providers/taste_profile_providers.dart
  </files>
  <action>
**File 1: `lib/features/taste_profile/data/taste_profile_preferences.dart`**

Create following the exact pattern from `run_plan_preferences.dart`:

```dart
import 'dart:convert';

import 'package:running_playlist_ai/features/taste_profile/domain/taste_profile.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Persistence wrapper for the user's taste profile.
///
/// Stores the [TasteProfile] as a single JSON string in SharedPreferences
/// so it survives app restarts. Uses static methods with async access
/// to the SharedPreferences singleton.
///
/// Follows the same pattern as RunPlanPreferences.
class TasteProfilePreferences {
  static const _key = 'taste_profile';

  /// Loads the saved taste profile, or null if none is stored.
  static Future<TasteProfile?> load() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_key);
    if (jsonString == null) return null;
    final json = jsonDecode(jsonString) as Map<String, dynamic>;
    return TasteProfile.fromJson(json);
  }

  /// Saves the given taste profile as a JSON string.
  static Future<void> save(TasteProfile profile) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = jsonEncode(profile.toJson());
    await prefs.setString(_key, jsonString);
  }

  /// Removes the stored taste profile.
  static Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_key);
  }
}
```

**File 2: `lib/features/taste_profile/providers/taste_profile_providers.dart`**

Create following the exact pattern from `run_plan_providers.dart`, with additional granular mutation methods for UI convenience. The notifier enforces business rules (max 5 genres, max 10 artists, artist validation).

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:running_playlist_ai/features/taste_profile/data/taste_profile_preferences.dart';
import 'package:running_playlist_ai/features/taste_profile/domain/taste_profile.dart';

/// Manages the user's [TasteProfile] state and persistence.
///
/// Loads the saved profile from SharedPreferences on initialization.
/// Provides granular mutation methods that enforce business rules
/// (max 5 genres, max 10 artists, artist name validation).
///
/// Follows the same pattern as RunPlanNotifier.
class TasteProfileNotifier extends StateNotifier<TasteProfile?> {
  TasteProfileNotifier() : super(null) {
    _load();
  }

  /// Loads the saved taste profile from SharedPreferences.
  Future<void> _load() async {
    state = await TasteProfilePreferences.load();
  }

  /// Replaces the entire taste profile and persists it.
  Future<void> setProfile(TasteProfile profile) async {
    state = profile;
    await TasteProfilePreferences.save(profile);
  }

  /// Sets the selected genres (clamped to max 5).
  Future<void> setGenres(List<RunningGenre> genres) async {
    final clamped = genres.length > 5 ? genres.sublist(0, 5) : genres;
    final profile = (state ?? const TasteProfile()).copyWith(genres: clamped);
    state = profile;
    await TasteProfilePreferences.save(profile);
  }

  /// Adds an artist if valid (non-empty, not duplicate, under max 10).
  ///
  /// Returns true if the artist was added, false if rejected.
  Future<bool> addArtist(String artist) async {
    final trimmed = artist.trim();
    if (trimmed.isEmpty) return false;

    final current = state ?? const TasteProfile();
    if (current.artists.length >= 10) return false;

    // Case-insensitive duplicate check
    final lowerTrimmed = trimmed.toLowerCase();
    if (current.artists.any((a) => a.toLowerCase() == lowerTrimmed)) {
      return false;
    }

    final updated = current.copyWith(
      artists: [...current.artists, trimmed],
    );
    state = updated;
    await TasteProfilePreferences.save(updated);
    return true;
  }

  /// Removes an artist by exact string match.
  Future<void> removeArtist(String artist) async {
    final current = state;
    if (current == null) return;
    final updated = current.copyWith(
      artists: current.artists.where((a) => a != artist).toList(),
    );
    state = updated;
    await TasteProfilePreferences.save(updated);
  }

  /// Sets the energy level preference.
  Future<void> setEnergyLevel(EnergyLevel level) async {
    final profile = (state ?? const TasteProfile()).copyWith(energyLevel: level);
    state = profile;
    await TasteProfilePreferences.save(profile);
  }

  /// Clears the taste profile and removes it from storage.
  Future<void> clear() async {
    state = null;
    await TasteProfilePreferences.clear();
  }
}

/// Provides [TasteProfileNotifier] and the current [TasteProfile?] to the widget tree.
///
/// Usage:
/// - `ref.watch(tasteProfileNotifierProvider)` to read the profile reactively
/// - `ref.read(tasteProfileNotifierProvider.notifier).setGenres(genres)` to update genres
/// - `ref.read(tasteProfileNotifierProvider.notifier).addArtist(name)` to add an artist
/// - `ref.read(tasteProfileNotifierProvider.notifier).setEnergyLevel(level)` to set energy
/// - `ref.read(tasteProfileNotifierProvider.notifier).clear()` to remove the profile
final tasteProfileNotifierProvider =
    StateNotifierProvider<TasteProfileNotifier, TasteProfile?>(
  (ref) => TasteProfileNotifier(),
);
```

Key design decisions:
- `setGenres` takes the full list (UI manages selection state, notifier just clamps)
- `addArtist` returns `bool` so UI can show feedback on rejection
- `addArtist` does case-insensitive dedup but stores original casing
- All mutation methods create a new TasteProfile from `state ?? const TasteProfile()` to handle null (new user) state gracefully
  </action>
  <verify>
Run `dart analyze lib/features/taste_profile/data/taste_profile_preferences.dart` -- zero errors.
Run `dart analyze lib/features/taste_profile/providers/taste_profile_providers.dart` -- zero errors.
  </verify>
  <done>
- taste_profile_preferences.dart exists with static load/save/clear methods matching RunPlanPreferences pattern
- taste_profile_providers.dart exists with TasteProfileNotifier (auto-load, setProfile, setGenres, addArtist, removeArtist, setEnergyLevel, clear) and tasteProfileNotifierProvider
- Notifier enforces max 5 genres, max 10 artists, rejects empty/whitespace artists, case-insensitive dedup
  </done>
</task>

<task type="auto">
  <name>Task 3: Unit tests for domain model and serialization</name>
  <files>test/features/taste_profile/domain/taste_profile_test.dart</files>
  <action>
Create `test/features/taste_profile/domain/taste_profile_test.dart` following the test pattern from `run_plan_calculator_test.dart`.

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/taste_profile/domain/taste_profile.dart';

void main() {
  // -- EnergyLevel enum -------------------------------------------------------

  group('EnergyLevel', () {
    test('has exactly 3 values', () {
      expect(EnergyLevel.values.length, equals(3));
    });

    test('fromJson deserializes each value', () {
      for (final level in EnergyLevel.values) {
        expect(EnergyLevel.fromJson(level.name), equals(level));
      }
    });

    test('fromJson throws on invalid name', () {
      expect(
        () => EnergyLevel.fromJson('invalid'),
        throwsA(isA<StateError>()),
      );
    });
  });

  // -- RunningGenre enum ------------------------------------------------------

  group('RunningGenre', () {
    test('has exactly 15 values', () {
      expect(RunningGenre.values.length, equals(15));
    });

    test('each value has a non-empty displayName', () {
      for (final genre in RunningGenre.values) {
        expect(genre.displayName, isNotEmpty);
      }
    });

    test('fromJson deserializes each value', () {
      for (final genre in RunningGenre.values) {
        expect(RunningGenre.fromJson(genre.name), equals(genre));
      }
    });

    test('fromJson throws on invalid name', () {
      expect(
        () => RunningGenre.fromJson('invalid'),
        throwsA(isA<StateError>()),
      );
    });

    test('specific display names are correct', () {
      expect(RunningGenre.hipHop.displayName, equals('Hip-Hop / Rap'));
      expect(RunningGenre.drumAndBass.displayName, equals('Drum & Bass'));
      expect(RunningGenre.rnb.displayName, equals('R&B / Soul'));
      expect(RunningGenre.kPop.displayName, equals('K-Pop'));
    });
  });

  // -- TasteProfile default constructor ---------------------------------------

  group('TasteProfile defaults', () {
    test('default constructor has empty genres', () {
      const profile = TasteProfile();
      expect(profile.genres, isEmpty);
    });

    test('default constructor has empty artists', () {
      const profile = TasteProfile();
      expect(profile.artists, isEmpty);
    });

    test('default constructor has balanced energy level', () {
      const profile = TasteProfile();
      expect(profile.energyLevel, equals(EnergyLevel.balanced));
    });
  });

  // -- TasteProfile serialization ---------------------------------------------

  group('TasteProfile serialization', () {
    test('toJson -> fromJson round-trip preserves all fields', () {
      final original = TasteProfile(
        genres: [RunningGenre.pop, RunningGenre.hipHop, RunningGenre.electronic],
        artists: ['Dua Lipa', 'The Weeknd'],
        energyLevel: EnergyLevel.intense,
      );
      final json = original.toJson();
      final restored = TasteProfile.fromJson(json);
      expect(restored.genres, equals(original.genres));
      expect(restored.artists, equals(original.artists));
      expect(restored.energyLevel, equals(original.energyLevel));
    });

    test('toJson stores genre enum names, not display names', () {
      final profile = TasteProfile(
        genres: [RunningGenre.hipHop, RunningGenre.drumAndBass],
      );
      final json = profile.toJson();
      final genreList = json['genres'] as List<dynamic>;
      expect(genreList, contains('hipHop'));
      expect(genreList, contains('drumAndBass'));
      expect(genreList, isNot(contains('Hip-Hop / Rap')));
    });

    test('toJson stores energy level enum name', () {
      const profile = TasteProfile(energyLevel: EnergyLevel.chill);
      final json = profile.toJson();
      expect(json['energyLevel'], equals('chill'));
    });

    test('round-trip with empty genres and artists', () {
      const original = TasteProfile();
      final json = original.toJson();
      final restored = TasteProfile.fromJson(json);
      expect(restored.genres, isEmpty);
      expect(restored.artists, isEmpty);
      expect(restored.energyLevel, equals(EnergyLevel.balanced));
    });

    test('round-trip with max 5 genres', () {
      final original = TasteProfile(
        genres: [
          RunningGenre.pop,
          RunningGenre.rock,
          RunningGenre.edm,
          RunningGenre.house,
          RunningGenre.latin,
        ],
      );
      final json = original.toJson();
      final restored = TasteProfile.fromJson(json);
      expect(restored.genres.length, equals(5));
      expect(restored.genres, equals(original.genres));
    });

    test('round-trip with max 10 artists', () {
      final artists = List.generate(10, (i) => 'Artist $i');
      final original = TasteProfile(artists: artists);
      final json = original.toJson();
      final restored = TasteProfile.fromJson(json);
      expect(restored.artists.length, equals(10));
      expect(restored.artists, equals(artists));
    });

    test('artists with special characters survive round-trip', () {
      final original = TasteProfile(
        artists: ['AC/DC', "Guns N' Roses", 'Beyonce'],
      );
      final json = original.toJson();
      final restored = TasteProfile.fromJson(json);
      expect(restored.artists, equals(original.artists));
    });
  });

  // -- TasteProfile copyWith --------------------------------------------------

  group('TasteProfile copyWith', () {
    test('copies genres only', () {
      final original = TasteProfile(
        genres: [RunningGenre.pop],
        artists: ['Artist'],
        energyLevel: EnergyLevel.intense,
      );
      final copied = original.copyWith(
        genres: [RunningGenre.rock, RunningGenre.edm],
      );
      expect(copied.genres, equals([RunningGenre.rock, RunningGenre.edm]));
      expect(copied.artists, equals(['Artist']));
      expect(copied.energyLevel, equals(EnergyLevel.intense));
    });

    test('copies artists only', () {
      final original = TasteProfile(
        genres: [RunningGenre.pop],
        artists: ['Old Artist'],
        energyLevel: EnergyLevel.chill,
      );
      final copied = original.copyWith(artists: ['New Artist']);
      expect(copied.genres, equals([RunningGenre.pop]));
      expect(copied.artists, equals(['New Artist']));
      expect(copied.energyLevel, equals(EnergyLevel.chill));
    });

    test('copies energy level only', () {
      final original = TasteProfile(
        genres: [RunningGenre.pop],
        energyLevel: EnergyLevel.chill,
      );
      final copied = original.copyWith(energyLevel: EnergyLevel.intense);
      expect(copied.genres, equals([RunningGenre.pop]));
      expect(copied.energyLevel, equals(EnergyLevel.intense));
    });

    test('no arguments returns equivalent profile', () {
      final original = TasteProfile(
        genres: [RunningGenre.pop],
        artists: ['Artist'],
        energyLevel: EnergyLevel.intense,
      );
      final copied = original.copyWith();
      expect(copied.genres, equals(original.genres));
      expect(copied.artists, equals(original.artists));
      expect(copied.energyLevel, equals(original.energyLevel));
    });
  });
}
```

This test file covers:
1. EnergyLevel enum: value count, round-trip, invalid name
2. RunningGenre enum: 15 values, displayName, round-trip, specific display names
3. TasteProfile defaults: empty genres/artists, balanced energy
4. TasteProfile serialization: full round-trip, enum names (not display names), empty state, max counts, special characters
5. TasteProfile copyWith: partial updates, no-arg copy
  </action>
  <verify>
Run `flutter test test/features/taste_profile/domain/taste_profile_test.dart` -- all tests pass.
  </verify>
  <done>
- taste_profile_test.dart exists with 20+ tests covering EnergyLevel, RunningGenre, TasteProfile serialization, and copyWith
- All tests pass
- Tests verify enum count (15 genres, 3 energy levels), JSON round-trips, display names, and edge cases
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/taste_profile/` -- zero errors, zero warnings across all 3 source files
2. `flutter test test/features/taste_profile/domain/taste_profile_test.dart` -- all tests pass
3. Verify no Flutter imports in domain model: `grep -r 'package:flutter' lib/features/taste_profile/domain/` returns empty
4. Verify RunningGenre has 15 values: test asserts `RunningGenre.values.length == 15`
5. Verify EnergyLevel has 3 values: test asserts `EnergyLevel.values.length == 3`
</verification>

<success_criteria>
- TasteProfile model with typed RunningGenre list, artist strings, EnergyLevel enum
- TasteProfilePreferences with static load/save/clear matching RunPlanPreferences pattern
- TasteProfileNotifier with auto-load, granular mutations, business rule enforcement (max 5 genres, max 10 artists, artist validation)
- All unit tests pass
- Zero analyzer errors/warnings
</success_criteria>

<output>
After completion, create `.planning/phases/12-taste-profile/12-01-SUMMARY.md`
</output>
