---
phase: 12-taste-profile
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - lib/features/taste_profile/presentation/taste_profile_screen.dart
  - lib/app/router.dart
autonomous: true

must_haves:
  truths:
    - "User can see 15 genre chips and select 1-5 of them"
    - "User cannot select more than 5 genres (6th selection is ignored)"
    - "User can type an artist name and press enter/submit to add it as a chip"
    - "User can delete an artist chip"
    - "User cannot add more than 10 artists (TextField hidden at 10)"
    - "User cannot add empty/whitespace-only artist names"
    - "User can select chill, balanced, or intense energy level via SegmentedButton"
    - "User can save their taste profile and see a confirmation snackbar"
    - "Navigating to /taste-profile shows the real screen, not Coming Soon"
    - "Existing taste profile loads and pre-fills the form on screen open"
  artifacts:
    - path: "lib/features/taste_profile/presentation/taste_profile_screen.dart"
      provides: "TasteProfileScreen with genre picker, artist input, energy selector"
      contains: "class TasteProfileScreen"
    - path: "lib/app/router.dart"
      provides: "Route /taste-profile pointing to TasteProfileScreen"
      contains: "TasteProfileScreen"
  key_links:
    - from: "taste_profile_screen.dart"
      to: "taste_profile_providers.dart"
      via: "ref.watch(tasteProfileNotifierProvider) and ref.read(.notifier)"
      pattern: "tasteProfileNotifierProvider"
    - from: "taste_profile_screen.dart"
      to: "taste_profile.dart"
      via: "imports RunningGenre, EnergyLevel, TasteProfile"
      pattern: "import.*taste_profile\\.dart"
    - from: "router.dart"
      to: "taste_profile_screen.dart"
      via: "import and route builder"
      pattern: "TasteProfileScreen"
---

<objective>
Build the taste profile UI screen with genre picker (FilterChip), artist input (TextField + InputChip), and energy level selector (SegmentedButton), then wire it into the router replacing the Coming Soon placeholder.

Purpose: Give users the interface to describe their running music taste, completing the full taste profile feature (TASTE-10 through TASTE-13).

Output: A working taste profile screen accessible from the home hub that persists preferences across app restarts.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-taste-profile/12-RESEARCH.md
@.planning/phases/12-taste-profile/12-01-SUMMARY.md

# Pattern reference (read this to match exact UI style)
@lib/features/run_plan/presentation/run_plan_screen.dart

# Files created by Plan 12-01 (read for imports/types)
@lib/features/taste_profile/domain/taste_profile.dart
@lib/features/taste_profile/providers/taste_profile_providers.dart

# File to modify
@lib/app/router.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Taste profile screen with genre picker, artist input, and energy selector</name>
  <files>lib/features/taste_profile/presentation/taste_profile_screen.dart</files>
  <action>
Create `lib/features/taste_profile/presentation/taste_profile_screen.dart` following the exact UI pattern from `run_plan_screen.dart`.

The screen is a `ConsumerStatefulWidget` with local UI state that syncs with the notifier on save. On init, it loads existing profile state into local variables.

```dart
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:running_playlist_ai/features/taste_profile/domain/taste_profile.dart';
import 'package:running_playlist_ai/features/taste_profile/providers/taste_profile_providers.dart';
```

**Class structure:**

```dart
/// Taste profile screen where users configure their running music preferences.
///
/// Three sections:
/// - **Genres:** FilterChip grid for selecting 1-5 preferred genres
/// - **Artists:** TextField + InputChip list for adding up to 10 favorite artists
/// - **Energy Level:** SegmentedButton for chill/balanced/intense preference
///
/// Preferences persist across app restarts via TasteProfilePreferences.
class TasteProfileScreen extends ConsumerStatefulWidget {
  const TasteProfileScreen({super.key});

  @override
  ConsumerState<TasteProfileScreen> createState() => _TasteProfileScreenState();
}
```

**State class with local UI state:**

```dart
class _TasteProfileScreenState extends ConsumerState<TasteProfileScreen> {
  final _selectedGenres = <RunningGenre>{};
  final _artists = <String>[];
  EnergyLevel _selectedEnergyLevel = EnergyLevel.balanced;
  final _artistController = TextEditingController();
  bool _initialized = false;
```

**initState and dispose:**

No special initState needed. The `_initialized` flag is used in `build()` to sync local state from provider on first non-null load. Dispose the TextEditingController.

```dart
  @override
  void dispose() {
    _artistController.dispose();
    super.dispose();
  }
```

**build method:**

```dart
  @override
  Widget build(BuildContext context) {
    final profile = ref.watch(tasteProfileNotifierProvider);
    final theme = Theme.of(context);

    // Sync local state from provider on first load (handles existing profile)
    if (!_initialized && profile != null) {
      _initialized = true;
      // Use addPostFrameCallback to avoid setState during build
      WidgetsBinding.instance.addPostFrameCallback((_) {
        setState(() {
          _selectedGenres
            ..clear()
            ..addAll(profile.genres);
          _artists
            ..clear()
            ..addAll(profile.artists);
          _selectedEnergyLevel = profile.energyLevel;
        });
      });
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Taste Profile'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // -- Genre selection --
            Text('Running Genres', style: theme.textTheme.titleMedium),
            const SizedBox(height: 4),
            Text(
              'Select 1-5 genres (${_selectedGenres.length}/5)',
              style: theme.textTheme.bodySmall,
            ),
            const SizedBox(height: 8),
            Wrap(
              spacing: 8,
              runSpacing: 4,
              children: RunningGenre.values.map((genre) {
                final isSelected = _selectedGenres.contains(genre);
                return FilterChip(
                  label: Text(genre.displayName),
                  selected: isSelected,
                  onSelected: (selected) {
                    setState(() {
                      if (selected) {
                        if (_selectedGenres.length < 5) {
                          _selectedGenres.add(genre);
                        }
                      } else {
                        _selectedGenres.remove(genre);
                      }
                    });
                  },
                );
              }).toList(),
            ),
            const SizedBox(height: 24),

            // -- Artist input --
            Text('Favorite Artists', style: theme.textTheme.titleMedium),
            const SizedBox(height: 4),
            Text(
              'Add up to 10 artists (${_artists.length}/10)',
              style: theme.textTheme.bodySmall,
            ),
            const SizedBox(height: 8),
            if (_artists.isNotEmpty) ...[
              Wrap(
                spacing: 8,
                runSpacing: 4,
                children: _artists.map((artist) {
                  return InputChip(
                    label: Text(artist),
                    onDeleted: () {
                      setState(() => _artists.remove(artist));
                    },
                  );
                }).toList(),
              ),
              const SizedBox(height: 8),
            ],
            if (_artists.length < 10)
              TextField(
                controller: _artistController,
                decoration: const InputDecoration(
                  labelText: 'Add artist',
                  hintText: 'Type artist name and press enter',
                  border: OutlineInputBorder(),
                ),
                textInputAction: TextInputAction.done,
                onSubmitted: _addArtist,
              ),
            const SizedBox(height: 24),

            // -- Energy level selector --
            Text('Energy Level', style: theme.textTheme.titleMedium),
            const SizedBox(height: 8),
            SegmentedButton<EnergyLevel>(
              segments: const [
                ButtonSegment(
                  value: EnergyLevel.chill,
                  label: Text('Chill'),
                  icon: Icon(Icons.spa),
                ),
                ButtonSegment(
                  value: EnergyLevel.balanced,
                  label: Text('Balanced'),
                  icon: Icon(Icons.balance),
                ),
                ButtonSegment(
                  value: EnergyLevel.intense,
                  label: Text('Intense'),
                  icon: Icon(Icons.local_fire_department),
                ),
              ],
              selected: {_selectedEnergyLevel},
              onSelectionChanged: (selected) {
                setState(() => _selectedEnergyLevel = selected.first);
              },
            ),
            const SizedBox(height: 32),

            // -- Save button --
            ElevatedButton(
              onPressed: _selectedGenres.isNotEmpty ? _saveProfile : null,
              child: Text(
                profile != null ? 'Update Taste Profile' : 'Save Taste Profile',
              ),
            ),
          ],
        ),
      ),
    );
  }
```

**Helper methods:**

```dart
  void _addArtist(String value) {
    final trimmed = value.trim();
    if (trimmed.isEmpty) return;

    // Case-insensitive duplicate check
    final lowerTrimmed = trimmed.toLowerCase();
    if (_artists.any((a) => a.toLowerCase() == lowerTrimmed)) {
      _artistController.clear();
      return;
    }

    if (_artists.length < 10) {
      setState(() => _artists.add(trimmed));
      _artistController.clear();
    }
  }

  void _saveProfile() {
    final profile = TasteProfile(
      genres: _selectedGenres.toList(),
      artists: List.of(_artists),
      energyLevel: _selectedEnergyLevel,
    );
    ref.read(tasteProfileNotifierProvider.notifier).setProfile(profile);

    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Taste profile saved!')),
    );
  }
}
```

Key design decisions matching existing patterns:
- `ConsumerStatefulWidget` with `ConsumerState` (same as RunPlanScreen)
- Local UI state (`_selectedGenres`, `_artists`, `_selectedEnergyLevel`) managed in State class
- `ref.watch()` for reactive state, `ref.read(.notifier)` for mutations (on save)
- `SingleChildScrollView` with `Column` layout and `EdgeInsets.all(16)` padding
- `SegmentedButton` for energy level (same pattern as RunType in run_plan_screen.dart)
- `Wrap` for chips (same pattern as distance presets in run_plan_screen.dart)
- `SnackBar` for save confirmation (same as "Run plan saved!")
- Save button disabled when no genres selected (`_selectedGenres.isNotEmpty`)
- Button text changes based on existing profile ("Update" vs "Save")
- FilterChip (NOT ChoiceChip) for multi-select genres
- TextField hidden when at 10 artists (prevents invalid input attempts)
- Artist validation: trim whitespace, reject empty, case-insensitive dedup (matches notifier logic)
  </action>
  <verify>
Run `dart analyze lib/features/taste_profile/presentation/taste_profile_screen.dart` -- zero errors, zero warnings.
Verify FilterChip used (not ChoiceChip): `grep 'FilterChip' lib/features/taste_profile/presentation/taste_profile_screen.dart` returns matches.
Verify SegmentedButton used: `grep 'SegmentedButton' lib/features/taste_profile/presentation/taste_profile_screen.dart` returns match.
Verify InputChip used for artists: `grep 'InputChip' lib/features/taste_profile/presentation/taste_profile_screen.dart` returns match.
  </verify>
  <done>
- taste_profile_screen.dart exists as ConsumerStatefulWidget
- Genre section: 15 FilterChips in Wrap, max 5 selection enforced, count label shown
- Artist section: InputChips with delete, TextField for entry, max 10 enforced, validation (trim, empty, case-insensitive dedup)
- Energy section: SegmentedButton with chill/balanced/intense and icons
- Save button: disabled when no genres selected, text changes for update vs new, SnackBar confirmation
- Existing profile pre-fills form on load
  </done>
</task>

<task type="auto">
  <name>Task 2: Router integration -- replace Coming Soon with TasteProfileScreen</name>
  <files>lib/app/router.dart</files>
  <action>
Modify `lib/app/router.dart` to replace the Coming Soon placeholder with the real TasteProfileScreen.

**Step 1:** Add import at the top of the file (after existing imports, alphabetical order):

```dart
import 'package:running_playlist_ai/features/taste_profile/presentation/taste_profile_screen.dart';
```

**Step 2:** Replace the `/taste-profile` route builder. Change this:

```dart
      GoRoute(
        path: '/taste-profile',
        builder: (context, state) =>
            const _ComingSoonScreen(title: 'Taste Profile'),
      ),
```

To this:

```dart
      GoRoute(
        path: '/taste-profile',
        builder: (context, state) => const TasteProfileScreen(),
      ),
```

Do NOT remove the `_ComingSoonScreen` class -- it is still used by `/playlist` and `/playlist-history` routes.

Do NOT change any other routes.
  </action>
  <verify>
Run `dart analyze lib/app/router.dart` -- zero errors.
Verify the route points to TasteProfileScreen: `grep 'TasteProfileScreen' lib/app/router.dart` returns a match.
Verify Coming Soon is NOT used for taste-profile: `grep -A2 "taste-profile" lib/app/router.dart` shows TasteProfileScreen, not _ComingSoonScreen.
Verify _ComingSoonScreen class still exists: `grep '_ComingSoonScreen' lib/app/router.dart` still returns matches (used by other routes).
  </verify>
  <done>
- router.dart imports TasteProfileScreen
- /taste-profile route uses TasteProfileScreen instead of _ComingSoonScreen
- Other routes unchanged, _ComingSoonScreen class preserved for /playlist and /playlist-history
- Zero analyzer errors
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/taste_profile/presentation/` -- zero errors
2. `dart analyze lib/app/router.dart` -- zero errors
3. `flutter test` -- all existing tests still pass (no regressions)
4. Manual verification: launch app, navigate to Taste Profile from home hub, confirm real screen appears (not Coming Soon)
5. Manual verification: select genres (verify max 5), add artists (verify max 10, validation), choose energy level, save, close app, reopen -- profile persists
</verification>

<success_criteria>
- TasteProfileScreen renders with genre chips (FilterChip), artist input (TextField + InputChip), and energy selector (SegmentedButton)
- Genre selection enforces 1-5 limit in UI
- Artist input validates (trim, empty, duplicate) and enforces max 10
- Save persists via notifier, shows SnackBar confirmation
- Existing profile pre-fills form on load (persistence works across restarts)
- /taste-profile route shows real screen, not placeholder
- All existing tests pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/12-taste-profile/12-02-SUMMARY.md`
</output>
