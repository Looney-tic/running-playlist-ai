---
phase: 13-bpm-data-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pubspec.yaml
  - .env
  - macos/Runner/DebugProfile.entitlements
  - macos/Runner/Release.entitlements
  - lib/features/bpm_lookup/domain/bpm_song.dart
  - lib/features/bpm_lookup/domain/bpm_matcher.dart
  - lib/features/bpm_lookup/data/getsongbpm_client.dart
  - test/features/bpm_lookup/domain/bpm_song_test.dart
  - test/features/bpm_lookup/domain/bpm_matcher_test.dart
  - test/features/bpm_lookup/data/getsongbpm_client_test.dart
autonomous: true

must_haves:
  truths:
    - "BpmSong model can parse a GetSongBPM /tempo/ API response item into a typed Dart object"
    - "BpmSong serializes to JSON and deserializes back without data loss"
    - "BpmMatcher.bpmQueries(170) returns {170: exact, 85: halfTime} and excludes 340 (over maxQueryBpm)"
    - "BpmMatcher.bpmQueries(85) returns {85: exact, 170: doubleTime, 42: halfTime}"
    - "GetSongBpmClient.fetchSongsByBpm calls the correct API URL and parses the response into BpmSong list"
    - "GetSongBpmClient throws BpmApiException on non-200 status codes"
    - "macOS entitlements allow outbound network requests for both debug and release builds"
  artifacts:
    - path: "lib/features/bpm_lookup/domain/bpm_song.dart"
      provides: "BpmSong domain model and BpmMatchType enum"
      contains: "class BpmSong"
    - path: "lib/features/bpm_lookup/domain/bpm_matcher.dart"
      provides: "Half/double-time BPM query computation"
      contains: "class BpmMatcher"
    - path: "lib/features/bpm_lookup/data/getsongbpm_client.dart"
      provides: "HTTP client for GetSongBPM API"
      contains: "class GetSongBpmClient"
    - path: "test/features/bpm_lookup/domain/bpm_song_test.dart"
      provides: "Unit tests for BpmSong model"
      contains: "group('BpmSong'"
    - path: "test/features/bpm_lookup/domain/bpm_matcher_test.dart"
      provides: "Unit tests for BpmMatcher"
      contains: "group('BpmMatcher'"
    - path: "test/features/bpm_lookup/data/getsongbpm_client_test.dart"
      provides: "Unit tests for GetSongBpmClient with MockClient"
      contains: "MockClient"
  key_links:
    - from: "lib/features/bpm_lookup/data/getsongbpm_client.dart"
      to: "lib/features/bpm_lookup/domain/bpm_song.dart"
      via: "BpmSong.fromApiJson parses API response"
      pattern: "BpmSong\\.fromApiJson"
    - from: "lib/features/bpm_lookup/data/getsongbpm_client.dart"
      to: "https://api.getsongbpm.com/tempo/"
      via: "Uri.https GET request"
      pattern: "Uri\\.https.*api\\.getsongbpm\\.com.*tempo"
    - from: "test/features/bpm_lookup/data/getsongbpm_client_test.dart"
      to: "lib/features/bpm_lookup/data/getsongbpm_client.dart"
      via: "MockClient injection for testability"
      pattern: "MockClient"
---

<objective>
Create the BPM data pipeline foundation: domain models (BpmSong, BpmMatchType, BpmMatcher), the GetSongBPM API client, platform configuration for network access, and comprehensive unit tests.

Purpose: This plan delivers the core data layer that Phase 13 Plan 02 (cache + providers) and Phase 14 (playlist generation) depend on. The domain models define the song data shape, the matcher encodes the half/double-time business logic, and the API client handles HTTP communication with GetSongBPM.

Output: 3 production files (bpm_song.dart, bpm_matcher.dart, getsongbpm_client.dart), 3 test files, updated pubspec.yaml with `http` dependency, and macOS entitlements with network.client permission.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-bpm-data-pipeline/13-RESEARCH.md

@lib/features/run_plan/domain/run_plan.dart
@lib/features/run_plan/data/run_plan_preferences.dart
@test/features/taste_profile/domain/taste_profile_test.dart
@pubspec.yaml
@macos/Runner/DebugProfile.entitlements
@macos/Runner/Release.entitlements
@analysis_options.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add http dependency and macOS network entitlements</name>
  <files>
    pubspec.yaml
    macos/Runner/DebugProfile.entitlements
    macos/Runner/Release.entitlements
  </files>
  <action>
**1a. Add `http` package to pubspec.yaml:**

Run:
```bash
cd /Users/tijmen/running-playlist-ai && flutter pub add http
```

This adds `http: ^1.3.0` (or latest compatible) to pubspec.yaml dependencies and runs `flutter pub get`.

**1b. Add macOS network.client entitlement to DebugProfile.entitlements:**

Edit `macos/Runner/DebugProfile.entitlements` to add the `com.apple.security.network.client` key. The final file should be:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.cs.allow-jit</key>
	<true/>
	<key>com.apple.security.network.server</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
</dict>
</plist>
```

**1c. Add macOS network.client entitlement to Release.entitlements:**

Edit `macos/Runner/Release.entitlements` to add the `com.apple.security.network.client` key. The final file should be:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
</dict>
</plist>
```

**1d. Add GETSONGBPM_API_KEY placeholder to .env:**

Append this line to the `.env` file (do NOT remove existing SUPABASE entries):

```
GETSONGBPM_API_KEY=
```

The user will fill in the actual key later. The empty value prevents dotenv from throwing errors.
  </action>
  <verify>
Run `flutter pub get` (should already succeed from step 1a). Verify http appears in pubspec.yaml dependencies. Verify both entitlements files contain `com.apple.security.network.client`. Verify .env has the GETSONGBPM_API_KEY line.
  </verify>
  <done>
pubspec.yaml has `http` dependency. Both macOS entitlement files have network.client permission. .env has GETSONGBPM_API_KEY placeholder.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BpmSong model, BpmMatchType enum, and BpmMatcher</name>
  <files>
    lib/features/bpm_lookup/domain/bpm_song.dart
    lib/features/bpm_lookup/domain/bpm_matcher.dart
  </files>
  <action>
**2a. Create `lib/features/bpm_lookup/domain/bpm_song.dart`:**

```dart
/// Pure Dart domain model for BPM song data. No Flutter dependencies.
///
/// A [BpmSong] represents a song discovered from the GetSongBPM API.
/// [BpmMatchType] indicates how the song's tempo relates to the target cadence.
library;

/// How a song's BPM relates to the target cadence.
enum BpmMatchType {
  /// Song tempo directly matches target BPM.
  exact,

  /// Song is at half the target BPM (e.g., 85 BPM song for 170 cadence).
  halfTime,

  /// Song is at double the target BPM (e.g., 340 BPM song for 170 cadence).
  doubleTime;

  /// Deserializes from a JSON string (enum name).
  static BpmMatchType fromJson(String name) =>
      BpmMatchType.values.firstWhere((e) => e.name == name);
}

/// A song discovered from the GetSongBPM API.
class BpmSong {
  const BpmSong({
    required this.songId,
    required this.title,
    required this.artistName,
    required this.tempo,
    this.songUri,
    this.artistUri,
    this.albumTitle,
    this.matchType = BpmMatchType.exact,
  });

  /// Deserializes from our local JSON format (cache / persistence).
  factory BpmSong.fromJson(Map<String, dynamic> json) {
    return BpmSong(
      songId: json['songId'] as String,
      title: json['title'] as String,
      artistName: json['artistName'] as String,
      tempo: (json['tempo'] as num).toInt(),
      songUri: json['songUri'] as String?,
      artistUri: json['artistUri'] as String?,
      albumTitle: json['albumTitle'] as String?,
      matchType: json['matchType'] != null
          ? BpmMatchType.fromJson(json['matchType'] as String)
          : BpmMatchType.exact,
    );
  }

  /// Parses from the GetSongBPM API `/tempo/` endpoint response item.
  ///
  /// The API uses `song_id`, `song_title`, and nests artist/album as objects.
  /// The `tempo` field comes back as a **string** (e.g., `"170"`).
  factory BpmSong.fromApiJson(
    Map<String, dynamic> json, {
    BpmMatchType matchType = BpmMatchType.exact,
  }) {
    final artist = json['artist'] as Map<String, dynamic>? ?? {};
    final album = json['album'] as Map<String, dynamic>?;
    return BpmSong(
      songId: json['song_id'] as String? ?? '',
      title: json['song_title'] as String? ?? '',
      artistName: artist['name'] as String? ?? '',
      tempo: int.tryParse(json['tempo']?.toString() ?? '') ?? 0,
      songUri: json['song_uri'] as String?,
      artistUri: artist['uri'] as String?,
      albumTitle: album?['title'] as String?,
      matchType: matchType,
    );
  }

  final String songId;
  final String title;
  final String artistName;
  final int tempo;
  final String? songUri;
  final String? artistUri;
  final String? albumTitle;
  final BpmMatchType matchType;

  /// Serializes to our local JSON format for cache / persistence.
  ///
  /// Note: [matchType] is intentionally **excluded** from the serialized
  /// output. Match type is contextual -- it depends on the relationship
  /// between this song's BPM and the *current* target BPM. Storing it
  /// would cause cache key collisions (see RESEARCH.md Pitfall 5).
  /// Match type is assigned at load time by the lookup notifier.
  Map<String, dynamic> toJson() => {
        'songId': songId,
        'title': title,
        'artistName': artistName,
        'tempo': tempo,
        'songUri': songUri,
        'artistUri': artistUri,
        'albumTitle': albumTitle,
      };

  /// Creates a copy with a different [matchType].
  BpmSong withMatchType(BpmMatchType type) => BpmSong(
        songId: songId,
        title: title,
        artistName: artistName,
        tempo: tempo,
        songUri: songUri,
        artistUri: artistUri,
        albumTitle: albumTitle,
        matchType: type,
      );
}
```

IMPORTANT: `toJson()` does NOT include `matchType`. This is deliberate per RESEARCH.md Pitfall 5: matchType is assigned at load time based on the relationship between the cached BPM and the current target BPM. The `fromJson()` factory defaults matchType to `exact` because cached songs without a matchType key are loaded with exact as the default, then reassigned by the notifier.

**2b. Create `lib/features/bpm_lookup/domain/bpm_matcher.dart`:**

```dart
/// Pure Dart half/double-time BPM matching logic. No Flutter dependencies.
///
/// Given a target running cadence BPM, [BpmMatcher] computes which BPM
/// values to query from the GetSongBPM API to find songs that work at
/// exact tempo, half-time, or double-time.
library;

import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';

/// Computes BPM values to query for half/double-time matching.
class BpmMatcher {
  /// The maximum BPM value the API is likely to have songs for.
  static const maxQueryBpm = 300;

  /// The minimum BPM value that makes sense to query.
  static const minQueryBpm = 40;

  /// Returns BPM values to query with their match types.
  ///
  /// For a target BPM of 170:
  /// - Exact: query 170
  /// - Half-time: query 85 (170 ~/ 2) -- only if >= [minQueryBpm]
  /// - Double-time: query 340 (170 * 2) -- only if <= [maxQueryBpm]
  ///
  /// ```dart
  /// BpmMatcher.bpmQueries(170); // {170: exact, 85: halfTime}
  /// BpmMatcher.bpmQueries(85);  // {85: exact, 42: halfTime, 170: doubleTime}
  /// BpmMatcher.bpmQueries(120); // {120: exact, 60: halfTime, 240: doubleTime}
  /// ```
  static Map<int, BpmMatchType> bpmQueries(int targetBpm) {
    final queries = <int, BpmMatchType>{
      targetBpm: BpmMatchType.exact,
    };

    final halfBpm = targetBpm ~/ 2;
    if (halfBpm >= minQueryBpm) {
      queries[halfBpm] = BpmMatchType.halfTime;
    }

    final doubleBpm = targetBpm * 2;
    if (doubleBpm <= maxQueryBpm) {
      queries[doubleBpm] = BpmMatchType.doubleTime;
    }

    return queries;
  }
}
```
  </action>
  <verify>
Run `dart analyze lib/features/bpm_lookup/domain/` -- no errors or warnings. Verify both files are pure Dart (no `import 'package:flutter` anywhere).
  </verify>
  <done>
BpmMatchType enum has 3 values (exact, halfTime, doubleTime) with fromJson. BpmSong has fromJson (cache), fromApiJson (API), toJson (excludes matchType), and withMatchType. BpmMatcher.bpmQueries returns correct map for any target BPM with minQueryBpm=40 and maxQueryBpm=300 bounds.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create GetSongBpmClient and all unit tests</name>
  <files>
    lib/features/bpm_lookup/data/getsongbpm_client.dart
    test/features/bpm_lookup/domain/bpm_song_test.dart
    test/features/bpm_lookup/domain/bpm_matcher_test.dart
    test/features/bpm_lookup/data/getsongbpm_client_test.dart
  </files>
  <action>
**3a. Create `lib/features/bpm_lookup/data/getsongbpm_client.dart`:**

```dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:http/http.dart' as http;
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';

/// Exception thrown when the GetSongBPM API returns an error.
class BpmApiException implements Exception {
  const BpmApiException(this.message, {this.statusCode});

  final String message;
  final int? statusCode;

  @override
  String toString() => 'BpmApiException: $message (status: $statusCode)';
}

/// Client for the GetSongBPM API.
///
/// Makes GET requests to the `/tempo/` endpoint to find songs by BPM.
/// Accepts an [http.Client] for testability (inject [MockClient] in tests).
class GetSongBpmClient {
  GetSongBpmClient({
    required String apiKey,
    http.Client? httpClient,
  })  : _apiKey = apiKey,
        _httpClient = httpClient ?? http.Client();

  final String _apiKey;
  final http.Client _httpClient;

  static const _baseUrl = 'api.getsongbpm.com';
  static const _timeout = Duration(seconds: 10);

  /// Fetches songs at the given [bpm] from the GetSongBPM API.
  ///
  /// Returns a list of [BpmSong] objects with the given [matchType].
  /// Throws [BpmApiException] on non-200 API responses.
  /// Throws [SocketException] on network connectivity errors.
  /// Throws [TimeoutException] if the request exceeds 10 seconds.
  /// Throws [FormatException] if the response body is not valid JSON.
  Future<List<BpmSong>> fetchSongsByBpm(
    int bpm, {
    BpmMatchType matchType = BpmMatchType.exact,
  }) async {
    final uri = Uri.https(_baseUrl, '/tempo/', {
      'api_key': _apiKey,
      'bpm': bpm.toString(),
    });

    final response = await _httpClient.get(uri).timeout(_timeout);

    if (response.statusCode != 200) {
      throw BpmApiException(
        'API returned status ${response.statusCode}',
        statusCode: response.statusCode,
      );
    }

    final body = jsonDecode(response.body) as Map<String, dynamic>;
    final tempoList = body['tempo'] as List<dynamic>? ?? [];

    return tempoList
        .map(
          (item) => BpmSong.fromApiJson(
            item as Map<String, dynamic>,
            matchType: matchType,
          ),
        )
        .toList();
  }

  /// Disposes the underlying HTTP client.
  void dispose() {
    _httpClient.close();
  }
}
```

**3b. Create `test/features/bpm_lookup/domain/bpm_song_test.dart`:**

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';

void main() {
  // -- BpmMatchType enum -------------------------------------------------------

  group('BpmMatchType', () {
    test('has exactly 3 values', () {
      expect(BpmMatchType.values.length, equals(3));
    });

    test('fromJson deserializes each value', () {
      for (final type in BpmMatchType.values) {
        expect(BpmMatchType.fromJson(type.name), equals(type));
      }
    });

    test('fromJson throws on invalid name', () {
      expect(
        () => BpmMatchType.fromJson('invalid'),
        throwsA(isA<StateError>()),
      );
    });
  });

  // -- BpmSong.fromApiJson -----------------------------------------------------

  group('BpmSong.fromApiJson', () {
    test('parses a complete API response item', () {
      final json = {
        'song_id': 'abc123',
        'song_title': 'Test Song',
        'song_uri': 'https://getsongbpm.com/song/test/abc123',
        'tempo': '170',
        'artist': {
          'id': 'xyz789',
          'name': 'Test Artist',
          'uri': 'https://getsongbpm.com/artist/test/xyz789',
        },
        'album': {
          'title': 'Test Album',
          'uri': 'https://getsongbpm.com/album/test/def456',
        },
      };

      final song = BpmSong.fromApiJson(json);
      expect(song.songId, equals('abc123'));
      expect(song.title, equals('Test Song'));
      expect(song.artistName, equals('Test Artist'));
      expect(song.tempo, equals(170));
      expect(
        song.songUri,
        equals('https://getsongbpm.com/song/test/abc123'),
      );
      expect(
        song.artistUri,
        equals('https://getsongbpm.com/artist/test/xyz789'),
      );
      expect(song.albumTitle, equals('Test Album'));
      expect(song.matchType, equals(BpmMatchType.exact));
    });

    test('parses tempo as string to int', () {
      final json = {
        'song_id': 's1',
        'song_title': 'Song',
        'tempo': '85',
        'artist': {'name': 'A'},
      };
      final song = BpmSong.fromApiJson(json);
      expect(song.tempo, equals(85));
    });

    test('defaults to 0 when tempo is invalid string', () {
      final json = {
        'song_id': 's1',
        'song_title': 'Song',
        'tempo': 'not-a-number',
        'artist': {'name': 'A'},
      };
      final song = BpmSong.fromApiJson(json);
      expect(song.tempo, equals(0));
    });

    test('handles missing optional fields gracefully', () {
      final json = {
        'song_id': 's1',
        'song_title': 'Song',
        'tempo': '120',
        'artist': {'name': 'A'},
      };
      final song = BpmSong.fromApiJson(json);
      expect(song.songUri, isNull);
      expect(song.artistUri, isNull);
      expect(song.albumTitle, isNull);
    });

    test('handles null artist and album gracefully', () {
      final json = {
        'song_id': 's1',
        'song_title': 'Song',
        'tempo': '120',
      };
      final song = BpmSong.fromApiJson(json);
      expect(song.artistName, equals(''));
      expect(song.albumTitle, isNull);
    });

    test('accepts matchType parameter', () {
      final json = {
        'song_id': 's1',
        'song_title': 'Song',
        'tempo': '85',
        'artist': {'name': 'A'},
      };
      final song = BpmSong.fromApiJson(json, matchType: BpmMatchType.halfTime);
      expect(song.matchType, equals(BpmMatchType.halfTime));
    });
  });

  // -- BpmSong.toJson / fromJson round-trip ------------------------------------

  group('BpmSong serialization', () {
    test('toJson -> fromJson round-trip preserves core fields', () {
      const original = BpmSong(
        songId: 'abc',
        title: 'My Song',
        artistName: 'My Artist',
        tempo: 170,
        songUri: 'https://example.com/song',
        artistUri: 'https://example.com/artist',
        albumTitle: 'My Album',
        matchType: BpmMatchType.halfTime,
      );
      final json = original.toJson();
      final restored = BpmSong.fromJson(json);
      expect(restored.songId, equals(original.songId));
      expect(restored.title, equals(original.title));
      expect(restored.artistName, equals(original.artistName));
      expect(restored.tempo, equals(original.tempo));
      expect(restored.songUri, equals(original.songUri));
      expect(restored.artistUri, equals(original.artistUri));
      expect(restored.albumTitle, equals(original.albumTitle));
    });

    test('toJson excludes matchType', () {
      const song = BpmSong(
        songId: 'abc',
        title: 'Song',
        artistName: 'Artist',
        tempo: 170,
        matchType: BpmMatchType.halfTime,
      );
      final json = song.toJson();
      expect(json.containsKey('matchType'), isFalse);
    });

    test('fromJson defaults matchType to exact when key absent', () {
      final json = {
        'songId': 'abc',
        'title': 'Song',
        'artistName': 'Artist',
        'tempo': 170,
      };
      final song = BpmSong.fromJson(json);
      expect(song.matchType, equals(BpmMatchType.exact));
    });

    test('round-trip with null optional fields', () {
      const original = BpmSong(
        songId: 'abc',
        title: 'Song',
        artistName: 'Artist',
        tempo: 120,
      );
      final json = original.toJson();
      final restored = BpmSong.fromJson(json);
      expect(restored.songUri, isNull);
      expect(restored.artistUri, isNull);
      expect(restored.albumTitle, isNull);
    });
  });

  // -- BpmSong.withMatchType ---------------------------------------------------

  group('BpmSong.withMatchType', () {
    test('creates copy with new matchType', () {
      const song = BpmSong(
        songId: 'abc',
        title: 'Song',
        artistName: 'Artist',
        tempo: 85,
        matchType: BpmMatchType.exact,
      );
      final halfTime = song.withMatchType(BpmMatchType.halfTime);
      expect(halfTime.matchType, equals(BpmMatchType.halfTime));
      expect(halfTime.songId, equals('abc'));
      expect(halfTime.title, equals('Song'));
      expect(halfTime.tempo, equals(85));
    });
  });
}
```

**3c. Create `test/features/bpm_lookup/domain/bpm_matcher_test.dart`:**

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_matcher.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';

void main() {
  group('BpmMatcher', () {
    test('constants are reasonable', () {
      expect(BpmMatcher.maxQueryBpm, equals(300));
      expect(BpmMatcher.minQueryBpm, equals(40));
    });
  });

  group('BpmMatcher.bpmQueries', () {
    test('170 BPM returns exact and half-time, no double-time', () {
      final queries = BpmMatcher.bpmQueries(170);
      expect(queries[170], equals(BpmMatchType.exact));
      expect(queries[85], equals(BpmMatchType.halfTime));
      // 170 * 2 = 340 > maxQueryBpm (300), so no double-time
      expect(queries.containsKey(340), isFalse);
      expect(queries.length, equals(2));
    });

    test('85 BPM returns exact, half-time, and double-time', () {
      final queries = BpmMatcher.bpmQueries(85);
      expect(queries[85], equals(BpmMatchType.exact));
      expect(queries[170], equals(BpmMatchType.doubleTime));
      // 85 ~/ 2 = 42, >= minQueryBpm (40)
      expect(queries[42], equals(BpmMatchType.halfTime));
      expect(queries.length, equals(3));
    });

    test('120 BPM returns exact, half-time, and double-time', () {
      final queries = BpmMatcher.bpmQueries(120);
      expect(queries[120], equals(BpmMatchType.exact));
      expect(queries[60], equals(BpmMatchType.halfTime));
      expect(queries[240], equals(BpmMatchType.doubleTime));
      expect(queries.length, equals(3));
    });

    test('150 BPM returns exact, half-time, and double-time', () {
      final queries = BpmMatcher.bpmQueries(150);
      expect(queries[150], equals(BpmMatchType.exact));
      expect(queries[75], equals(BpmMatchType.halfTime));
      // 150 * 2 = 300, exactly at limit, should be included
      expect(queries[300], equals(BpmMatchType.doubleTime));
      expect(queries.length, equals(3));
    });

    test('70 BPM excludes half-time below minQueryBpm', () {
      final queries = BpmMatcher.bpmQueries(70);
      expect(queries[70], equals(BpmMatchType.exact));
      // 70 ~/ 2 = 35, < minQueryBpm (40), excluded
      expect(queries.containsKey(35), isFalse);
      expect(queries[140], equals(BpmMatchType.doubleTime));
      expect(queries.length, equals(2));
    });

    test('40 BPM at minQueryBpm boundary', () {
      final queries = BpmMatcher.bpmQueries(40);
      expect(queries[40], equals(BpmMatchType.exact));
      // 40 ~/ 2 = 20, < minQueryBpm, excluded
      expect(queries.containsKey(20), isFalse);
      expect(queries[80], equals(BpmMatchType.doubleTime));
      expect(queries.length, equals(2));
    });

    test('always includes exact match', () {
      final queries = BpmMatcher.bpmQueries(200);
      expect(queries[200], equals(BpmMatchType.exact));
    });
  });
}
```

**3d. Create `test/features/bpm_lookup/data/getsongbpm_client_test.dart`:**

```dart
import 'dart:convert';

import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:http/testing.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/getsongbpm_client.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';

void main() {
  // -- BpmApiException ---------------------------------------------------------

  group('BpmApiException', () {
    test('toString includes message and status code', () {
      const e = BpmApiException('test error', statusCode: 500);
      expect(e.toString(), contains('test error'));
      expect(e.toString(), contains('500'));
    });

    test('statusCode can be null', () {
      const e = BpmApiException('network error');
      expect(e.statusCode, isNull);
    });
  });

  // -- GetSongBpmClient.fetchSongsByBpm ----------------------------------------

  group('GetSongBpmClient.fetchSongsByBpm', () {
    test('sends correct URL with api_key and bpm params', () async {
      Uri? capturedUri;
      final mockClient = MockClient((request) async {
        capturedUri = request.url;
        return http.Response(jsonEncode({'tempo': []}), 200);
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key-123',
        httpClient: mockClient,
      );

      await client.fetchSongsByBpm(170);

      expect(capturedUri, isNotNull);
      expect(capturedUri!.scheme, equals('https'));
      expect(capturedUri!.host, equals('api.getsongbpm.com'));
      expect(capturedUri!.path, equals('/tempo/'));
      expect(capturedUri!.queryParameters['api_key'], equals('test-key-123'));
      expect(capturedUri!.queryParameters['bpm'], equals('170'));
    });

    test('parses API response into BpmSong list', () async {
      final mockClient = MockClient((request) async {
        return http.Response(
          jsonEncode({
            'tempo': [
              {
                'song_id': 'abc123',
                'song_title': 'Test Song',
                'song_uri': 'https://getsongbpm.com/song/test/abc123',
                'tempo': '170',
                'artist': {
                  'id': 'xyz789',
                  'name': 'Test Artist',
                  'uri': 'https://getsongbpm.com/artist/test/xyz789',
                },
                'album': {
                  'title': 'Test Album',
                  'uri': 'https://getsongbpm.com/album/test/def456',
                },
              },
            ],
          }),
          200,
        );
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: mockClient,
      );

      final songs = await client.fetchSongsByBpm(170);
      expect(songs.length, equals(1));
      expect(songs.first.songId, equals('abc123'));
      expect(songs.first.title, equals('Test Song'));
      expect(songs.first.artistName, equals('Test Artist'));
      expect(songs.first.tempo, equals(170));
      expect(songs.first.albumTitle, equals('Test Album'));
      expect(songs.first.matchType, equals(BpmMatchType.exact));
    });

    test('passes matchType to parsed songs', () async {
      final mockClient = MockClient((request) async {
        return http.Response(
          jsonEncode({
            'tempo': [
              {
                'song_id': 's1',
                'song_title': 'Half Song',
                'tempo': '85',
                'artist': {'name': 'A'},
              },
            ],
          }),
          200,
        );
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: mockClient,
      );

      final songs = await client.fetchSongsByBpm(
        85,
        matchType: BpmMatchType.halfTime,
      );
      expect(songs.first.matchType, equals(BpmMatchType.halfTime));
    });

    test('returns empty list when tempo array is empty', () async {
      final mockClient = MockClient((request) async {
        return http.Response(jsonEncode({'tempo': []}), 200);
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: mockClient,
      );

      final songs = await client.fetchSongsByBpm(999);
      expect(songs, isEmpty);
    });

    test('returns empty list when tempo key is missing', () async {
      final mockClient = MockClient((request) async {
        return http.Response(jsonEncode({}), 200);
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: mockClient,
      );

      final songs = await client.fetchSongsByBpm(999);
      expect(songs, isEmpty);
    });

    test('throws BpmApiException on non-200 status code', () async {
      final mockClient = MockClient((request) async {
        return http.Response('Server Error', 500);
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: mockClient,
      );

      expect(
        () => client.fetchSongsByBpm(170),
        throwsA(
          isA<BpmApiException>().having(
            (e) => e.statusCode,
            'statusCode',
            equals(500),
          ),
        ),
      );
    });

    test('throws BpmApiException on 429 rate limit', () async {
      final mockClient = MockClient((request) async {
        return http.Response('Too Many Requests', 429);
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: mockClient,
      );

      expect(
        () => client.fetchSongsByBpm(170),
        throwsA(
          isA<BpmApiException>().having(
            (e) => e.statusCode,
            'statusCode',
            equals(429),
          ),
        ),
      );
    });

    test('throws FormatException on invalid JSON response', () async {
      final mockClient = MockClient((request) async {
        return http.Response('not valid json', 200);
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: mockClient,
      );

      expect(
        () => client.fetchSongsByBpm(170),
        throwsA(isA<FormatException>()),
      );
    });

    test('parses multiple songs', () async {
      final mockClient = MockClient((request) async {
        return http.Response(
          jsonEncode({
            'tempo': [
              {
                'song_id': 's1',
                'song_title': 'Song One',
                'tempo': '170',
                'artist': {'name': 'Artist A'},
              },
              {
                'song_id': 's2',
                'song_title': 'Song Two',
                'tempo': '170',
                'artist': {'name': 'Artist B'},
              },
              {
                'song_id': 's3',
                'song_title': 'Song Three',
                'tempo': '170',
                'artist': {'name': 'Artist C'},
              },
            ],
          }),
          200,
        );
      });

      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: mockClient,
      );

      final songs = await client.fetchSongsByBpm(170);
      expect(songs.length, equals(3));
      expect(songs[0].title, equals('Song One'));
      expect(songs[1].title, equals('Song Two'));
      expect(songs[2].title, equals('Song Three'));
    });
  });
}
```
  </action>
  <verify>
Run `flutter test test/features/bpm_lookup/` -- all tests pass. Run `dart analyze lib/features/bpm_lookup/ test/features/bpm_lookup/` -- no errors or warnings.
  </verify>
  <done>
GetSongBpmClient with MockClient injection, BpmApiException, 10s timeout, and correct URL construction. All unit tests pass: BpmMatchType (3 tests), BpmSong.fromApiJson (6 tests), BpmSong serialization (4 tests), BpmSong.withMatchType (1 test), BpmMatcher.bpmQueries (7 tests), BpmApiException (2 tests), GetSongBpmClient (9 tests). Total: ~32 tests passing.
  </done>
</task>

</tasks>

<verification>
1. `flutter pub get` succeeds with http dependency
2. `dart analyze lib/features/bpm_lookup/` reports no issues
3. `flutter test test/features/bpm_lookup/` -- all tests pass
4. Both macOS entitlements files contain `com.apple.security.network.client`
5. `grep -r "import 'package:flutter" lib/features/bpm_lookup/domain/` returns nothing (domain is pure Dart)
</verification>

<success_criteria>
- BpmSong model parses GetSongBPM API /tempo/ response items correctly (string tempo, nested artist/album)
- BpmSong.toJson excludes matchType; fromJson defaults it to exact
- BpmMatcher.bpmQueries returns correct exact/half/double queries with 40-300 BPM bounds
- GetSongBpmClient uses http.Client injection, constructs correct URL, throws BpmApiException on errors
- All ~32 unit tests pass
- macOS can make outbound HTTP requests (entitlements configured)
- http package added to pubspec.yaml
</success_criteria>

<output>
After completion, create `.planning/phases/13-bpm-data-pipeline/13-01-SUMMARY.md`
</output>
