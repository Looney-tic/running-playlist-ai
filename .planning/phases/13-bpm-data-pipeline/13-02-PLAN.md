---
phase: 13-bpm-data-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - lib/features/bpm_lookup/data/bpm_cache_preferences.dart
  - lib/features/bpm_lookup/providers/bpm_lookup_providers.dart
  - test/features/bpm_lookup/data/bpm_cache_preferences_test.dart
  - test/features/bpm_lookup/providers/bpm_lookup_providers_test.dart
autonomous: true

must_haves:
  truths:
    - "Repeating the same BPM lookup loads results from local cache without making an API call"
    - "Cached BPM results expire after 7 days and trigger a fresh API fetch"
    - "BpmLookupNotifier.lookupByBpm(170) queries both 170 (exact) and 85 (half-time) and merges results"
    - "A query for 85 BPM returns songs with exact matchType; the same songs appear with halfTime matchType when queried as part of a 170 BPM target lookup"
    - "When the API is unreachable, BpmLookupState.error contains a user-friendly message and songs is empty"
    - "BpmApiException, SocketException, TimeoutException, and FormatException each produce a distinct error message"
    - "bpmLookupProvider reads the API key from dotenv.env['GETSONGBPM_API_KEY']"
  artifacts:
    - path: "lib/features/bpm_lookup/data/bpm_cache_preferences.dart"
      provides: "Per-BPM SharedPreferences cache with 7-day TTL"
      contains: "class BpmCachePreferences"
    - path: "lib/features/bpm_lookup/providers/bpm_lookup_providers.dart"
      provides: "BpmLookupState, BpmLookupNotifier, and bpmLookupProvider"
      contains: "class BpmLookupNotifier extends StateNotifier"
    - path: "test/features/bpm_lookup/data/bpm_cache_preferences_test.dart"
      provides: "Unit tests for BPM cache load/save/clear/TTL"
      contains: "group('BpmCachePreferences'"
    - path: "test/features/bpm_lookup/providers/bpm_lookup_providers_test.dart"
      provides: "Unit tests for BpmLookupNotifier cache-first strategy and error handling"
      contains: "group('BpmLookupNotifier'"
  key_links:
    - from: "lib/features/bpm_lookup/providers/bpm_lookup_providers.dart"
      to: "lib/features/bpm_lookup/data/bpm_cache_preferences.dart"
      via: "Cache-first lookup: check cache before API call"
      pattern: "BpmCachePreferences\\.load"
    - from: "lib/features/bpm_lookup/providers/bpm_lookup_providers.dart"
      to: "lib/features/bpm_lookup/data/getsongbpm_client.dart"
      via: "API fallback when cache misses, then withMatchType for contextual match type"
      pattern: "_client\\.fetchSongsByBpm"
    - from: "lib/features/bpm_lookup/providers/bpm_lookup_providers.dart"
      to: "lib/features/bpm_lookup/domain/bpm_matcher.dart"
      via: "BpmMatcher.bpmQueries determines which BPMs to query"
      pattern: "BpmMatcher\\.bpmQueries"
    - from: "lib/features/bpm_lookup/providers/bpm_lookup_providers.dart"
      to: "package:flutter_dotenv"
      via: "API key read from dotenv.env"
      pattern: "dotenv\\.env\\['GETSONGBPM_API_KEY'\\]"
---

<objective>
Build the cache layer, state management, and provider integration for the BPM data pipeline: local SharedPreferences caching with 7-day TTL, a cache-first BpmLookupNotifier that orchestrates multi-BPM queries (exact + half/double-time), comprehensive error handling, and the top-level provider wired to the dotenv API key.

Purpose: This plan completes Phase 13 by connecting the domain models and API client (from Plan 13-01) into a fully usable data pipeline. After this plan, Phase 14 (playlist generation) can call `bpmLookupProvider` to discover songs by BPM with automatic caching and error handling.

Output: 2 production files (bpm_cache_preferences.dart, bpm_lookup_providers.dart), 2 test files, all Phase 13 requirements (BPM-10 through BPM-13) satisfied.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-bpm-data-pipeline/13-RESEARCH.md
@.planning/phases/13-bpm-data-pipeline/13-01-SUMMARY.md

@lib/features/bpm_lookup/domain/bpm_song.dart
@lib/features/bpm_lookup/domain/bpm_matcher.dart
@lib/features/bpm_lookup/data/getsongbpm_client.dart
@lib/features/run_plan/data/run_plan_preferences.dart
@lib/features/run_plan/providers/run_plan_providers.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BpmCachePreferences and its unit tests</name>
  <files>
    lib/features/bpm_lookup/data/bpm_cache_preferences.dart
    test/features/bpm_lookup/data/bpm_cache_preferences_test.dart
  </files>
  <action>
**1a. Create `lib/features/bpm_lookup/data/bpm_cache_preferences.dart`:**

```dart
import 'dart:convert';

import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Cache for BPM lookup results in SharedPreferences.
///
/// Stores results as JSON strings, keyed by **queried BPM** (not target BPM).
/// Each entry includes a timestamp for TTL-based expiry.
///
/// Songs are cached **without** matchType. The match type is contextual and
/// must be assigned at load time based on the relationship between the cached
/// BPM and the current target BPM.
class BpmCachePreferences {
  static const _prefix = 'bpm_cache_';

  /// Cache time-to-live: 7 days.
  static const cacheTtl = Duration(days: 7);

  /// Loads cached songs for a [bpm] value, or null if not cached / expired.
  ///
  /// Returns songs with [BpmMatchType.exact] as the default matchType.
  /// The caller is responsible for reassigning the correct matchType.
  static Future<List<BpmSong>?> load(int bpm) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString('$_prefix$bpm');
    if (jsonString == null) return null;

    final json = jsonDecode(jsonString) as Map<String, dynamic>;

    // Check TTL
    final cachedAt = DateTime.parse(json['cachedAt'] as String);
    if (DateTime.now().difference(cachedAt) > cacheTtl) {
      await prefs.remove('$_prefix$bpm');
      return null;
    }

    final songs = (json['songs'] as List<dynamic>)
        .map((s) => BpmSong.fromJson(s as Map<String, dynamic>))
        .toList();
    return songs;
  }

  /// Saves songs for a [bpm] value with a timestamp.
  ///
  /// Songs are stored via [BpmSong.toJson], which excludes matchType.
  static Future<void> save(int bpm, List<BpmSong> songs) async {
    final prefs = await SharedPreferences.getInstance();
    final json = {
      'cachedAt': DateTime.now().toIso8601String(),
      'songs': songs.map((s) => s.toJson()).toList(),
    };
    await prefs.setString('$_prefix$bpm', jsonEncode(json));
  }

  /// Clears a specific BPM cache entry.
  static Future<void> clear(int bpm) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove('$_prefix$bpm');
  }

  /// Clears all BPM cache entries.
  static Future<void> clearAll() async {
    final prefs = await SharedPreferences.getInstance();
    final keys = prefs.getKeys().where((k) => k.startsWith(_prefix));
    for (final key in keys) {
      await prefs.remove(key);
    }
  }
}
```

**1b. Create `test/features/bpm_lookup/data/bpm_cache_preferences_test.dart`:**

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/bpm_cache_preferences.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() {
  // Reset SharedPreferences before each test
  setUp(() {
    SharedPreferences.setMockInitialValues({});
  });

  group('BpmCachePreferences', () {
    test('cacheTtl is 7 days', () {
      expect(BpmCachePreferences.cacheTtl, equals(const Duration(days: 7)));
    });
  });

  group('BpmCachePreferences.save and load', () {
    test('saves and loads songs for a BPM value', () async {
      final songs = [
        const BpmSong(
          songId: 'abc',
          title: 'Song A',
          artistName: 'Artist A',
          tempo: 170,
        ),
        const BpmSong(
          songId: 'def',
          title: 'Song B',
          artistName: 'Artist B',
          tempo: 170,
          albumTitle: 'Album B',
        ),
      ];

      await BpmCachePreferences.save(170, songs);
      final loaded = await BpmCachePreferences.load(170);

      expect(loaded, isNotNull);
      expect(loaded!.length, equals(2));
      expect(loaded[0].songId, equals('abc'));
      expect(loaded[0].title, equals('Song A'));
      expect(loaded[1].songId, equals('def'));
      expect(loaded[1].albumTitle, equals('Album B'));
    });

    test('returns null for uncached BPM', () async {
      final result = await BpmCachePreferences.load(999);
      expect(result, isNull);
    });

    test('caches per BPM value (170 and 85 are separate)', () async {
      final songs170 = [
        const BpmSong(
          songId: 's1',
          title: 'Fast Song',
          artistName: 'A',
          tempo: 170,
        ),
      ];
      final songs85 = [
        const BpmSong(
          songId: 's2',
          title: 'Slow Song',
          artistName: 'B',
          tempo: 85,
        ),
      ];

      await BpmCachePreferences.save(170, songs170);
      await BpmCachePreferences.save(85, songs85);

      final loaded170 = await BpmCachePreferences.load(170);
      final loaded85 = await BpmCachePreferences.load(85);

      expect(loaded170!.first.title, equals('Fast Song'));
      expect(loaded85!.first.title, equals('Slow Song'));
    });

    test('loaded songs default to exact matchType', () async {
      final songs = [
        const BpmSong(
          songId: 'abc',
          title: 'Song',
          artistName: 'Artist',
          tempo: 170,
          matchType: BpmMatchType.halfTime,
        ),
      ];

      await BpmCachePreferences.save(170, songs);
      final loaded = await BpmCachePreferences.load(170);

      // matchType is NOT stored in cache, so loaded songs get default (exact)
      expect(loaded!.first.matchType, equals(BpmMatchType.exact));
    });

    test('preserves optional fields through save/load cycle', () async {
      final songs = [
        const BpmSong(
          songId: 'abc',
          title: 'Song',
          artistName: 'Artist',
          tempo: 120,
          songUri: 'https://example.com/song',
          artistUri: 'https://example.com/artist',
          albumTitle: 'Album',
        ),
      ];

      await BpmCachePreferences.save(120, songs);
      final loaded = await BpmCachePreferences.load(120);

      expect(loaded!.first.songUri, equals('https://example.com/song'));
      expect(loaded.first.artistUri, equals('https://example.com/artist'));
      expect(loaded.first.albumTitle, equals('Album'));
    });

    test('saves empty list without error', () async {
      await BpmCachePreferences.save(200, []);
      final loaded = await BpmCachePreferences.load(200);
      expect(loaded, isNotNull);
      expect(loaded, isEmpty);
    });
  });

  group('BpmCachePreferences.clear', () {
    test('clears a specific BPM entry', () async {
      final songs = [
        const BpmSong(
          songId: 'abc',
          title: 'Song',
          artistName: 'A',
          tempo: 170,
        ),
      ];

      await BpmCachePreferences.save(170, songs);
      await BpmCachePreferences.clear(170);
      final loaded = await BpmCachePreferences.load(170);

      expect(loaded, isNull);
    });

    test('clearing one BPM does not affect another', () async {
      await BpmCachePreferences.save(170, [
        const BpmSong(
          songId: 'a',
          title: 'A',
          artistName: 'A',
          tempo: 170,
        ),
      ]);
      await BpmCachePreferences.save(85, [
        const BpmSong(
          songId: 'b',
          title: 'B',
          artistName: 'B',
          tempo: 85,
        ),
      ]);

      await BpmCachePreferences.clear(170);

      expect(await BpmCachePreferences.load(170), isNull);
      expect(await BpmCachePreferences.load(85), isNotNull);
    });
  });

  group('BpmCachePreferences.clearAll', () {
    test('clears all BPM cache entries', () async {
      await BpmCachePreferences.save(170, [
        const BpmSong(
          songId: 'a',
          title: 'A',
          artistName: 'A',
          tempo: 170,
        ),
      ]);
      await BpmCachePreferences.save(85, [
        const BpmSong(
          songId: 'b',
          title: 'B',
          artistName: 'B',
          tempo: 85,
        ),
      ]);

      await BpmCachePreferences.clearAll();

      expect(await BpmCachePreferences.load(170), isNull);
      expect(await BpmCachePreferences.load(85), isNull);
    });
  });

  group('BpmCachePreferences TTL', () {
    test('returns null and removes entry when cache is expired', () async {
      // Manually write a cache entry with an old timestamp
      final prefs = await SharedPreferences.getInstance();
      final oldDate =
          DateTime.now().subtract(const Duration(days: 8)).toIso8601String();
      final json = '{"cachedAt":"$oldDate","songs":[{"songId":"old","title":"Old Song","artistName":"A","tempo":170}]}';
      await prefs.setString('bpm_cache_170', json);

      final loaded = await BpmCachePreferences.load(170);
      expect(loaded, isNull);

      // Verify the expired entry was cleaned up
      expect(prefs.getString('bpm_cache_170'), isNull);
    });

    test('returns songs when cache is within TTL', () async {
      // Manually write a cache entry with a recent timestamp
      final prefs = await SharedPreferences.getInstance();
      final recentDate =
          DateTime.now().subtract(const Duration(days: 6)).toIso8601String();
      final json = '{"cachedAt":"$recentDate","songs":[{"songId":"new","title":"New Song","artistName":"A","tempo":170}]}';
      await prefs.setString('bpm_cache_170', json);

      final loaded = await BpmCachePreferences.load(170);
      expect(loaded, isNotNull);
      expect(loaded!.first.title, equals('New Song'));
    });
  });
}
```
  </action>
  <verify>
Run `flutter test test/features/bpm_lookup/data/bpm_cache_preferences_test.dart` -- all tests pass. Run `dart analyze lib/features/bpm_lookup/data/bpm_cache_preferences.dart` -- no issues.
  </verify>
  <done>
BpmCachePreferences with per-BPM keys (bpm_cache_170, bpm_cache_85, etc.), 7-day TTL with auto-cleanup, and matchType excluded from cache. All ~14 cache tests pass including TTL boundary tests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BpmLookupState, BpmLookupNotifier, provider, and unit tests</name>
  <files>
    lib/features/bpm_lookup/providers/bpm_lookup_providers.dart
    test/features/bpm_lookup/providers/bpm_lookup_providers_test.dart
  </files>
  <action>
**2a. Create `lib/features/bpm_lookup/providers/bpm_lookup_providers.dart`:**

```dart
import 'dart:async';
import 'dart:io';

import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/bpm_cache_preferences.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/getsongbpm_client.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_matcher.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';

/// State for a BPM lookup operation.
class BpmLookupState {
  const BpmLookupState({
    this.songs = const [],
    this.isLoading = false,
    this.error,
    this.targetBpm,
  });

  final List<BpmSong> songs;
  final bool isLoading;
  final String? error;
  final int? targetBpm;
}

/// Orchestrates BPM song lookup with cache-first strategy and error handling.
///
/// For a given target BPM, this notifier:
/// 1. Computes exact + half/double-time BPM values via [BpmMatcher]
/// 2. Checks [BpmCachePreferences] for each BPM value (cache-first)
/// 3. Falls back to [GetSongBpmClient] API on cache miss
/// 4. Saves API results to cache for future lookups
/// 5. Assigns the correct [BpmMatchType] to each song based on context
/// 6. Merges all results and updates state
class BpmLookupNotifier extends StateNotifier<BpmLookupState> {
  BpmLookupNotifier(this._client) : super(const BpmLookupState());

  final GetSongBpmClient _client;

  /// Looks up songs for the given [targetBpm].
  ///
  /// Uses cache-first strategy: checks local cache before hitting the API.
  /// Queries multiple BPM values (exact + half/double-time) and merges results.
  Future<void> lookupByBpm(int targetBpm) async {
    state = BpmLookupState(isLoading: true, targetBpm: targetBpm);

    try {
      // Determine which BPM values to query (exact + half + double)
      final queries = BpmMatcher.bpmQueries(targetBpm);
      final allSongs = <BpmSong>[];

      for (final entry in queries.entries) {
        final bpm = entry.key;
        final matchType = entry.value;

        // Cache-first: check local cache
        var songs = await BpmCachePreferences.load(bpm);

        if (songs == null) {
          // Cache miss: fetch from API
          songs = await _client.fetchSongsByBpm(bpm);
          // Save raw songs (without matchType) to cache
          await BpmCachePreferences.save(bpm, songs);
        }

        // Assign matchType based on relationship to target BPM
        final typed = songs.map((s) => s.withMatchType(matchType)).toList();
        allSongs.addAll(typed);
      }

      state = BpmLookupState(songs: allSongs, targetBpm: targetBpm);
    } on SocketException {
      state = BpmLookupState(
        error:
            'No internet connection. Please check your network and try again.',
        targetBpm: targetBpm,
      );
    } on TimeoutException {
      state = BpmLookupState(
        error: 'Request timed out. Please try again.',
        targetBpm: targetBpm,
      );
    } on BpmApiException catch (e) {
      state = BpmLookupState(
        error: 'Could not fetch songs: ${e.message}',
        targetBpm: targetBpm,
      );
    } on FormatException {
      state = BpmLookupState(
        error: 'Received unexpected data from the server.',
        targetBpm: targetBpm,
      );
    } catch (e) {
      state = BpmLookupState(
        error: 'An unexpected error occurred. Please try again.',
        targetBpm: targetBpm,
      );
    }
  }

  /// Clears the current lookup results.
  void clear() {
    state = const BpmLookupState();
  }
}

/// Provides a [GetSongBpmClient] configured with the API key from `.env`.
final getSongBpmClientProvider = Provider<GetSongBpmClient>((ref) {
  final apiKey = dotenv.env['GETSONGBPM_API_KEY'] ?? '';
  final client = GetSongBpmClient(apiKey: apiKey);
  ref.onDispose(client.dispose);
  return client;
});

/// Provides [BpmLookupNotifier] and the current [BpmLookupState].
///
/// Usage:
/// - `ref.watch(bpmLookupProvider)` to read the current state reactively
/// - `ref.read(bpmLookupProvider.notifier).lookupByBpm(170)` to trigger lookup
/// - `ref.read(bpmLookupProvider.notifier).clear()` to reset
final bpmLookupProvider =
    StateNotifierProvider<BpmLookupNotifier, BpmLookupState>((ref) {
  final client = ref.watch(getSongBpmClientProvider);
  return BpmLookupNotifier(client);
});
```

IMPORTANT DESIGN DECISIONS:
- `fetchSongsByBpm(bpm)` is called WITHOUT matchType -- raw songs are cached.
- After loading from cache or API, `withMatchType(matchType)` is called to assign the contextual match type.
- This prevents Pitfall 5: cache at BPM 85 always stores raw songs. When loaded as part of a 170 target query, they get halfTime. When loaded as part of an 85 direct query, they get exact.
- The `getSongBpmClientProvider` reads the API key from dotenv and disposes the client on ref disposal.
- Error handling covers all 5 exception types from RESEARCH.md with distinct user-facing messages.

**2b. Create `test/features/bpm_lookup/providers/bpm_lookup_providers_test.dart`:**

```dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:http/testing.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/bpm_cache_preferences.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/getsongbpm_client.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:running_playlist_ai/features/bpm_lookup/providers/bpm_lookup_providers.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Helper to create a GetSongBpmClient with a MockClient.
GetSongBpmClient _clientWithMock(
  Future<http.Response> Function(http.Request) handler,
) {
  return GetSongBpmClient(
    apiKey: 'test-key',
    httpClient: MockClient(handler),
  );
}

/// Helper to build a valid API response body for a list of songs.
String _apiResponseBody(List<Map<String, dynamic>> songs) {
  return jsonEncode({'tempo': songs});
}

/// Helper API song JSON.
Map<String, dynamic> _apiSong({
  String id = 's1',
  String title = 'Song',
  String tempo = '170',
  String artist = 'Artist',
}) =>
    {
      'song_id': id,
      'song_title': title,
      'tempo': tempo,
      'artist': {'name': artist},
    };

void main() {
  setUp(() {
    SharedPreferences.setMockInitialValues({});
  });

  // -- BpmLookupState ----------------------------------------------------------

  group('BpmLookupState', () {
    test('default state has empty songs, not loading, no error', () {
      const state = BpmLookupState();
      expect(state.songs, isEmpty);
      expect(state.isLoading, isFalse);
      expect(state.error, isNull);
      expect(state.targetBpm, isNull);
    });
  });

  // -- BpmLookupNotifier: successful lookups -----------------------------------

  group('BpmLookupNotifier successful lookups', () {
    test('lookupByBpm returns songs from API', () async {
      final client = _clientWithMock((request) async {
        return http.Response(
          _apiResponseBody([_apiSong(title: 'Test Song', tempo: '170')]),
          200,
        );
      });

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      expect(notifier.state.isLoading, isFalse);
      expect(notifier.state.error, isNull);
      expect(notifier.state.targetBpm, equals(170));
      expect(notifier.state.songs, isNotEmpty);
      // Should have songs from exact (170) + half-time (85) queries
      // Both return results since the mock responds to all requests
    });

    test('lookupByBpm sets isLoading to true during fetch', () async {
      var sawLoading = false;

      final client = _clientWithMock((request) async {
        // Verify notifier state during the API call is not easily done
        // because the mock is synchronous. Rely on state transition tests.
        return http.Response(
          _apiResponseBody([_apiSong()]),
          200,
        );
      });

      final notifier = BpmLookupNotifier(client);

      // Add a listener to capture state transitions
      notifier.addListener((state) {
        if (state.isLoading) sawLoading = true;
      });

      await notifier.lookupByBpm(170);
      expect(sawLoading, isTrue);
    });

    test('lookupByBpm assigns correct matchType to songs', () async {
      final client = _clientWithMock((request) async {
        final bpm = request.url.queryParameters['bpm'];
        if (bpm == '170') {
          return http.Response(
            _apiResponseBody([_apiSong(id: 'exact', tempo: '170')]),
            200,
          );
        } else if (bpm == '85') {
          return http.Response(
            _apiResponseBody([_apiSong(id: 'half', tempo: '85')]),
            200,
          );
        }
        return http.Response(_apiResponseBody([]), 200);
      });

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      final exactSong =
          notifier.state.songs.where((s) => s.songId == 'exact').first;
      final halfSong =
          notifier.state.songs.where((s) => s.songId == 'half').first;

      expect(exactSong.matchType, equals(BpmMatchType.exact));
      expect(halfSong.matchType, equals(BpmMatchType.halfTime));
    });
  });

  // -- BpmLookupNotifier: cache-first strategy ---------------------------------

  group('BpmLookupNotifier cache-first', () {
    test('uses cached results instead of making API call', () async {
      // Pre-populate cache for BPM 170
      await BpmCachePreferences.save(170, [
        const BpmSong(
          songId: 'cached',
          title: 'Cached Song',
          artistName: 'A',
          tempo: 170,
        ),
      ]);

      var apiCallCount = 0;
      final client = _clientWithMock((request) async {
        apiCallCount++;
        final bpm = request.url.queryParameters['bpm'];
        // Only the half-time (85) should hit the API
        return http.Response(
          _apiResponseBody([_apiSong(id: 'api-$bpm', tempo: bpm!)]),
          200,
        );
      });

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      // BPM 170 was cached, so only 85 (half-time) should hit the API
      expect(apiCallCount, equals(1));

      // Both cached and API songs should be in results
      final cachedSong =
          notifier.state.songs.where((s) => s.songId == 'cached');
      expect(cachedSong, isNotEmpty);
    });

    test('saves API results to cache for future lookups', () async {
      final client = _clientWithMock((request) async {
        return http.Response(
          _apiResponseBody([_apiSong(id: 'new-song', title: 'New')]),
          200,
        );
      });

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      // Verify cache was populated for BPM 170
      final cached = await BpmCachePreferences.load(170);
      expect(cached, isNotNull);
      expect(cached!.any((s) => s.songId == 'new-song'), isTrue);
    });

    test('second lookup for same BPM uses cache (zero API calls)', () async {
      var apiCallCount = 0;
      final client = _clientWithMock((request) async {
        apiCallCount++;
        return http.Response(
          _apiResponseBody([_apiSong()]),
          200,
        );
      });

      final notifier = BpmLookupNotifier(client);

      // First lookup -- hits API
      await notifier.lookupByBpm(170);
      final firstCallCount = apiCallCount;

      // Second lookup -- should use cache for all BPM values
      apiCallCount = 0;
      await notifier.lookupByBpm(170);

      expect(apiCallCount, equals(0));
      expect(firstCallCount, greaterThan(0));
    });
  });

  // -- BpmLookupNotifier: error handling ---------------------------------------

  group('BpmLookupNotifier error handling', () {
    test('handles BpmApiException with message', () async {
      final client = _clientWithMock((request) async {
        return http.Response('Server Error', 500);
      });

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      expect(notifier.state.error, isNotNull);
      expect(notifier.state.error, contains('Could not fetch songs'));
      expect(notifier.state.songs, isEmpty);
      expect(notifier.state.isLoading, isFalse);
      expect(notifier.state.targetBpm, equals(170));
    });

    test('handles FormatException from invalid JSON', () async {
      final client = _clientWithMock((request) async {
        return http.Response('not json', 200);
      });

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      expect(notifier.state.error, isNotNull);
      expect(notifier.state.error, contains('unexpected data'));
      expect(notifier.state.songs, isEmpty);
    });

    test('handles SocketException for no network', () async {
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient((request) async {
          throw const SocketException('No network');
        }),
      );

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      expect(notifier.state.error, isNotNull);
      expect(notifier.state.error, contains('No internet connection'));
      expect(notifier.state.songs, isEmpty);
    });

    test('handles TimeoutException', () async {
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient((request) async {
          throw TimeoutException('Timed out');
        }),
      );

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      expect(notifier.state.error, isNotNull);
      expect(notifier.state.error, contains('timed out'));
      expect(notifier.state.songs, isEmpty);
    });

    test('handles unexpected exceptions', () async {
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient((request) async {
          throw Exception('Something weird');
        }),
      );

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      expect(notifier.state.error, isNotNull);
      expect(notifier.state.error, contains('unexpected error'));
      expect(notifier.state.songs, isEmpty);
    });

    test('partial cache hit still works when API fails for uncached BPM',
        () async {
      // Cache BPM 170 (exact) but not 85 (half-time)
      await BpmCachePreferences.save(170, [
        const BpmSong(
          songId: 'cached',
          title: 'Cached',
          artistName: 'A',
          tempo: 170,
        ),
      ]);

      // API fails for the uncached BPM 85
      final client = _clientWithMock((request) async {
        return http.Response('Server Error', 500);
      });

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);

      // Should get an error since the API call for 85 failed
      expect(notifier.state.error, isNotNull);
      expect(notifier.state.songs, isEmpty);
    });
  });

  // -- BpmLookupNotifier.clear -------------------------------------------------

  group('BpmLookupNotifier.clear', () {
    test('resets state to default', () async {
      final client = _clientWithMock((request) async {
        return http.Response(
          _apiResponseBody([_apiSong()]),
          200,
        );
      });

      final notifier = BpmLookupNotifier(client);
      await notifier.lookupByBpm(170);
      expect(notifier.state.songs, isNotEmpty);

      notifier.clear();
      expect(notifier.state.songs, isEmpty);
      expect(notifier.state.isLoading, isFalse);
      expect(notifier.state.error, isNull);
      expect(notifier.state.targetBpm, isNull);
    });
  });
}
```
  </action>
  <verify>
Run `flutter test test/features/bpm_lookup/` -- ALL tests pass (both plan 01 and plan 02 tests). Run `dart analyze lib/features/bpm_lookup/ test/features/bpm_lookup/` -- no errors or warnings.
  </verify>
  <done>
BpmCachePreferences with per-BPM keys, 7-day TTL, matchType exclusion. BpmLookupNotifier with cache-first strategy, multi-BPM queries via BpmMatcher, contextual matchType assignment via withMatchType, and error handling for SocketException/TimeoutException/BpmApiException/FormatException/catch-all. getSongBpmClientProvider reads API key from dotenv. bpmLookupProvider wires client into notifier. All tests pass (~30 tests in this plan, ~60 total across both plans).
  </done>
</task>

</tasks>

<verification>
1. `flutter test test/features/bpm_lookup/` -- ALL tests pass (both plans' tests)
2. `dart analyze lib/features/bpm_lookup/` -- no issues
3. Verify cache-first behavior: the "second lookup uses cache" test passes with 0 API calls
4. Verify matchType assignment: songs at BPM 85 loaded for target 170 have `halfTime` matchType
5. Verify error handling: each exception type produces a distinct, user-friendly error message
6. Verify provider chain: bpmLookupProvider -> getSongBpmClientProvider -> dotenv API key
</verification>

<success_criteria>
- BpmCachePreferences stores/loads songs per queried BPM with 7-day TTL
- Expired cache entries return null and are auto-cleaned
- BpmLookupNotifier uses cache-first strategy (no API call for cached BPM values)
- Second identical lookup makes zero API calls (fully cached)
- matchType is assigned at load time, not stored in cache
- All 5 error types (SocketException, TimeoutException, BpmApiException, FormatException, catch-all) produce distinct user-facing messages
- bpmLookupProvider reads GETSONGBPM_API_KEY from dotenv
- All Phase 13 requirements satisfied: BPM-10 (API discovery), BPM-11 (caching), BPM-12 (half/double-time), BPM-13 (error handling)
</success_criteria>

<output>
After completion, create `.planning/phases/13-bpm-data-pipeline/13-02-SUMMARY.md`
</output>
