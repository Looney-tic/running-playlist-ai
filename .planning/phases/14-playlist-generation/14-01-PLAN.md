---
phase: 14-playlist-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/playlist/domain/playlist.dart
  - lib/features/playlist/domain/song_link_builder.dart
  - lib/features/playlist/domain/playlist_generator.dart
  - test/features/playlist/domain/playlist_test.dart
  - test/features/playlist/domain/song_link_builder_test.dart
  - test/features/playlist/domain/playlist_generator_test.dart
autonomous: true

must_haves:
  truths:
    - "PlaylistSong holds title, artistName, bpm, matchType, segmentLabel, segmentIndex, spotifyUrl, youtubeUrl, and songUri"
    - "Playlist holds a list of PlaylistSong, runPlanName, totalDurationSeconds, and createdAt"
    - "Playlist.toClipboardText() returns a formatted string with segment headers and song lines"
    - "Playlist serializes to JSON and deserializes back without data loss"
    - "SongLinkBuilder.spotifySearchUrl returns https://open.spotify.com/search/{encoded query}"
    - "SongLinkBuilder.youtubeMusicSearchUrl returns https://music.youtube.com/search?q={encoded query}"
    - "PlaylistGenerator.generate produces a playlist covering all segments with BPM-matched songs"
    - "PlaylistGenerator avoids repeating songs across segments"
    - "PlaylistGenerator ranks artist-match songs higher than non-match songs"
    - "PlaylistGenerator falls back to unfiltered BPM matches when no taste-preferred songs exist"
  artifacts:
    - path: "lib/features/playlist/domain/playlist.dart"
      provides: "Playlist and PlaylistSong domain models"
      contains: "class Playlist"
    - path: "lib/features/playlist/domain/song_link_builder.dart"
      provides: "Spotify and YouTube Music search URL construction"
      contains: "class SongLinkBuilder"
    - path: "lib/features/playlist/domain/playlist_generator.dart"
      provides: "Core playlist generation algorithm"
      contains: "class PlaylistGenerator"
    - path: "test/features/playlist/domain/playlist_test.dart"
      provides: "Unit tests for Playlist and PlaylistSong models"
      contains: "group('Playlist'"
    - path: "test/features/playlist/domain/song_link_builder_test.dart"
      provides: "Unit tests for SongLinkBuilder URL construction"
      contains: "group('SongLinkBuilder'"
    - path: "test/features/playlist/domain/playlist_generator_test.dart"
      provides: "Unit tests for PlaylistGenerator algorithm"
      contains: "group('PlaylistGenerator'"
  key_links:
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/bpm_lookup/domain/bpm_song.dart"
      via: "Takes Map<int, List<BpmSong>> as pre-fetched song pool"
      pattern: "Map<int, List<BpmSong>>"
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/run_plan/domain/run_plan.dart"
      via: "Iterates RunPlan.segments to fill each segment with songs"
      pattern: "RunPlan"
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/taste_profile/domain/taste_profile.dart"
      via: "Uses TasteProfile.artists for song scoring/ranking"
      pattern: "TasteProfile"
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/playlist/domain/song_link_builder.dart"
      via: "Constructs Spotify/YouTube URLs for each PlaylistSong"
      pattern: "SongLinkBuilder"
---

<objective>
Create the playlist generation domain layer: Playlist and PlaylistSong models, SongLinkBuilder for external URL construction, PlaylistGenerator algorithm (BPM matching + taste filtering + segment assignment + duration filling + dedup), and comprehensive unit tests.

Purpose: This plan delivers the pure Dart core that the playlist generation notifier (Plan 14-02) and UI (Plan 14-03) depend on. The generator is a synchronous function taking pre-fetched data, making it trivially unit-testable. All async work (API calls, cache reads) is done by the notifier in the next plan.

Output: 3 production files (playlist.dart, song_link_builder.dart, playlist_generator.dart), 3 test files, all pure Dart with no Flutter imports in domain/.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-playlist-generation/14-RESEARCH.md

@lib/features/run_plan/domain/run_plan.dart
@lib/features/taste_profile/domain/taste_profile.dart
@lib/features/bpm_lookup/domain/bpm_song.dart
@lib/features/bpm_lookup/domain/bpm_matcher.dart
@test/features/bpm_lookup/domain/bpm_song_test.dart
@analysis_options.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Playlist and PlaylistSong models with SongLinkBuilder</name>
  <files>
    lib/features/playlist/domain/playlist.dart
    lib/features/playlist/domain/song_link_builder.dart
  </files>
  <action>
**1a. Create `lib/features/playlist/domain/song_link_builder.dart`:**

```dart
/// Pure Dart URL construction for external song links. No Flutter dependencies.
///
/// Builds Spotify and YouTube Music search URLs from song metadata.
/// Search URLs work without any API authentication and open the respective
/// app if installed, or fall back to the web player.
library;

/// Constructs external search URLs for playing songs on Spotify or YouTube Music.
class SongLinkBuilder {
  /// Builds a Spotify search URL for a song.
  ///
  /// Format: `https://open.spotify.com/search/{encoded query}`
  ///
  /// ```dart
  /// SongLinkBuilder.spotifySearchUrl('Lose Yourself', 'Eminem');
  /// // => 'https://open.spotify.com/search/Lose%20Yourself%20Eminem'
  /// ```
  static String spotifySearchUrl(String title, String artist) {
    final query = '$title $artist';
    return 'https://open.spotify.com/search/${Uri.encodeComponent(query)}';
  }

  /// Builds a YouTube Music search URL for a song.
  ///
  /// Format: `https://music.youtube.com/search?q={encoded query}`
  ///
  /// ```dart
  /// SongLinkBuilder.youtubeMusicSearchUrl('Lose Yourself', 'Eminem');
  /// // => 'https://music.youtube.com/search?q=Lose+Yourself+Eminem'
  /// ```
  static String youtubeMusicSearchUrl(String title, String artist) {
    final query = '$title $artist';
    final uri = Uri.https('music.youtube.com', '/search', {'q': query});
    return uri.toString();
  }
}
```

**1b. Create `lib/features/playlist/domain/playlist.dart`:**

```dart
/// Pure Dart domain models for generated playlists. No Flutter dependencies.
///
/// A [Playlist] contains a list of [PlaylistSong]s assigned to run segments.
/// Each song has external play links (Spotify, YouTube Music) and segment metadata.
library;

import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';

/// A song assigned to a specific run segment in the playlist.
class PlaylistSong {
  const PlaylistSong({
    required this.title,
    required this.artistName,
    required this.bpm,
    required this.matchType,
    required this.segmentLabel,
    required this.segmentIndex,
    this.songUri,
    this.spotifyUrl,
    this.youtubeUrl,
  });

  factory PlaylistSong.fromJson(Map<String, dynamic> json) {
    return PlaylistSong(
      title: json['title'] as String,
      artistName: json['artistName'] as String,
      bpm: (json['bpm'] as num).toInt(),
      matchType: BpmMatchType.fromJson(json['matchType'] as String),
      segmentLabel: json['segmentLabel'] as String,
      segmentIndex: (json['segmentIndex'] as num).toInt(),
      songUri: json['songUri'] as String?,
      spotifyUrl: json['spotifyUrl'] as String?,
      youtubeUrl: json['youtubeUrl'] as String?,
    );
  }

  final String title;
  final String artistName;
  final int bpm;
  final BpmMatchType matchType;
  final String segmentLabel;
  final int segmentIndex;
  final String? songUri;
  final String? spotifyUrl;
  final String? youtubeUrl;

  Map<String, dynamic> toJson() => {
        'title': title,
        'artistName': artistName,
        'bpm': bpm,
        'matchType': matchType.name,
        'segmentLabel': segmentLabel,
        'segmentIndex': segmentIndex,
        'songUri': songUri,
        'spotifyUrl': spotifyUrl,
        'youtubeUrl': youtubeUrl,
      };
}

/// A complete generated playlist.
class Playlist {
  const Playlist({
    required this.songs,
    required this.totalDurationSeconds,
    required this.createdAt,
    this.runPlanName,
  });

  factory Playlist.fromJson(Map<String, dynamic> json) {
    return Playlist(
      songs: (json['songs'] as List<dynamic>)
          .map((s) => PlaylistSong.fromJson(s as Map<String, dynamic>))
          .toList(),
      totalDurationSeconds: (json['totalDurationSeconds'] as num).toInt(),
      createdAt: DateTime.parse(json['createdAt'] as String),
      runPlanName: json['runPlanName'] as String?,
    );
  }

  final List<PlaylistSong> songs;
  final String? runPlanName;
  final int totalDurationSeconds;
  final DateTime createdAt;

  Map<String, dynamic> toJson() => {
        'songs': songs.map((s) => s.toJson()).toList(),
        'totalDurationSeconds': totalDurationSeconds,
        'createdAt': createdAt.toIso8601String(),
        'runPlanName': runPlanName,
      };

  /// Formats the playlist as copyable text for clipboard (PLAY-14).
  ///
  /// Groups songs by segment with headers. Each song line includes
  /// title, artist, and BPM.
  ///
  /// ```
  /// Running Playlist - My 5K
  /// Generated: 2026-02-05 14:30
  ///
  /// --- Warm-up ---
  /// Lose Yourself - Eminem (170 BPM)
  /// Eye of the Tiger - Survivor (168 BPM)
  /// ```
  String toClipboardText() {
    final buffer = StringBuffer();
    buffer.writeln('Running Playlist - ${runPlanName ?? "My Run"}');
    buffer.writeln(
      'Generated: ${createdAt.toLocal().toString().substring(0, 16)}',
    );
    buffer.writeln();

    String? currentSegment;
    for (final song in songs) {
      if (song.segmentLabel != currentSegment) {
        currentSegment = song.segmentLabel;
        buffer.writeln('--- $currentSegment ---');
      }
      buffer.writeln('${song.title} - ${song.artistName} (${song.bpm} BPM)');
    }
    return buffer.toString();
  }
}
```

IMPORTANT DESIGN DECISIONS:
- PlaylistSong stores `matchType` in `toJson()` (unlike BpmSong which excludes it). In playlist context, matchType is a display attribute for the user, not a cache key concern.
- `toClipboardText()` is a pure Dart method on Playlist -- no Flutter import needed.
- `createdAt` serializes as ISO 8601 string for JSON persistence.
- `segmentLabel` is required (not nullable) -- the generator fills in a default like "Segment 1" when the RunSegment has no label.
  </action>
  <verify>
Run `dart analyze lib/features/playlist/domain/` -- no errors or warnings. Verify both files are pure Dart (no `import 'package:flutter` anywhere).
  </verify>
  <done>
PlaylistSong with all fields (title, artistName, bpm, matchType, segmentLabel, segmentIndex, songUri, spotifyUrl, youtubeUrl) and toJson/fromJson. Playlist with songs, runPlanName, totalDurationSeconds, createdAt, toJson/fromJson, and toClipboardText. SongLinkBuilder with spotifySearchUrl and youtubeMusicSearchUrl using proper URI encoding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PlaylistGenerator algorithm</name>
  <files>
    lib/features/playlist/domain/playlist_generator.dart
  </files>
  <action>
**2a. Create `lib/features/playlist/domain/playlist_generator.dart`:**

```dart
/// Pure Dart playlist generation algorithm. No Flutter dependencies.
///
/// Takes a [RunPlan], [TasteProfile], and pre-fetched song pool, and returns
/// a [Playlist] with songs assigned to each run segment. All async work
/// (API calls, cache reads) must be completed before calling [generate].
library;

import 'dart:math';

import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_matcher.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist.dart';
import 'package:running_playlist_ai/features/playlist/domain/song_link_builder.dart';
import 'package:running_playlist_ai/features/run_plan/domain/run_plan.dart';
import 'package:running_playlist_ai/features/taste_profile/domain/taste_profile.dart';

/// Generates BPM-matched playlists from run plans and taste profiles.
///
/// The generator is a pure synchronous function. It:
/// 1. Iterates each [RunSegment] in the plan
/// 2. Finds candidate songs matching the segment's target BPM
/// 3. Scores candidates by taste profile match (artist name matching)
/// 4. Fills each segment's duration using a greedy algorithm
/// 5. Avoids repeating songs across segments
///
/// Song duration is estimated at 210 seconds (3.5 min) since the GetSongBPM
/// API does not return song duration.
class PlaylistGenerator {
  /// Estimated song duration in seconds (3.5 minutes).
  ///
  /// The GetSongBPM API does not return song duration. This fixed estimate
  /// is used to calculate how many songs are needed per segment.
  static const estimatedSongDurationSeconds = 210;

  /// Score bonus for songs by artists in the taste profile.
  static const _artistMatchScore = 10;

  /// Score bonus for exact BPM match (vs half/double-time).
  static const _exactMatchScore = 3;

  /// Score bonus for half-time or double-time match.
  static const _tempoVariantScore = 1;

  /// Generates a playlist from a run plan, taste profile, and available songs.
  ///
  /// [runPlan] defines the segments with target BPMs and durations.
  /// [tasteProfile] provides artist preferences for scoring (can be null
  /// if the user has not set up a taste profile).
  /// [songsByBpm] is a map of queried BPM -> list of BpmSong, pre-fetched
  /// from the API/cache. Keys are the raw queried BPMs (not target BPMs).
  /// [random] optional Random instance for deterministic testing.
  ///
  /// Returns a [Playlist] with songs assigned to all segments. Segments
  /// with no available songs will have zero songs in the output.
  static Playlist generate({
    required RunPlan runPlan,
    TasteProfile? tasteProfile,
    required Map<int, List<BpmSong>> songsByBpm,
    Random? random,
  }) {
    final rng = random ?? Random();
    final usedSongIds = <String>{};
    final allPlaylistSongs = <PlaylistSong>[];

    for (var i = 0; i < runPlan.segments.length; i++) {
      final segment = runPlan.segments[i];
      final segmentLabel = segment.label ?? 'Segment ${i + 1}';

      // Collect candidate songs for this segment's target BPM
      final targetBpm = segment.targetBpm.round();
      final candidates = _collectCandidates(
        targetBpm: targetBpm,
        songsByBpm: songsByBpm,
      );

      // Filter out already-used songs
      final available =
          candidates.where((s) => !usedSongIds.contains(s.songId)).toList();

      // Score and rank by taste profile match
      final scored = _scoreAndRank(
        candidates: available,
        tasteProfile: tasteProfile,
        rng: rng,
      );

      // Calculate how many songs to select for this segment
      final songsNeeded =
          (segment.durationSeconds / estimatedSongDurationSeconds).ceil();
      final selected = scored.take(songsNeeded.clamp(1, scored.length));

      // Build PlaylistSong objects and track used song IDs
      for (final entry in selected) {
        usedSongIds.add(entry.song.songId);
        allPlaylistSongs.add(
          PlaylistSong(
            title: entry.song.title,
            artistName: entry.song.artistName,
            bpm: entry.song.tempo,
            matchType: entry.song.matchType,
            segmentLabel: segmentLabel,
            segmentIndex: i,
            songUri: entry.song.songUri,
            spotifyUrl: SongLinkBuilder.spotifySearchUrl(
              entry.song.title,
              entry.song.artistName,
            ),
            youtubeUrl: SongLinkBuilder.youtubeMusicSearchUrl(
              entry.song.title,
              entry.song.artistName,
            ),
          ),
        );
      }
    }

    return Playlist(
      songs: allPlaylistSongs,
      runPlanName: runPlan.name,
      totalDurationSeconds: runPlan.totalDurationSeconds,
      createdAt: DateTime.now(),
    );
  }

  /// Collects all candidate songs for a target BPM from the pre-fetched pool.
  ///
  /// Uses [BpmMatcher.bpmQueries] to determine which BPM keys to look up
  /// in the songsByBpm map (exact + half-time + double-time).
  static List<BpmSong> _collectCandidates({
    required int targetBpm,
    required Map<int, List<BpmSong>> songsByBpm,
  }) {
    final queries = BpmMatcher.bpmQueries(targetBpm);
    final candidates = <BpmSong>[];

    for (final entry in queries.entries) {
      final bpm = entry.key;
      final matchType = entry.value;
      final songs = songsByBpm[bpm];
      if (songs != null) {
        // Assign the correct matchType based on relationship to target
        candidates.addAll(
          songs.map((s) => s.withMatchType(matchType)),
        );
      }
    }

    return candidates;
  }

  /// Scores and ranks candidate songs by taste profile match.
  ///
  /// Scoring:
  /// - +10 if song's artist matches any artist in the taste profile (case-insensitive)
  /// - +3 for exact BPM match
  /// - +1 for half-time or double-time match
  ///
  /// Songs are sorted by score descending. Within the same score tier,
  /// songs are shuffled for variety across regenerations.
  ///
  /// This is a RANKING signal, not a hard filter. If no songs match taste
  /// preferences, all BPM-matched songs are still returned (just unranked).
  static List<_ScoredSong> _scoreAndRank({
    required List<BpmSong> candidates,
    TasteProfile? tasteProfile,
    required Random rng,
  }) {
    final artistsLower = tasteProfile?.artists
            .map((a) => a.toLowerCase())
            .toList() ??
        const [];

    final scored = candidates.map((song) {
      var score = 0;

      // Artist match (case-insensitive)
      if (artistsLower.isNotEmpty) {
        final songArtistLower = song.artistName.toLowerCase();
        if (artistsLower.any((a) => songArtistLower.contains(a) || a.contains(songArtistLower))) {
          score += _artistMatchScore;
        }
      }

      // Match type bonus
      if (song.matchType == BpmMatchType.exact) {
        score += _exactMatchScore;
      } else {
        score += _tempoVariantScore;
      }

      return _ScoredSong(song, score);
    }).toList();

    // Shuffle first for randomness within same-score tiers
    scored.shuffle(rng);
    // Then stable-sort by score descending
    scored.sort((a, b) => b.score.compareTo(a.score));

    return scored;
  }
}

/// Internal scored song wrapper for ranking.
class _ScoredSong {
  const _ScoredSong(this.song, this.score);

  final BpmSong song;
  final int score;
}
```

IMPORTANT DESIGN DECISIONS:
- **Pure synchronous function**: All async work (API/cache) done before calling generate(). This makes testing trivial.
- **210-second song estimate**: GetSongBPM API does not return song duration. 3.5 min is a reasonable average.
- **Artist matching is bidirectional**: `songArtistLower.contains(a) || a.contains(songArtistLower)` handles "Eminem" matching "Eminem feat. Rihanna" and vice versa.
- **Shuffle-then-sort**: Shuffling before stable sort ensures same-score songs appear in random order, giving variety on regeneration.
- **No hard genre filter**: Genre data is not available from the /tempo/ API. Artist matching is the only taste signal.
- **Dedup via usedSongIds**: Songs used in earlier segments are excluded from later ones.
- **songsNeeded.clamp(1, scored.length)**: Always try to select at least 1 song, but never more than available.
- **Random injection**: Optional `Random` parameter for deterministic test assertions.
- **_collectCandidates uses BpmMatcher**: The generator calls BpmMatcher.bpmQueries to determine which BPM keys map to the target, ensuring consistent matching logic with the lookup pipeline.
  </action>
  <verify>
Run `dart analyze lib/features/playlist/domain/` -- no errors or warnings. Verify the file is pure Dart (no `import 'package:flutter` anywhere).
  </verify>
  <done>
PlaylistGenerator.generate takes RunPlan + TasteProfile + songsByBpm map + optional Random. Returns Playlist with songs assigned to all segments. Uses BpmMatcher for candidate collection, artist-name scoring for taste ranking, greedy duration-filling, and cross-segment dedup. All pure Dart, no Flutter imports.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for all domain files</name>
  <files>
    test/features/playlist/domain/playlist_test.dart
    test/features/playlist/domain/song_link_builder_test.dart
    test/features/playlist/domain/playlist_generator_test.dart
  </files>
  <action>
**3a. Create `test/features/playlist/domain/song_link_builder_test.dart`:**

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/playlist/domain/song_link_builder.dart';

void main() {
  group('SongLinkBuilder.spotifySearchUrl', () {
    test('builds correct Spotify search URL', () {
      final url = SongLinkBuilder.spotifySearchUrl('Lose Yourself', 'Eminem');
      expect(url, startsWith('https://open.spotify.com/search/'));
      expect(url, contains('Lose'));
      expect(url, contains('Eminem'));
    });

    test('encodes special characters', () {
      final url = SongLinkBuilder.spotifySearchUrl('Don\'t Stop', 'Fleetwood Mac');
      expect(url, startsWith('https://open.spotify.com/search/'));
      // Should be URI encoded (no raw spaces)
      expect(url.contains(' '), isFalse);
    });

    test('handles ampersands and symbols', () {
      final url = SongLinkBuilder.spotifySearchUrl('Rock & Roll', 'AC/DC');
      expect(url, startsWith('https://open.spotify.com/search/'));
      expect(url.contains(' '), isFalse);
    });
  });

  group('SongLinkBuilder.youtubeMusicSearchUrl', () {
    test('builds correct YouTube Music search URL', () {
      final url =
          SongLinkBuilder.youtubeMusicSearchUrl('Lose Yourself', 'Eminem');
      expect(url, startsWith('https://music.youtube.com/search'));
      expect(url, contains('q='));
      expect(url, contains('Lose'));
      expect(url, contains('Eminem'));
    });

    test('encodes special characters', () {
      final url =
          SongLinkBuilder.youtubeMusicSearchUrl('Don\'t Stop', 'Fleetwood Mac');
      expect(url, startsWith('https://music.youtube.com/search'));
      // Query parameter value should not have raw spaces
      final queryPart = Uri.parse(url).queryParameters['q']!;
      expect(queryPart, contains('Don\'t Stop'));
      expect(queryPart, contains('Fleetwood Mac'));
    });
  });
}
```

**3b. Create `test/features/playlist/domain/playlist_test.dart`:**

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist.dart';

void main() {
  // -- PlaylistSong -----------------------------------------------------------

  group('PlaylistSong serialization', () {
    test('toJson -> fromJson round-trip preserves all fields', () {
      const original = PlaylistSong(
        title: 'Test Song',
        artistName: 'Test Artist',
        bpm: 170,
        matchType: BpmMatchType.exact,
        segmentLabel: 'Warm-up',
        segmentIndex: 0,
        songUri: 'https://getsongbpm.com/song/test/abc',
        spotifyUrl: 'https://open.spotify.com/search/Test%20Song%20Test%20Artist',
        youtubeUrl: 'https://music.youtube.com/search?q=Test+Song+Test+Artist',
      );

      final json = original.toJson();
      final restored = PlaylistSong.fromJson(json);

      expect(restored.title, equals(original.title));
      expect(restored.artistName, equals(original.artistName));
      expect(restored.bpm, equals(original.bpm));
      expect(restored.matchType, equals(original.matchType));
      expect(restored.segmentLabel, equals(original.segmentLabel));
      expect(restored.segmentIndex, equals(original.segmentIndex));
      expect(restored.songUri, equals(original.songUri));
      expect(restored.spotifyUrl, equals(original.spotifyUrl));
      expect(restored.youtubeUrl, equals(original.youtubeUrl));
    });

    test('toJson -> fromJson with null optional fields', () {
      const original = PlaylistSong(
        title: 'Song',
        artistName: 'Artist',
        bpm: 120,
        matchType: BpmMatchType.halfTime,
        segmentLabel: 'Running',
        segmentIndex: 1,
      );

      final json = original.toJson();
      final restored = PlaylistSong.fromJson(json);

      expect(restored.songUri, isNull);
      expect(restored.spotifyUrl, isNull);
      expect(restored.youtubeUrl, isNull);
    });

    test('toJson includes matchType', () {
      const song = PlaylistSong(
        title: 'Song',
        artistName: 'Artist',
        bpm: 85,
        matchType: BpmMatchType.halfTime,
        segmentLabel: 'Segment 1',
        segmentIndex: 0,
      );
      final json = song.toJson();
      expect(json['matchType'], equals('halfTime'));
    });
  });

  // -- Playlist ---------------------------------------------------------------

  group('Playlist serialization', () {
    test('toJson -> fromJson round-trip preserves all fields', () {
      final original = Playlist(
        songs: const [
          PlaylistSong(
            title: 'Song A',
            artistName: 'Artist A',
            bpm: 170,
            matchType: BpmMatchType.exact,
            segmentLabel: 'Running',
            segmentIndex: 0,
          ),
          PlaylistSong(
            title: 'Song B',
            artistName: 'Artist B',
            bpm: 85,
            matchType: BpmMatchType.halfTime,
            segmentLabel: 'Cool-down',
            segmentIndex: 1,
          ),
        ],
        runPlanName: 'My 5K',
        totalDurationSeconds: 1800,
        createdAt: DateTime.utc(2026, 2, 5, 14, 30),
      );

      final json = original.toJson();
      final restored = Playlist.fromJson(json);

      expect(restored.songs.length, equals(2));
      expect(restored.songs[0].title, equals('Song A'));
      expect(restored.songs[1].title, equals('Song B'));
      expect(restored.runPlanName, equals('My 5K'));
      expect(restored.totalDurationSeconds, equals(1800));
      expect(restored.createdAt, equals(DateTime.utc(2026, 2, 5, 14, 30)));
    });

    test('toJson -> fromJson with null runPlanName', () {
      final original = Playlist(
        songs: const [],
        totalDurationSeconds: 600,
        createdAt: DateTime.utc(2026, 1, 1),
      );

      final json = original.toJson();
      final restored = Playlist.fromJson(json);
      expect(restored.runPlanName, isNull);
    });
  });

  // -- Playlist.toClipboardText -----------------------------------------------

  group('Playlist.toClipboardText', () {
    test('formats playlist with segment headers and song lines', () {
      final playlist = Playlist(
        songs: const [
          PlaylistSong(
            title: 'Song A',
            artistName: 'Artist A',
            bpm: 140,
            matchType: BpmMatchType.exact,
            segmentLabel: 'Warm-up',
            segmentIndex: 0,
          ),
          PlaylistSong(
            title: 'Song B',
            artistName: 'Artist B',
            bpm: 170,
            matchType: BpmMatchType.exact,
            segmentLabel: 'Running',
            segmentIndex: 1,
          ),
          PlaylistSong(
            title: 'Song C',
            artistName: 'Artist C',
            bpm: 170,
            matchType: BpmMatchType.halfTime,
            segmentLabel: 'Running',
            segmentIndex: 1,
          ),
        ],
        runPlanName: 'My 5K',
        totalDurationSeconds: 1800,
        createdAt: DateTime.utc(2026, 2, 5, 14, 30),
      );

      final text = playlist.toClipboardText();

      expect(text, contains('Running Playlist - My 5K'));
      expect(text, contains('--- Warm-up ---'));
      expect(text, contains('Song A - Artist A (140 BPM)'));
      expect(text, contains('--- Running ---'));
      expect(text, contains('Song B - Artist B (170 BPM)'));
      expect(text, contains('Song C - Artist C (170 BPM)'));
    });

    test('uses "My Run" when runPlanName is null', () {
      final playlist = Playlist(
        songs: const [],
        totalDurationSeconds: 600,
        createdAt: DateTime.utc(2026, 1, 1),
      );

      final text = playlist.toClipboardText();
      expect(text, contains('Running Playlist - My Run'));
    });

    test('does not repeat segment header for consecutive songs in same segment', () {
      final playlist = Playlist(
        songs: const [
          PlaylistSong(
            title: 'Song 1',
            artistName: 'A',
            bpm: 170,
            matchType: BpmMatchType.exact,
            segmentLabel: 'Running',
            segmentIndex: 0,
          ),
          PlaylistSong(
            title: 'Song 2',
            artistName: 'B',
            bpm: 170,
            matchType: BpmMatchType.exact,
            segmentLabel: 'Running',
            segmentIndex: 0,
          ),
        ],
        totalDurationSeconds: 600,
        createdAt: DateTime.utc(2026, 1, 1),
      );

      final text = playlist.toClipboardText();
      // 'Running' header should appear only once
      final matches = RegExp('--- Running ---').allMatches(text);
      expect(matches.length, equals(1));
    });
  });
}
```

**3c. Create `test/features/playlist/domain/playlist_generator_test.dart`:**

```dart
import 'dart:math';

import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist_generator.dart';
import 'package:running_playlist_ai/features/run_plan/domain/run_plan.dart';
import 'package:running_playlist_ai/features/taste_profile/domain/taste_profile.dart';

/// Helper to create a simple BpmSong.
BpmSong _song({
  String id = 's1',
  String title = 'Song',
  String artist = 'Artist',
  int tempo = 170,
  BpmMatchType matchType = BpmMatchType.exact,
}) =>
    BpmSong(
      songId: id,
      title: title,
      artistName: artist,
      tempo: tempo,
      matchType: matchType,
    );

void main() {
  // -- Basic generation -------------------------------------------------------

  group('PlaylistGenerator.generate', () {
    test('generates songs for a single-segment steady run', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 1800, targetBpm: 170, label: 'Running'),
        ],
      );

      final songsByBpm = {
        170: [
          _song(id: 's1', title: 'Song 1'),
          _song(id: 's2', title: 'Song 2'),
          _song(id: 's3', title: 'Song 3'),
          _song(id: 's4', title: 'Song 4'),
          _song(id: 's5', title: 'Song 5'),
          _song(id: 's6', title: 'Song 6'),
          _song(id: 's7', title: 'Song 7'),
          _song(id: 's8', title: 'Song 8'),
          _song(id: 's9', title: 'Song 9'),
          _song(id: 's10', title: 'Song 10'),
        ],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      // 1800s / 210s = 8.57 -> ceil = 9 songs needed
      expect(playlist.songs.length, equals(9));
      expect(playlist.runPlanName, isNull);
      expect(playlist.totalDurationSeconds, equals(1800));
      expect(playlist.songs.every((s) => s.segmentLabel == 'Running'), isTrue);
      expect(playlist.songs.every((s) => s.segmentIndex == 0), isTrue);
    });

    test('generates songs across multiple segments', () {
      final plan = RunPlan(
        type: RunType.warmUpCoolDown,
        distanceKm: 5,
        paceMinPerKm: 6,
        name: 'My 5K',
        segments: const [
          RunSegment(
            durationSeconds: 300,
            targetBpm: 140,
            label: 'Warm-up',
          ),
          RunSegment(
            durationSeconds: 1200,
            targetBpm: 170,
            label: 'Running',
          ),
          RunSegment(
            durationSeconds: 300,
            targetBpm: 140,
            label: 'Cool-down',
          ),
        ],
      );

      final songsByBpm = {
        140: List.generate(
          10,
          (i) => _song(id: 'w$i', title: 'Warm $i', tempo: 140),
        ),
        170: List.generate(
          10,
          (i) => _song(id: 'r$i', title: 'Run $i', tempo: 170),
        ),
        70: List.generate(
          5,
          (i) => _song(id: 'h$i', title: 'Half $i', tempo: 70),
        ),
        85: List.generate(
          5,
          (i) => _song(id: 'hr$i', title: 'HalfRun $i', tempo: 85),
        ),
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      expect(playlist.runPlanName, equals('My 5K'));

      // Verify songs are assigned to correct segments
      final warmUp = playlist.songs.where((s) => s.segmentIndex == 0);
      final running = playlist.songs.where((s) => s.segmentIndex == 1);
      final coolDown = playlist.songs.where((s) => s.segmentIndex == 2);

      expect(warmUp, isNotEmpty);
      expect(running, isNotEmpty);
      expect(coolDown, isNotEmpty);

      expect(warmUp.every((s) => s.segmentLabel == 'Warm-up'), isTrue);
      expect(running.every((s) => s.segmentLabel == 'Running'), isTrue);
      expect(coolDown.every((s) => s.segmentLabel == 'Cool-down'), isTrue);
    });

    test('defaults segment label to "Segment N" when label is null', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 420, targetBpm: 170),
        ],
      );

      final songsByBpm = {
        170: [_song(id: 's1'), _song(id: 's2'), _song(id: 's3')],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      expect(playlist.songs.first.segmentLabel, equals('Segment 1'));
    });

    test('preserves run plan name in playlist', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 10,
        paceMinPerKm: 5,
        name: 'Morning 10K',
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170),
        ],
      );

      final songsByBpm = {
        170: [_song()],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      expect(playlist.runPlanName, equals('Morning 10K'));
    });
  });

  // -- Dedup ------------------------------------------------------------------

  group('PlaylistGenerator dedup', () {
    test('does not repeat songs across segments', () {
      final plan = RunPlan(
        type: RunType.warmUpCoolDown,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(
            durationSeconds: 210,
            targetBpm: 140,
            label: 'Warm-up',
          ),
          RunSegment(
            durationSeconds: 210,
            targetBpm: 140,
            label: 'Cool-down',
          ),
        ],
      );

      // Both segments query BPM 140 -- same pool
      final songsByBpm = {
        140: [
          _song(id: 'a', title: 'Song A', tempo: 140),
          _song(id: 'b', title: 'Song B', tempo: 140),
          _song(id: 'c', title: 'Song C', tempo: 140),
        ],
        70: [
          _song(id: 'd', title: 'Song D', tempo: 70),
        ],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      // Each segment needs 1 song (210/210=1). With dedup, they must be different.
      final songIds = playlist.songs.map((s) => s.title).toList();
      expect(songIds.toSet().length, equals(songIds.length),
          reason: 'No duplicate songs across segments');
    });
  });

  // -- Taste filtering --------------------------------------------------------

  group('PlaylistGenerator taste filtering', () {
    test('ranks artist-match songs higher', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Run'),
        ],
      );

      final tasteProfile = TasteProfile(
        genres: const [RunningGenre.rock],
        artists: const ['Eminem'],
      );

      final songsByBpm = {
        170: [
          _song(id: 'other1', title: 'Other 1', artist: 'Unknown Artist'),
          _song(id: 'em1', title: 'Lose Yourself', artist: 'Eminem'),
          _song(id: 'other2', title: 'Other 2', artist: 'Another Artist'),
        ],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        tasteProfile: tasteProfile,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      // Only 1 song needed (210/210). The Eminem song should be ranked first.
      expect(playlist.songs.length, equals(1));
      expect(playlist.songs.first.artistName, equals('Eminem'));
    });

    test('falls back to unfiltered BPM matches when no taste match', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Run'),
        ],
      );

      final tasteProfile = TasteProfile(
        genres: const [RunningGenre.rock],
        artists: const ['Nonexistent Artist'],
      );

      final songsByBpm = {
        170: [
          _song(id: 's1', title: 'Song 1', artist: 'Artist A'),
          _song(id: 's2', title: 'Song 2', artist: 'Artist B'),
        ],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        tasteProfile: tasteProfile,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      // Should still get a song even though no artist matches
      expect(playlist.songs.length, equals(1));
    });

    test('works with null taste profile', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Run'),
        ],
      );

      final songsByBpm = {
        170: [_song(id: 's1', title: 'Song 1')],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      expect(playlist.songs.length, equals(1));
    });

    test('artist matching is case-insensitive', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Run'),
        ],
      );

      final tasteProfile = TasteProfile(
        artists: const ['eminem'],  // lowercase
      );

      final songsByBpm = {
        170: [
          _song(id: 'other', title: 'Other', artist: 'Unknown'),
          _song(id: 'em', title: 'Lose Yourself', artist: 'EMINEM'),  // uppercase
        ],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        tasteProfile: tasteProfile,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      expect(playlist.songs.first.artistName, equals('EMINEM'));
    });
  });

  // -- External links ---------------------------------------------------------

  group('PlaylistGenerator external links', () {
    test('each song has Spotify and YouTube URLs', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Run'),
        ],
      );

      final songsByBpm = {
        170: [_song(id: 's1', title: 'My Song', artist: 'My Artist')],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      final song = playlist.songs.first;
      expect(song.spotifyUrl, contains('open.spotify.com/search'));
      expect(song.spotifyUrl, contains('My'));
      expect(song.youtubeUrl, contains('music.youtube.com/search'));
      expect(song.youtubeUrl, contains('My'));
    });
  });

  // -- Edge cases -------------------------------------------------------------

  group('PlaylistGenerator edge cases', () {
    test('returns empty playlist when no songs available for any segment', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 1800, targetBpm: 170, label: 'Run'),
        ],
      );

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: const {},
        random: Random(42),
      );

      expect(playlist.songs, isEmpty);
    });

    test('handles segment with very short duration (< 1 song)', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 1,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 60, targetBpm: 170, label: 'Sprint'),
        ],
      );

      final songsByBpm = {
        170: [_song(id: 's1')],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      // ceil(60/210) = 1, clamp(1, 1) = 1
      expect(playlist.songs.length, equals(1));
    });

    test('uses half-time songs when exact BPM pool is empty', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Run'),
        ],
      );

      // No songs at 170, but songs at 85 (half-time of 170)
      final songsByBpm = {
        85: [_song(id: 'h1', title: 'Half Song', tempo: 85)],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      expect(playlist.songs.length, equals(1));
      expect(playlist.songs.first.matchType, equals(BpmMatchType.halfTime));
    });

    test('prefers exact match over half/double-time', () {
      final plan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Run'),
        ],
      );

      final songsByBpm = {
        170: [_song(id: 'exact', title: 'Exact Song', tempo: 170)],
        85: [_song(id: 'half', title: 'Half Song', tempo: 85)],
      };

      final playlist = PlaylistGenerator.generate(
        runPlan: plan,
        songsByBpm: songsByBpm,
        random: Random(42),
      );

      // Only 1 song needed. Exact match scores +3, half-time scores +1.
      expect(playlist.songs.first.title, equals('Exact Song'));
    });

    test('estimatedSongDurationSeconds is 210', () {
      expect(PlaylistGenerator.estimatedSongDurationSeconds, equals(210));
    });
  });
}
```
  </action>
  <verify>
Run `flutter test test/features/playlist/domain/` -- all tests pass. Run `dart analyze lib/features/playlist/domain/ test/features/playlist/domain/` -- no errors or warnings.
  </verify>
  <done>
All unit tests pass: SongLinkBuilder (5 tests), PlaylistSong serialization (3 tests), Playlist serialization (2 tests), Playlist.toClipboardText (3 tests), PlaylistGenerator basic (4 tests), PlaylistGenerator dedup (1 test), PlaylistGenerator taste filtering (4 tests), PlaylistGenerator external links (1 test), PlaylistGenerator edge cases (5 tests). Total: ~28 tests.
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/playlist/domain/` reports no issues
2. `flutter test test/features/playlist/domain/` -- all tests pass
3. `grep -r "import 'package:flutter" lib/features/playlist/domain/` returns nothing (domain is pure Dart)
4. PlaylistGenerator.generate produces correct song count for a 30-min run (ceil(1800/210) = 9 songs)
5. Songs are deduped across segments (no songId appears twice in output)
6. Artist-match songs rank higher than non-match songs
7. Empty song pool produces empty playlist (no crash)
8. Spotify URLs start with `https://open.spotify.com/search/`
9. YouTube URLs start with `https://music.youtube.com/search?q=`
</verification>

<success_criteria>
- PlaylistSong and Playlist models with complete toJson/fromJson round-trip
- Playlist.toClipboardText formats segments and songs correctly
- SongLinkBuilder produces valid Spotify and YouTube Music search URLs with proper encoding
- PlaylistGenerator fills segments using greedy duration algorithm (210s per song estimate)
- PlaylistGenerator uses BpmMatcher for candidate collection (exact + half + double-time)
- PlaylistGenerator scores songs by artist match (+10) and match type (exact +3, variant +1)
- PlaylistGenerator avoids repeating songs across segments
- PlaylistGenerator works with null taste profile (graceful fallback)
- All ~28 unit tests pass
- All files are pure Dart (no Flutter imports in domain/)
</success_criteria>

<output>
After completion, create `.planning/phases/14-playlist-generation/14-01-SUMMARY.md`
</output>
