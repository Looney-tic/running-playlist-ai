---
phase: 14-playlist-generation
plan: 02
type: execute
wave: 2
depends_on: ["14-01"]
files_modified:
  - pubspec.yaml
  - android/app/src/main/AndroidManifest.xml
  - lib/features/playlist/providers/playlist_providers.dart
  - test/features/playlist/providers/playlist_providers_test.dart
autonomous: true

must_haves:
  truths:
    - "PlaylistGenerationNotifier fetches songs for all unique segment BPMs before running the generator"
    - "PlaylistGenerationNotifier uses GetSongBpmClient + BpmCachePreferences directly (not through BpmLookupNotifier) for batch multi-BPM fetching"
    - "PlaylistGenerationNotifier uses cache-first strategy with BpmCachePreferences for each queried BPM"
    - "PlaylistGenerationState has idle, loading, loaded (with Playlist), and error states"
    - "When generation completes, PlaylistGenerationState.playlist contains the generated Playlist"
    - "When API fails for any segment BPM, an error state is produced with a user-friendly message"
    - "url_launcher is a direct dependency in pubspec.yaml"
    - "Android AndroidManifest.xml has <queries> entry for HTTPS intent"
  artifacts:
    - path: "lib/features/playlist/providers/playlist_providers.dart"
      provides: "PlaylistGenerationState, PlaylistGenerationNotifier, and playlistGenerationProvider"
      contains: "class PlaylistGenerationNotifier extends StateNotifier"
    - path: "test/features/playlist/providers/playlist_providers_test.dart"
      provides: "Unit tests for PlaylistGenerationNotifier"
      contains: "group('PlaylistGenerationNotifier'"
    - path: "pubspec.yaml"
      provides: "url_launcher as direct dependency"
      contains: "url_launcher"
    - path: "android/app/src/main/AndroidManifest.xml"
      provides: "HTTPS intent query for url_launcher on Android 11+"
      contains: "android.intent.action.VIEW"
  key_links:
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/bpm_lookup/data/getsongbpm_client.dart"
      via: "Direct API calls for batch multi-BPM fetching"
      pattern: "GetSongBpmClient"
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/bpm_lookup/data/bpm_cache_preferences.dart"
      via: "Cache-first lookup for each queried BPM"
      pattern: "BpmCachePreferences"
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/playlist/domain/playlist_generator.dart"
      via: "Calls PlaylistGenerator.generate after all songs are fetched"
      pattern: "PlaylistGenerator\\.generate"
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/run_plan/providers/run_plan_providers.dart"
      via: "Reads current RunPlan from runPlanNotifierProvider"
      pattern: "runPlanNotifierProvider"
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/taste_profile/providers/taste_profile_providers.dart"
      via: "Reads current TasteProfile from tasteProfileNotifierProvider"
      pattern: "tasteProfileNotifierProvider"
---

<objective>
Build the playlist generation state management layer: PlaylistGenerationNotifier that orchestrates batch BPM fetching (cache-first via GetSongBpmClient + BpmCachePreferences), runs the PlaylistGenerator algorithm, and manages loading/loaded/error states. Also add url_launcher dependency and Android manifest configuration for external link support.

Purpose: This plan connects the pure domain layer (from Plan 14-01) to the Riverpod state management system and prepares platform configuration for external links. After this plan, the UI (Plan 14-03) can trigger generation via a provider and display results.

Output: 1 production file (playlist_providers.dart), 1 test file, updated pubspec.yaml with url_launcher, updated AndroidManifest.xml with HTTPS queries. All Phase 14 requirements achievable from UI after this plan.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-playlist-generation/14-RESEARCH.md
@.planning/phases/14-playlist-generation/14-01-SUMMARY.md

@lib/features/playlist/domain/playlist.dart
@lib/features/playlist/domain/playlist_generator.dart
@lib/features/playlist/domain/song_link_builder.dart
@lib/features/bpm_lookup/data/getsongbpm_client.dart
@lib/features/bpm_lookup/data/bpm_cache_preferences.dart
@lib/features/bpm_lookup/domain/bpm_matcher.dart
@lib/features/bpm_lookup/domain/bpm_song.dart
@lib/features/bpm_lookup/providers/bpm_lookup_providers.dart
@lib/features/run_plan/providers/run_plan_providers.dart
@lib/features/taste_profile/providers/taste_profile_providers.dart
@pubspec.yaml
@android/app/src/main/AndroidManifest.xml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add url_launcher dependency and Android manifest queries</name>
  <files>
    pubspec.yaml
    android/app/src/main/AndroidManifest.xml
  </files>
  <action>
**1a. Add `url_launcher` package to pubspec.yaml:**

Run:
```bash
cd /Users/tijmen/running-playlist-ai && flutter pub add url_launcher
```

This promotes url_launcher from transitive to direct dependency in pubspec.yaml and runs `flutter pub get`. Expected version: ^6.3.2 or latest compatible.

**1b. Add HTTPS intent query to AndroidManifest.xml:**

Edit `android/app/src/main/AndroidManifest.xml` to add an HTTPS intent query inside the existing `<queries>` block. The `<queries>` block currently has only the text processing intent. Add the HTTPS browsing intent AFTER the existing `<intent>` entry:

Find the existing `<queries>` section:
```xml
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
```

Replace it with:
```xml
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
        <intent>
            <action android:name="android.intent.action.VIEW"/>
            <category android:name="android.intent.category.BROWSABLE"/>
            <data android:scheme="https"/>
        </intent>
    </queries>
```

This allows `canLaunchUrl()` to return true for HTTPS URLs on Android 11+ (API 30+). While we primarily use `launchUrl()` directly (which works without this), the queries entry is best practice for url_launcher.
  </action>
  <verify>
Run `flutter pub get` -- succeeds. Verify `url_launcher` appears in pubspec.yaml dependencies. Verify AndroidManifest.xml `<queries>` block contains both the PROCESS_TEXT and VIEW/BROWSABLE/https intents.
  </verify>
  <done>
pubspec.yaml has url_launcher as direct dependency. AndroidManifest.xml has HTTPS intent query for url_launcher compatibility on Android 11+.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PlaylistGenerationNotifier, state, providers, and unit tests</name>
  <files>
    lib/features/playlist/providers/playlist_providers.dart
    test/features/playlist/providers/playlist_providers_test.dart
  </files>
  <action>
**2a. Create `lib/features/playlist/providers/playlist_providers.dart`:**

```dart
import 'dart:async';
import 'dart:io';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/bpm_cache_preferences.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/getsongbpm_client.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_matcher.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:running_playlist_ai/features/bpm_lookup/providers/bpm_lookup_providers.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist_generator.dart';
import 'package:running_playlist_ai/features/run_plan/domain/run_plan.dart';
import 'package:running_playlist_ai/features/run_plan/providers/run_plan_providers.dart';
import 'package:running_playlist_ai/features/taste_profile/domain/taste_profile.dart';
import 'package:running_playlist_ai/features/taste_profile/providers/taste_profile_providers.dart';

/// State for playlist generation.
class PlaylistGenerationState {
  const PlaylistGenerationState._({
    this.playlist,
    this.isLoading = false,
    this.error,
  });

  /// Initial idle state.
  const PlaylistGenerationState.idle() : this._();

  /// Loading state while fetching songs and generating.
  const PlaylistGenerationState.loading() : this._(isLoading: true);

  /// Loaded state with a generated playlist.
  PlaylistGenerationState.loaded(Playlist playlist)
      : this._(playlist: playlist);

  /// Error state with a user-facing message.
  const PlaylistGenerationState.error(String message) : this._(error: message);

  final Playlist? playlist;
  final bool isLoading;
  final String? error;
}

/// Orchestrates playlist generation: batch BPM fetching + algorithm execution.
///
/// Uses [GetSongBpmClient] and [BpmCachePreferences] directly (not through
/// [BpmLookupNotifier]) for batch multi-BPM fetching. This gives full control
/// over fetching songs for all unique segment BPMs in a single operation.
///
/// Flow:
/// 1. Read current RunPlan and TasteProfile from their providers
/// 2. Collect unique target BPMs across all run plan segments
/// 3. For each unique BPM, compute query BPMs via BpmMatcher (exact + half + double)
/// 4. For each query BPM, check cache first, then fetch from API on miss
/// 5. Accumulate all songs into a Map<int, List<BpmSong>>
/// 6. Call PlaylistGenerator.generate with the accumulated songs
/// 7. Update state with the generated Playlist
class PlaylistGenerationNotifier extends StateNotifier<PlaylistGenerationState> {
  PlaylistGenerationNotifier({
    required this.client,
    required this.ref,
  }) : super(const PlaylistGenerationState.idle());

  final GetSongBpmClient client;
  final Ref ref;

  /// Delay between API calls for uncached BPMs to avoid rate limiting.
  static const _apiCallDelay = Duration(milliseconds: 300);

  /// Generates a playlist from the current run plan and taste profile.
  ///
  /// Reads RunPlan from [runPlanNotifierProvider] and TasteProfile from
  /// [tasteProfileNotifierProvider]. If no run plan is saved, produces an
  /// error state.
  Future<void> generatePlaylist() async {
    final runPlan = ref.read(runPlanNotifierProvider);
    if (runPlan == null) {
      state = const PlaylistGenerationState.error(
        'No run plan saved. Please create a run plan first.',
      );
      return;
    }

    final tasteProfile = ref.read(tasteProfileNotifierProvider);

    state = const PlaylistGenerationState.loading();

    try {
      final songsByBpm = await _fetchAllSongs(runPlan);

      final playlist = PlaylistGenerator.generate(
        runPlan: runPlan,
        tasteProfile: tasteProfile,
        songsByBpm: songsByBpm,
      );

      if (!mounted) return;
      state = PlaylistGenerationState.loaded(playlist);
    } on SocketException {
      if (!mounted) return;
      state = const PlaylistGenerationState.error(
        'No internet connection. Please check your network and try again.',
      );
    } on TimeoutException {
      if (!mounted) return;
      state = const PlaylistGenerationState.error(
        'Request timed out. Please try again.',
      );
    } on BpmApiException catch (e) {
      if (!mounted) return;
      state = PlaylistGenerationState.error(
        'Could not fetch songs: ${e.message}',
      );
    } catch (e) {
      if (!mounted) return;
      state = const PlaylistGenerationState.error(
        'An unexpected error occurred. Please try again.',
      );
    }
  }

  /// Fetches songs for all unique BPMs needed by the run plan.
  ///
  /// For each unique target BPM in the plan:
  /// 1. Compute query BPMs via BpmMatcher (exact + half + double)
  /// 2. For each query BPM, check cache → fetch from API on miss → save to cache
  /// 3. Accumulate results keyed by queried BPM
  ///
  /// Returns a map of queried BPM → songs, suitable for PlaylistGenerator.
  Future<Map<int, List<BpmSong>>> _fetchAllSongs(RunPlan plan) async {
    final songsByBpm = <int, List<BpmSong>>{};

    // Collect all unique query BPMs across all segments
    final allQueryBpms = <int>{};
    for (final segment in plan.segments) {
      final targetBpm = segment.targetBpm.round();
      final queries = BpmMatcher.bpmQueries(targetBpm);
      allQueryBpms.addAll(queries.keys);
    }

    // Fetch songs for each unique query BPM (cache-first)
    var isFirstApiCall = true;
    for (final bpm in allQueryBpms) {
      // Check cache first
      var songs = await BpmCachePreferences.load(bpm);

      if (songs == null) {
        // Rate limiting: small delay between API calls (skip for first call)
        if (!isFirstApiCall) {
          await Future<void>.delayed(_apiCallDelay);
        }
        isFirstApiCall = false;

        // Cache miss: fetch from API
        songs = await client.fetchSongsByBpm(bpm);
        // Save to cache for future use
        await BpmCachePreferences.save(bpm, songs);
      }

      songsByBpm[bpm] = songs;
    }

    return songsByBpm;
  }

  /// Resets the state to idle.
  void clear() {
    state = const PlaylistGenerationState.idle();
  }
}

/// Provides [PlaylistGenerationNotifier] and the current [PlaylistGenerationState].
///
/// Usage:
/// - `ref.watch(playlistGenerationProvider)` to read state reactively
/// - `ref.read(playlistGenerationProvider.notifier).generatePlaylist()` to trigger
/// - `ref.read(playlistGenerationProvider.notifier).clear()` to reset
final playlistGenerationProvider = StateNotifierProvider<
    PlaylistGenerationNotifier, PlaylistGenerationState>((ref) {
  final client = ref.watch(getSongBpmClientProvider);
  return PlaylistGenerationNotifier(client: client, ref: ref);
});
```

IMPORTANT DESIGN DECISIONS:
- **Uses GetSongBpmClient + BpmCachePreferences directly**: Not through BpmLookupNotifier. This is per RESEARCH.md recommendation for batch multi-BPM fetching.
- **Collects ALL unique query BPMs first**: Dedupes across segments (e.g., warm-up and cool-down at same BPM share the same query). This minimizes API calls.
- **300ms delay between API calls**: Per RESEARCH.md Open Question 3, to avoid potential rate limiting. Only applied between uncached calls, not cache hits.
- **Cache-first pattern mirrors BpmLookupNotifier**: Same logic (load from cache → fetch from API → save to cache) but accumulates results across BPMs instead of replacing state.
- **Reads RunPlan and TasteProfile from their providers**: The notifier uses `ref.read()` at generation time (not `ref.watch()`) since it's a one-shot operation.
- **mounted check after async operations**: Prevents state updates if the notifier was disposed during an async gap.

**2b. Create `test/features/playlist/providers/playlist_providers_test.dart`:**

```dart
import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:http/http.dart' as http;
import 'package:http/testing.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/bpm_cache_preferences.dart';
import 'package:running_playlist_ai/features/bpm_lookup/data/getsongbpm_client.dart';
import 'package:running_playlist_ai/features/bpm_lookup/providers/bpm_lookup_providers.dart';
import 'package:running_playlist_ai/features/playlist/providers/playlist_providers.dart';
import 'package:running_playlist_ai/features/run_plan/domain/run_plan.dart';
import 'package:running_playlist_ai/features/run_plan/providers/run_plan_providers.dart';
import 'package:running_playlist_ai/features/taste_profile/domain/taste_profile.dart';
import 'package:running_playlist_ai/features/taste_profile/providers/taste_profile_providers.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Helper API song JSON.
Map<String, dynamic> _apiSong({
  String id = 's1',
  String title = 'Song',
  String tempo = '170',
  String artist = 'Artist',
}) =>
    {
      'song_id': id,
      'song_title': title,
      'tempo': tempo,
      'artist': {'name': artist},
    };

/// Builds a valid API response body.
String _apiResponseBody(List<Map<String, dynamic>> songs) {
  return jsonEncode({'tempo': songs});
}

/// Creates a ProviderContainer with overrides for testing.
///
/// Overrides runPlanNotifierProvider and tasteProfileNotifierProvider
/// to provide test data without SharedPreferences loading.
ProviderContainer _createContainer({
  RunPlan? runPlan,
  TasteProfile? tasteProfile,
  required GetSongBpmClient client,
}) {
  return ProviderContainer(
    overrides: [
      getSongBpmClientProvider.overrideWithValue(client),
      runPlanNotifierProvider.overrideWith((ref) {
        final notifier = RunPlanNotifier();
        if (runPlan != null) {
          // Use a future to set the plan after construction
          Future.microtask(() => notifier.setPlan(runPlan));
        }
        return notifier;
      }),
      tasteProfileNotifierProvider.overrideWith((ref) {
        final notifier = TasteProfileNotifier();
        if (tasteProfile != null) {
          Future.microtask(() => notifier.setProfile(tasteProfile));
        }
        return notifier;
      }),
    ],
  );
}

void main() {
  setUp(() {
    SharedPreferences.setMockInitialValues({});
  });

  // -- PlaylistGenerationState ------------------------------------------------

  group('PlaylistGenerationState', () {
    test('idle state has no playlist, not loading, no error', () {
      const state = PlaylistGenerationState.idle();
      expect(state.playlist, isNull);
      expect(state.isLoading, isFalse);
      expect(state.error, isNull);
    });

    test('loading state has isLoading true', () {
      const state = PlaylistGenerationState.loading();
      expect(state.isLoading, isTrue);
      expect(state.playlist, isNull);
      expect(state.error, isNull);
    });

    test('error state has error message', () {
      const state = PlaylistGenerationState.error('Something went wrong');
      expect(state.error, equals('Something went wrong'));
      expect(state.isLoading, isFalse);
      expect(state.playlist, isNull);
    });
  });

  // -- PlaylistGenerationNotifier: no run plan --------------------------------

  group('PlaylistGenerationNotifier without run plan', () {
    test('produces error when no run plan is saved', () async {
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient(
          (r) async => http.Response(_apiResponseBody([]), 200),
        ),
      );

      final container = _createContainer(client: client);
      // Wait for providers to initialize
      await Future<void>.delayed(Duration.zero);

      final notifier =
          container.read(playlistGenerationProvider.notifier);
      await notifier.generatePlaylist();

      final state = container.read(playlistGenerationProvider);
      expect(state.error, contains('No run plan'));
      expect(state.playlist, isNull);
    });
  });

  // -- PlaylistGenerationNotifier: successful generation ----------------------

  group('PlaylistGenerationNotifier successful generation', () {
    test('generates playlist from run plan and API songs', () async {
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient((request) async {
          final bpm = request.url.queryParameters['bpm'];
          return http.Response(
            _apiResponseBody([
              _apiSong(id: 'song-$bpm', title: 'Song at $bpm', tempo: bpm!),
            ]),
            200,
          );
        }),
      );

      final runPlan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        name: 'Test Run',
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Running'),
        ],
      );

      final container = _createContainer(
        client: client,
        runPlan: runPlan,
      );

      // Wait for providers to initialize and set the run plan
      await Future<void>.delayed(const Duration(milliseconds: 50));

      final notifier =
          container.read(playlistGenerationProvider.notifier);
      await notifier.generatePlaylist();

      final state = container.read(playlistGenerationProvider);
      expect(state.error, isNull);
      expect(state.isLoading, isFalse);
      expect(state.playlist, isNotNull);
      expect(state.playlist!.songs, isNotEmpty);
      expect(state.playlist!.runPlanName, equals('Test Run'));
    });

    test('uses cache when songs are pre-cached', () async {
      // Pre-populate cache for BPM 170
      await BpmCachePreferences.save(170, [
        const BpmSong(
          songId: 'cached',
          title: 'Cached Song',
          artistName: 'Cached Artist',
          tempo: 170,
        ),
      ]);

      var apiCallCount = 0;
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient((request) async {
          apiCallCount++;
          final bpm = request.url.queryParameters['bpm'];
          return http.Response(
            _apiResponseBody([
              _apiSong(id: 'api-$bpm', tempo: bpm!),
            ]),
            200,
          );
        }),
      );

      final runPlan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Running'),
        ],
      );

      final container = _createContainer(
        client: client,
        runPlan: runPlan,
      );

      await Future<void>.delayed(const Duration(milliseconds: 50));

      final notifier =
          container.read(playlistGenerationProvider.notifier);
      await notifier.generatePlaylist();

      // BPM 170 was cached, so only half-time (85) should hit API
      // (170 is cached, 85 is not, 340 is beyond maxQueryBpm)
      expect(apiCallCount, equals(1));

      final state = container.read(playlistGenerationProvider);
      expect(state.playlist, isNotNull);
    });
  });

  // -- PlaylistGenerationNotifier: error handling -----------------------------

  group('PlaylistGenerationNotifier error handling', () {
    test('handles API error with user-friendly message', () async {
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient(
          (r) async => http.Response('Server Error', 500),
        ),
      );

      final runPlan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Running'),
        ],
      );

      final container = _createContainer(
        client: client,
        runPlan: runPlan,
      );

      await Future<void>.delayed(const Duration(milliseconds: 50));

      final notifier =
          container.read(playlistGenerationProvider.notifier);
      await notifier.generatePlaylist();

      final state = container.read(playlistGenerationProvider);
      expect(state.error, isNotNull);
      expect(state.error, contains('Could not fetch songs'));
      expect(state.playlist, isNull);
    });

    test('handles SocketException for no network', () async {
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient(
          (r) async => throw const SocketException('No network'),
        ),
      );

      final runPlan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Running'),
        ],
      );

      final container = _createContainer(
        client: client,
        runPlan: runPlan,
      );

      await Future<void>.delayed(const Duration(milliseconds: 50));

      final notifier =
          container.read(playlistGenerationProvider.notifier);
      await notifier.generatePlaylist();

      final state = container.read(playlistGenerationProvider);
      expect(state.error, contains('No internet connection'));
    });
  });

  // -- PlaylistGenerationNotifier: clear --------------------------------------

  group('PlaylistGenerationNotifier.clear', () {
    test('resets state to idle', () async {
      final client = GetSongBpmClient(
        apiKey: 'test-key',
        httpClient: MockClient((request) async {
          final bpm = request.url.queryParameters['bpm'];
          return http.Response(
            _apiResponseBody([_apiSong(id: 'song-$bpm', tempo: bpm!)]),
            200,
          );
        }),
      );

      final runPlan = RunPlan(
        type: RunType.steady,
        distanceKm: 5,
        paceMinPerKm: 6,
        segments: const [
          RunSegment(durationSeconds: 210, targetBpm: 170, label: 'Running'),
        ],
      );

      final container = _createContainer(
        client: client,
        runPlan: runPlan,
      );

      await Future<void>.delayed(const Duration(milliseconds: 50));

      final notifier =
          container.read(playlistGenerationProvider.notifier);
      await notifier.generatePlaylist();

      // State should have a playlist
      expect(container.read(playlistGenerationProvider).playlist, isNotNull);

      // Clear should reset to idle
      notifier.clear();
      final state = container.read(playlistGenerationProvider);
      expect(state.playlist, isNull);
      expect(state.isLoading, isFalse);
      expect(state.error, isNull);
    });
  });
}
```

IMPORTANT NOTES FOR EXECUTOR:
- The test uses `ProviderContainer` with overrides for isolated testing without a widget tree.
- `getSongBpmClientProvider.overrideWithValue(client)` injects the mock client.
- `runPlanNotifierProvider.overrideWith` creates a notifier that sets the plan via `Future.microtask` to avoid SharedPreferences dependency.
- `await Future<void>.delayed(const Duration(milliseconds: 50))` gives the notifier time to load the plan.
- If the `overrideWith` pattern for StateNotifierProvider causes issues, the executor should adjust by using `overrideWithValue` with a pre-configured notifier or by pre-populating SharedPreferences via `SharedPreferences.setMockInitialValues`.
  </action>
  <verify>
Run `flutter pub get` -- succeeds. Run `flutter test test/features/playlist/providers/` -- all tests pass. Run `dart analyze lib/features/playlist/providers/ test/features/playlist/providers/` -- no errors or warnings.
  </verify>
  <done>
PlaylistGenerationNotifier with batch multi-BPM fetching (cache-first via GetSongBpmClient + BpmCachePreferences), 300ms rate-limit delay between API calls, error handling for all exception types, and clear() method. playlistGenerationProvider wired to getSongBpmClientProvider. PlaylistGenerationState with idle/loading/loaded/error factory constructors. url_launcher in pubspec.yaml. AndroidManifest.xml with HTTPS queries. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `flutter pub get` succeeds with url_launcher as direct dependency
2. `dart analyze lib/features/playlist/providers/` -- no issues
3. `flutter test test/features/playlist/providers/` -- all tests pass
4. `grep url_launcher pubspec.yaml` shows it as a direct dependency
5. AndroidManifest.xml `<queries>` block has both PROCESS_TEXT and VIEW/BROWSABLE/https intents
6. PlaylistGenerationNotifier uses GetSongBpmClient directly (not BpmLookupNotifier)
7. Cache-first strategy verified: pre-cached BPMs skip API calls
</verification>

<success_criteria>
- PlaylistGenerationNotifier fetches songs for all unique query BPMs before generating
- Cache-first strategy: cached BPMs skip API calls, uncached BPMs fetch and save to cache
- 300ms delay between uncached API calls for rate limiting
- PlaylistGenerationState has idle, loading, loaded (with Playlist), and error states
- Error handling covers SocketException, TimeoutException, BpmApiException, and catch-all
- Provider reads RunPlan and TasteProfile from their respective providers
- url_launcher added as direct dependency
- Android manifest has HTTPS intent query
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-playlist-generation/14-02-SUMMARY.md`
</output>
