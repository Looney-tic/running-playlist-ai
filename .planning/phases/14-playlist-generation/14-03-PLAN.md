---
phase: 14-playlist-generation
plan: 03
type: execute
wave: 3
depends_on: ["14-02"]
files_modified:
  - lib/features/playlist/presentation/playlist_screen.dart
  - lib/app/router.dart
autonomous: true

must_haves:
  truths:
    - "User navigates to /playlist and sees a 'Generate Playlist' button when no playlist is generated"
    - "User taps Generate and sees a loading indicator while songs are being fetched"
    - "After generation, user sees a playlist grouped by run segment with each song showing title, artist, BPM, and segment"
    - "User can tap any song to open it in Spotify or YouTube via external URL"
    - "User can tap a copy button to copy the entire playlist as formatted text to clipboard"
    - "When generation fails, user sees a clear error message with a retry option"
    - "When no run plan exists, user sees a message directing them to create one"
    - "Router /playlist route points to PlaylistScreen (not _ComingSoonScreen)"
  artifacts:
    - path: "lib/features/playlist/presentation/playlist_screen.dart"
      provides: "Full playlist generation UI with loading, display, links, and clipboard"
      contains: "class PlaylistScreen"
    - path: "lib/app/router.dart"
      provides: "Updated /playlist route pointing to PlaylistScreen"
      contains: "PlaylistScreen"
  key_links:
    - from: "lib/features/playlist/presentation/playlist_screen.dart"
      to: "lib/features/playlist/providers/playlist_providers.dart"
      via: "ref.watch(playlistGenerationProvider) for reactive state"
      pattern: "playlistGenerationProvider"
    - from: "lib/features/playlist/presentation/playlist_screen.dart"
      to: "package:url_launcher"
      via: "launchUrl to open Spotify/YouTube search URLs"
      pattern: "launchUrl"
    - from: "lib/features/playlist/presentation/playlist_screen.dart"
      to: "package:flutter/services.dart"
      via: "Clipboard.setData for copy-to-clipboard"
      pattern: "Clipboard\\.setData"
    - from: "lib/app/router.dart"
      to: "lib/features/playlist/presentation/playlist_screen.dart"
      via: "GoRoute /playlist builder"
      pattern: "PlaylistScreen"
---

<objective>
Build the PlaylistScreen UI that ties together the entire playlist generation feature: trigger generation from a saved run plan, display loading state, show the generated playlist grouped by segment with song details (title, artist, BPM, segment), enable tapping songs to open Spotify or YouTube via external link, and provide a copy-to-clipboard button. Update the router to replace the _ComingSoonScreen placeholder.

Purpose: This plan delivers the user-facing UI that satisfies all Phase 14 requirements (PLAY-10 through PLAY-14). After this plan, the full playlist generation flow works end-to-end: user navigates from home, taps Generate, sees their BPM-matched playlist, taps songs to play them, and copies the playlist to share.

Output: 1 new file (playlist_screen.dart), 1 edited file (router.dart). All Phase 14 success criteria met.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-playlist-generation/14-RESEARCH.md
@.planning/phases/14-playlist-generation/14-01-SUMMARY.md
@.planning/phases/14-playlist-generation/14-02-SUMMARY.md

@lib/features/playlist/domain/playlist.dart
@lib/features/playlist/providers/playlist_providers.dart
@lib/features/run_plan/providers/run_plan_providers.dart
@lib/features/taste_profile/providers/taste_profile_providers.dart
@lib/features/run_plan/domain/run_plan.dart
@lib/app/router.dart
@lib/features/taste_profile/presentation/taste_profile_screen.dart
@lib/features/home/presentation/home_screen.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PlaylistScreen with full generation UI</name>
  <files>
    lib/features/playlist/presentation/playlist_screen.dart
  </files>
  <action>
Create `lib/features/playlist/presentation/playlist_screen.dart`:

```dart
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist.dart';
import 'package:running_playlist_ai/features/playlist/providers/playlist_providers.dart';
import 'package:running_playlist_ai/features/run_plan/domain/run_plan.dart';
import 'package:running_playlist_ai/features/run_plan/providers/run_plan_providers.dart';
import 'package:url_launcher/url_launcher.dart';

/// Screen for generating and displaying a BPM-matched playlist.
///
/// States:
/// - No run plan: shows message directing user to create one
/// - Idle (with run plan): shows Generate button with run plan summary
/// - Loading: shows progress indicator
/// - Loaded: shows playlist grouped by segment with song cards
/// - Error: shows error message with retry button
class PlaylistScreen extends ConsumerWidget {
  const PlaylistScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final generationState = ref.watch(playlistGenerationProvider);
    final runPlan = ref.watch(runPlanNotifierProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Generate Playlist'),
        actions: [
          if (generationState.playlist != null)
            IconButton(
              onPressed: () => _copyPlaylist(context, generationState.playlist!),
              icon: const Icon(Icons.copy),
              tooltip: 'Copy playlist to clipboard',
            ),
        ],
      ),
      body: _buildBody(context, ref, generationState, runPlan),
    );
  }

  Widget _buildBody(
    BuildContext context,
    WidgetRef ref,
    PlaylistGenerationState state,
    RunPlan? runPlan,
  ) {
    // No run plan saved
    if (runPlan == null && !state.isLoading && state.playlist == null) {
      return _NoRunPlanView(
        onGoToRunPlan: () => context.push('/run-plan'),
      );
    }

    // Loading
    if (state.isLoading) {
      return const _LoadingView();
    }

    // Error
    if (state.error != null) {
      return _ErrorView(
        error: state.error!,
        onRetry: () => ref
            .read(playlistGenerationProvider.notifier)
            .generatePlaylist(),
      );
    }

    // Loaded with playlist
    if (state.playlist != null) {
      return _PlaylistView(
        playlist: state.playlist!,
        onRegenerate: () => ref
            .read(playlistGenerationProvider.notifier)
            .generatePlaylist(),
      );
    }

    // Idle with run plan -- show generate prompt
    return _IdleView(
      runPlan: runPlan!,
      onGenerate: () => ref
          .read(playlistGenerationProvider.notifier)
          .generatePlaylist(),
    );
  }

  Future<void> _copyPlaylist(BuildContext context, Playlist playlist) async {
    await Clipboard.setData(ClipboardData(text: playlist.toClipboardText()));
    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Playlist copied to clipboard!')),
      );
    }
  }
}

/// Shown when the user has no saved run plan.
class _NoRunPlanView extends StatelessWidget {
  const _NoRunPlanView({required this.onGoToRunPlan});

  final VoidCallback onGoToRunPlan;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.directions_run, size: 64, color: Colors.grey),
            const SizedBox(height: 16),
            const Text(
              'No Run Plan',
              style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            const Text(
              'Create a run plan first to generate a playlist matched to your cadence.',
              textAlign: TextAlign.center,
              style: TextStyle(fontSize: 16, color: Colors.grey),
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: onGoToRunPlan,
              icon: const Icon(Icons.timer),
              label: const Text('Create Run Plan'),
            ),
          ],
        ),
      ),
    );
  }
}

/// Shown while the playlist is being generated.
class _LoadingView extends StatelessWidget {
  const _LoadingView();

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(),
          SizedBox(height: 16),
          Text(
            'Finding songs for your run...',
            style: TextStyle(fontSize: 16),
          ),
          SizedBox(height: 8),
          Text(
            'Matching BPM to your cadence',
            style: TextStyle(fontSize: 14, color: Colors.grey),
          ),
        ],
      ),
    );
  }
}

/// Shown when generation fails.
class _ErrorView extends StatelessWidget {
  const _ErrorView({required this.error, required this.onRetry});

  final String error;
  final VoidCallback onRetry;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text(
              error,
              textAlign: TextAlign.center,
              style: const TextStyle(fontSize: 16),
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: onRetry,
              icon: const Icon(Icons.refresh),
              label: const Text('Try Again'),
            ),
          ],
        ),
      ),
    );
  }
}

/// Shown when a run plan is saved but no playlist has been generated yet.
class _IdleView extends StatelessWidget {
  const _IdleView({required this.runPlan, required this.onGenerate});

  final RunPlan runPlan;
  final VoidCallback onGenerate;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.queue_music, size: 64, color: Colors.blue),
            const SizedBox(height: 16),
            Text(
              runPlan.name ?? 'Your Run Plan',
              style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            Text(
              '${runPlan.distanceKm.toStringAsFixed(1)} km '
              '${formatDuration(runPlan.totalDurationSeconds)} '
              '${runPlan.segments.length} segment${runPlan.segments.length == 1 ? "" : "s"}',
              style: const TextStyle(fontSize: 16, color: Colors.grey),
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: onGenerate,
              icon: const Icon(Icons.play_arrow),
              label: const Text('Generate Playlist'),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(
                  horizontal: 32,
                  vertical: 16,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Displays the generated playlist grouped by segment.
class _PlaylistView extends StatelessWidget {
  const _PlaylistView({required this.playlist, required this.onRegenerate});

  final Playlist playlist;
  final VoidCallback onRegenerate;

  @override
  Widget build(BuildContext context) {
    if (playlist.songs.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Icon(Icons.music_off, size: 64, color: Colors.grey),
              const SizedBox(height: 16),
              const Text(
                'No songs found',
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              const Text(
                'No songs matched your run plan BPM. Try adjusting your pace or taste profile.',
                textAlign: TextAlign.center,
                style: TextStyle(fontSize: 16, color: Colors.grey),
              ),
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onRegenerate,
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
              ),
            ],
          ),
        ),
      );
    }

    return Column(
      children: [
        // Summary header
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 16, 16, 0),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  '${playlist.songs.length} songs for your run',
                  style: const TextStyle(
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              TextButton.icon(
                onPressed: onRegenerate,
                icon: const Icon(Icons.refresh, size: 18),
                label: const Text('Regenerate'),
              ),
            ],
          ),
        ),
        const Divider(),
        // Song list grouped by segment
        Expanded(
          child: ListView.builder(
            padding: const EdgeInsets.only(bottom: 16),
            itemCount: playlist.songs.length,
            itemBuilder: (context, index) {
              final song = playlist.songs[index];
              final showSegmentHeader = index == 0 ||
                  playlist.songs[index - 1].segmentLabel != song.segmentLabel;

              return Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (showSegmentHeader)
                    _SegmentHeader(label: song.segmentLabel),
                  _SongTile(song: song),
                ],
              );
            },
          ),
        ),
      ],
    );
  }
}

/// Segment header row in the playlist list.
class _SegmentHeader extends StatelessWidget {
  const _SegmentHeader({required this.label});

  final String label;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 4),
      color: Theme.of(context).colorScheme.surfaceContainerHighest,
      child: Text(
        label,
        style: TextStyle(
          fontSize: 14,
          fontWeight: FontWeight.bold,
          color: Theme.of(context).colorScheme.onSurfaceVariant,
        ),
      ),
    );
  }
}

/// Individual song tile with tap-to-open external link.
class _SongTile extends StatelessWidget {
  const _SongTile({required this.song});

  final PlaylistSong song;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(
        song.title,
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      subtitle: Text(
        '${song.artistName}  ${_matchLabel(song.matchType)}',
        maxLines: 1,
        overflow: TextOverflow.ellipsis,
      ),
      trailing: Text(
        '${song.bpm} BPM',
        style: TextStyle(
          color: Theme.of(context).colorScheme.primary,
          fontWeight: FontWeight.w500,
        ),
      ),
      onTap: () => _showPlayOptions(context),
    );
  }

  String _matchLabel(BpmMatchType type) {
    switch (type) {
      case BpmMatchType.exact:
        return '';
      case BpmMatchType.halfTime:
        return '(half-time)';
      case BpmMatchType.doubleTime:
        return '(double-time)';
    }
  }

  void _showPlayOptions(BuildContext context) {
    showModalBottomSheet<void>(
      context: context,
      builder: (context) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Text(
                '${song.title} - ${song.artistName}',
                style: const TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
            ),
            const Divider(height: 1),
            if (song.spotifyUrl != null)
              ListTile(
                leading: const Icon(Icons.music_note),
                title: const Text('Open in Spotify'),
                onTap: () {
                  Navigator.pop(context);
                  _launchUrl(context, song.spotifyUrl!);
                },
              ),
            if (song.youtubeUrl != null)
              ListTile(
                leading: const Icon(Icons.play_circle_outline),
                title: const Text('Open in YouTube Music'),
                onTap: () {
                  Navigator.pop(context);
                  _launchUrl(context, song.youtubeUrl!);
                },
              ),
            const SizedBox(height: 8),
          ],
        ),
      ),
    );
  }

  Future<void> _launchUrl(BuildContext context, String url) async {
    final uri = Uri.parse(url);
    if (!await launchUrl(uri, mode: LaunchMode.externalApplication)) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Could not open link')),
        );
      }
    }
  }
}
```

IMPORTANT DESIGN DECISIONS:
- **ConsumerWidget, not ConsumerStatefulWidget**: Follows HomeScreen pattern. All state is managed by Riverpod providers.
- **Five sub-views**: _NoRunPlanView, _LoadingView, _ErrorView, _IdleView, _PlaylistView. Clear separation of states.
- **Song tap â†’ bottom sheet with Spotify/YouTube options**: Not a direct link -- gives the user a choice. Uses `launchUrl` with `LaunchMode.externalApplication` to open in the respective app.
- **Copy button in AppBar**: Only visible when a playlist is generated. Uses `Clipboard.setData` + `SnackBar` confirmation.
- **Segment headers**: `_SegmentHeader` only shown when the segment label changes from the previous song. Uses `surfaceContainerHighest` for subtle background differentiation.
- **Match type label**: Shows "(half-time)" or "(double-time)" in subtitle for non-exact matches. Empty string for exact (less visual noise).
- **formatDuration** imported from run_plan.dart for the idle view run plan summary.
- **No `canLaunchUrl` check**: Per RESEARCH.md, just call `launchUrl` directly and handle failure. Avoids Android 11+ `<queries>` complexity.
- **Regenerate button**: Visible in the loaded state to let users get a different playlist (shuffle produces different results).
  </action>
  <verify>
Run `dart analyze lib/features/playlist/presentation/` -- no errors or warnings. Verify the file imports `url_launcher` and `services.dart` (for Clipboard).
  </verify>
  <done>
PlaylistScreen with 5 state views (no run plan, idle, loading, loaded, error). Song tap opens bottom sheet with Spotify/YouTube options via launchUrl. Copy button in AppBar uses Clipboard.setData. Segment headers group songs visually. Regenerate button for new results.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update router to use PlaylistScreen</name>
  <files>
    lib/app/router.dart
  </files>
  <action>
**2a. Update `lib/app/router.dart`:**

Add the import for PlaylistScreen at the top of the file:

```dart
import 'package:running_playlist_ai/features/playlist/presentation/playlist_screen.dart';
```

Then replace the `/playlist` route's builder from `_ComingSoonScreen` to `PlaylistScreen`:

Find:
```dart
      GoRoute(
        path: '/playlist',
        builder: (context, state) =>
            const _ComingSoonScreen(title: 'Generate Playlist'),
      ),
```

Replace with:
```dart
      GoRoute(
        path: '/playlist',
        builder: (context, state) => const PlaylistScreen(),
      ),
```

**2b. Clean up _ComingSoonScreen if no longer used:**

After replacing the `/playlist` route, check if `_ComingSoonScreen` is still used. The `/playlist-history` route still uses it, so do NOT delete the class. Leave it in place for Phase 15.
  </action>
  <verify>
Run `dart analyze lib/app/router.dart` -- no errors or warnings. Verify the `/playlist` route uses `PlaylistScreen()` (not `_ComingSoonScreen`). Verify `_ComingSoonScreen` is still present (used by `/playlist-history`). Run `dart analyze lib/` to check for no import issues.
  </verify>
  <done>
Router `/playlist` route points to PlaylistScreen. Import added. _ComingSoonScreen retained for `/playlist-history` (Phase 15).
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/playlist/presentation/` -- no issues
2. `dart analyze lib/app/router.dart` -- no issues
3. `flutter test` -- all existing tests still pass (no regressions)
4. Router `/playlist` route builds PlaylistScreen
5. PlaylistScreen imports url_launcher and services.dart
6. PlaylistScreen reads playlistGenerationProvider for state
7. PlaylistScreen reads runPlanNotifierProvider for run plan check
8. Tap on song shows bottom sheet with Spotify and YouTube options
9. Copy button calls Clipboard.setData with playlist.toClipboardText()
10. Error state shows retry button that calls generatePlaylist()
</verification>

<success_criteria>
- User navigates to /playlist and sees idle view with run plan summary and Generate button
- User without a run plan sees helpful message with link to create one
- Tapping Generate shows loading indicator, then displays playlist grouped by segment
- Each song shows title, artist, BPM, and match type (half/double-time indicated)
- Tapping a song opens bottom sheet with Spotify and YouTube Music options
- Tapping Spotify/YouTube opens external URL via launchUrl
- Copy button in AppBar copies formatted playlist text to clipboard with SnackBar confirmation
- Error state shows message and retry button
- Regenerate button produces a new shuffled playlist
- All Phase 14 requirements satisfied: PLAY-10 (generation), PLAY-11 (taste filtering), PLAY-12 (song details), PLAY-13 (external links), PLAY-14 (clipboard copy)
</success_criteria>

<output>
After completion, create `.planning/phases/14-playlist-generation/14-03-SUMMARY.md`
</output>
