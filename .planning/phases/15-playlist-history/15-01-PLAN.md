---
phase: 15-playlist-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/playlist/domain/playlist.dart
  - lib/features/playlist/domain/playlist_generator.dart
  - lib/features/playlist/data/playlist_history_preferences.dart
  - lib/features/playlist/providers/playlist_history_providers.dart
  - lib/features/playlist/providers/playlist_providers.dart
  - test/features/playlist/domain/playlist_test.dart
  - test/features/playlist/domain/playlist_generator_test.dart
  - test/features/playlist/data/playlist_history_preferences_test.dart
  - test/features/playlist/providers/playlist_history_providers_test.dart
autonomous: true

must_haves:
  truths:
    - "Playlist model has id, distanceKm, and paceMinPerKm fields"
    - "Existing Playlist.fromJson works with old JSON that lacks new fields (backward compatible)"
    - "PlaylistGenerator assigns id, distanceKm, and paceMinPerKm from RunPlan"
    - "Playlist history can be saved and loaded from SharedPreferences"
    - "Generating a playlist auto-saves it to history"
    - "A playlist can be deleted from history by ID"
    - "History is capped at 50 playlists"
  artifacts:
    - path: "lib/features/playlist/domain/playlist.dart"
      provides: "Playlist model with id, distanceKm, paceMinPerKm fields"
      contains: "distanceKm"
    - path: "lib/features/playlist/data/playlist_history_preferences.dart"
      provides: "SharedPreferences persistence for playlist history list"
      exports: ["PlaylistHistoryPreferences"]
    - path: "lib/features/playlist/providers/playlist_history_providers.dart"
      provides: "StateNotifier for playlist history state"
      exports: ["PlaylistHistoryNotifier", "playlistHistoryProvider"]
  key_links:
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/playlist/providers/playlist_history_providers.dart"
      via: "ref.read(playlistHistoryProvider.notifier).addPlaylist(playlist)"
      pattern: "playlistHistoryProvider"
    - from: "lib/features/playlist/providers/playlist_history_providers.dart"
      to: "lib/features/playlist/data/playlist_history_preferences.dart"
      via: "PlaylistHistoryPreferences.load() and .save()"
      pattern: "PlaylistHistoryPreferences"
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/run_plan/domain/run_plan.dart"
      via: "id, distanceKm, paceMinPerKm in Playlist constructor"
      pattern: "runPlan\\.distanceKm"
---

<objective>
Add playlist history data layer: extend the Playlist model with id/distanceKm/paceMinPerKm fields, create persistence and provider layers for playlist history, wire auto-save into playlist generation, and add comprehensive unit tests.

Purpose: Establish the data foundation for playlist history (HIST-01, HIST-02, HIST-03) so the UI layer (Plan 15-02) can display, navigate, and delete saved playlists.
Output: Extended Playlist model, PlaylistHistoryPreferences, PlaylistHistoryNotifier, auto-save in generation flow, and unit tests for all.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-playlist-history/15-RESEARCH.md

@lib/features/playlist/domain/playlist.dart
@lib/features/playlist/domain/playlist_generator.dart
@lib/features/playlist/providers/playlist_providers.dart
@lib/features/run_plan/domain/run_plan.dart
@lib/features/taste_profile/data/taste_profile_preferences.dart
@test/features/playlist/domain/playlist_test.dart
@test/features/playlist/domain/playlist_generator_test.dart
@test/features/playlist/providers/playlist_providers_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend Playlist model and PlaylistGenerator with history fields</name>
  <files>
    lib/features/playlist/domain/playlist.dart
    lib/features/playlist/domain/playlist_generator.dart
    test/features/playlist/domain/playlist_test.dart
    test/features/playlist/domain/playlist_generator_test.dart
  </files>
  <action>
**1. Extend Playlist model** in `lib/features/playlist/domain/playlist.dart`:

Add three new optional fields to the `Playlist` class:

```dart
class Playlist {
  const Playlist({
    required this.songs,
    required this.totalDurationSeconds,
    required this.createdAt,
    this.id,
    this.runPlanName,
    this.distanceKm,
    this.paceMinPerKm,
  });
```

Add the fields:
```dart
  final String? id;
  final double? distanceKm;
  final double? paceMinPerKm;
```

Update `fromJson` to read the new fields with null-safety (backward compatible -- old JSON without these fields will produce null values):
```dart
factory Playlist.fromJson(Map<String, dynamic> json) {
  return Playlist(
    id: json['id'] as String?,
    songs: (json['songs'] as List<dynamic>)
        .map((s) => PlaylistSong.fromJson(s as Map<String, dynamic>))
        .toList(),
    totalDurationSeconds: (json['totalDurationSeconds'] as num).toInt(),
    createdAt: DateTime.parse(json['createdAt'] as String),
    runPlanName: json['runPlanName'] as String?,
    distanceKm: (json['distanceKm'] as num?)?.toDouble(),
    paceMinPerKm: (json['paceMinPerKm'] as num?)?.toDouble(),
  );
}
```

Update `toJson` to include the new fields conditionally (only when non-null, matching existing pattern for `runPlanName`):
```dart
Map<String, dynamic> toJson() => {
      if (id != null) 'id': id,
      'songs': songs.map((s) => s.toJson()).toList(),
      'totalDurationSeconds': totalDurationSeconds,
      'createdAt': createdAt.toIso8601String(),
      'runPlanName': runPlanName,
      if (distanceKm != null) 'distanceKm': distanceKm,
      if (paceMinPerKm != null) 'paceMinPerKm': paceMinPerKm,
    };
```

**IMPORTANT:** The `id` field goes BEFORE `songs` in both the constructor parameter list and the field declarations. Place `distanceKm` and `paceMinPerKm` after `createdAt` in the field declarations.

**2. Update PlaylistGenerator.generate()** in `lib/features/playlist/domain/playlist_generator.dart`:

Change the return statement at the end of `generate()` to include the three new fields:
```dart
return Playlist(
  id: DateTime.now().millisecondsSinceEpoch.toString(),
  songs: allPlaylistSongs,
  runPlanName: runPlan.name,
  totalDurationSeconds: runPlan.totalDurationSeconds,
  createdAt: DateTime.now(),
  distanceKm: runPlan.distanceKm,
  paceMinPerKm: runPlan.paceMinPerKm,
);
```

**3. Update existing tests** to ensure they still pass:

In `test/features/playlist/domain/playlist_test.dart`:
- The existing Playlist serialization tests construct `Playlist(songs: ..., totalDurationSeconds: ..., createdAt: ...)` without `id`, `distanceKm`, or `paceMinPerKm`. These MUST continue to work because those fields are optional. **Do not modify existing test cases.**
- ADD a new test group after the existing 'Playlist serialization' group:

```dart
group('Playlist serialization with history fields', () {
  test('toJson -> fromJson round-trip preserves id, distanceKm, paceMinPerKm', () {
    final original = Playlist(
      id: '1738765200000',
      songs: const [],
      totalDurationSeconds: 1800,
      createdAt: DateTime.utc(2026, 2, 5, 14, 30),
      runPlanName: 'My 5K',
      distanceKm: 5.0,
      paceMinPerKm: 6.0,
    );

    final json = original.toJson();
    final restored = Playlist.fromJson(json);

    expect(restored.id, equals('1738765200000'));
    expect(restored.distanceKm, equals(5.0));
    expect(restored.paceMinPerKm, equals(6.0));
  });

  test('fromJson handles missing id, distanceKm, paceMinPerKm (backward compat)', () {
    final json = {
      'songs': <dynamic>[],
      'totalDurationSeconds': 600,
      'createdAt': '2026-01-01T00:00:00.000Z',
      'runPlanName': 'Old Playlist',
    };

    final playlist = Playlist.fromJson(json);
    expect(playlist.id, isNull);
    expect(playlist.distanceKm, isNull);
    expect(playlist.paceMinPerKm, isNull);
    expect(playlist.runPlanName, equals('Old Playlist'));
  });

  test('toJson omits null id, distanceKm, paceMinPerKm', () {
    final playlist = Playlist(
      songs: const [],
      totalDurationSeconds: 600,
      createdAt: DateTime.utc(2026),
    );

    final json = playlist.toJson();
    expect(json.containsKey('id'), isFalse);
    expect(json.containsKey('distanceKm'), isFalse);
    expect(json.containsKey('paceMinPerKm'), isFalse);
  });
});
```

In `test/features/playlist/domain/playlist_generator_test.dart`:
- ADD a new test in the 'PlaylistGenerator.generate' group to verify the new fields:

```dart
test('assigns id, distanceKm, and paceMinPerKm from run plan', () {
  const plan = RunPlan(
    type: RunType.steady,
    distanceKm: 5,
    paceMinPerKm: 6,
    segments: [
      RunSegment(
        durationSeconds: 210,
        targetBpm: 170,
        label: 'Running',
      ),
    ],
  );

  final songsByBpm = {
    170: [_song()],
  };

  final playlist = PlaylistGenerator.generate(
    runPlan: plan,
    songsByBpm: songsByBpm,
    random: Random(42),
  );

  expect(playlist.id, isNotNull);
  expect(playlist.id, isNotEmpty);
  expect(playlist.distanceKm, equals(5.0));
  expect(playlist.paceMinPerKm, equals(6.0));
});
```
  </action>
  <verify>
Run: `cd /Users/tijmen/running-playlist-ai && flutter test test/features/playlist/domain/playlist_test.dart test/features/playlist/domain/playlist_generator_test.dart`

All existing tests pass. New tests pass. Zero failures.
  </verify>
  <done>
- Playlist model has `id`, `distanceKm`, `paceMinPerKm` fields
- `fromJson` handles old JSON without new fields (backward compatible)
- `toJson` conditionally includes new fields
- PlaylistGenerator assigns all three from RunPlan input
- All existing tests still pass, new tests verify the additions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create persistence, provider, auto-save hook, and tests</name>
  <files>
    lib/features/playlist/data/playlist_history_preferences.dart
    lib/features/playlist/providers/playlist_history_providers.dart
    lib/features/playlist/providers/playlist_providers.dart
    test/features/playlist/data/playlist_history_preferences_test.dart
    test/features/playlist/providers/playlist_history_providers_test.dart
  </files>
  <action>
**1. Create PlaylistHistoryPreferences** at `lib/features/playlist/data/playlist_history_preferences.dart`:

Follow the exact pattern of `TasteProfilePreferences` (single-key JSON storage):

```dart
import 'dart:convert';

import 'package:running_playlist_ai/features/playlist/domain/playlist.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Persistence wrapper for playlist generation history.
///
/// Stores a list of [Playlist] objects as a single JSON-encoded string
/// in SharedPreferences under the key `playlist_history`. The collection
/// is always loaded and saved as a whole (not per-entry).
///
/// Follows the same single-key pattern as [TasteProfilePreferences].
class PlaylistHistoryPreferences {
  static const _key = 'playlist_history';

  /// Maximum number of playlists to store. Oldest are trimmed on save.
  static const maxHistorySize = 50;

  /// Loads the saved playlist history, or null if none is stored.
  static Future<List<Playlist>?> load() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_key);
    if (jsonString == null) return null;
    final list = jsonDecode(jsonString) as List<dynamic>;
    return list
        .map((e) => Playlist.fromJson(e as Map<String, dynamic>))
        .toList();
  }

  /// Saves the given playlist history as a JSON string.
  ///
  /// Trims the list to [maxHistorySize] entries (keeping the first/newest).
  static Future<void> save(List<Playlist> playlists) async {
    final prefs = await SharedPreferences.getInstance();
    final trimmed = playlists.length > maxHistorySize
        ? playlists.sublist(0, maxHistorySize)
        : playlists;
    final jsonString =
        jsonEncode(trimmed.map((p) => p.toJson()).toList());
    await prefs.setString(_key, jsonString);
  }

  /// Removes the stored playlist history.
  static Future<void> clear() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_key);
  }
}
```

**2. Create PlaylistHistoryNotifier** at `lib/features/playlist/providers/playlist_history_providers.dart`:

Follow the StateNotifier pattern used throughout the app (RunPlanNotifier, TasteProfileNotifier):

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:running_playlist_ai/features/playlist/data/playlist_history_preferences.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist.dart';

/// Manages the list of saved playlists in history.
///
/// Loads from [PlaylistHistoryPreferences] on construction, provides
/// methods to add and delete playlists, and persists every mutation.
class PlaylistHistoryNotifier extends StateNotifier<List<Playlist>> {
  PlaylistHistoryNotifier() : super([]) {
    _load();
  }

  Future<void> _load() async {
    final playlists = await PlaylistHistoryPreferences.load();
    if (playlists != null && mounted) {
      state = playlists;
    }
  }

  /// Adds a playlist to the front of history (newest first) and persists.
  Future<void> addPlaylist(Playlist playlist) async {
    state = [playlist, ...state];
    await PlaylistHistoryPreferences.save(state);
  }

  /// Deletes a playlist by [id] and persists.
  Future<void> deletePlaylist(String id) async {
    state = state.where((p) => p.id != id).toList();
    await PlaylistHistoryPreferences.save(state);
  }
}

/// Provides the playlist history state and notifier.
///
/// Usage:
/// - `ref.watch(playlistHistoryProvider)` for the `List<Playlist>` state
/// - `ref.read(playlistHistoryProvider.notifier).addPlaylist(...)` to add
/// - `ref.read(playlistHistoryProvider.notifier).deletePlaylist(id)` to remove
final playlistHistoryProvider =
    StateNotifierProvider<PlaylistHistoryNotifier, List<Playlist>>((ref) {
  return PlaylistHistoryNotifier();
});
```

**3. Add auto-save hook in PlaylistGenerationNotifier** in `lib/features/playlist/providers/playlist_providers.dart`:

Add the import at the top of the file:
```dart
import 'package:running_playlist_ai/features/playlist/providers/playlist_history_providers.dart';
```

In the `generatePlaylist()` method, RIGHT AFTER the line:
```dart
state = PlaylistGenerationState.loaded(playlist);
```

Add:
```dart
// Auto-save to history
ref.read(playlistHistoryProvider.notifier).addPlaylist(playlist);
```

This goes inside the try block, after `state = PlaylistGenerationState.loaded(playlist);` and before the closing of the try block. The full context after the change:
```dart
if (!mounted) return;
state = PlaylistGenerationState.loaded(playlist);

// Auto-save to history
ref.read(playlistHistoryProvider.notifier).addPlaylist(playlist);
```

**4. Create test for PlaylistHistoryPreferences** at `test/features/playlist/data/playlist_history_preferences_test.dart`:

```dart
import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:running_playlist_ai/features/playlist/data/playlist_history_preferences.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist.dart';
import 'package:shared_preferences/shared_preferences.dart';

Playlist _playlist({
  String id = '1',
  String name = 'Test Run',
  double distanceKm = 5.0,
  double paceMinPerKm = 6.0,
}) =>
    Playlist(
      id: id,
      songs: const [
        PlaylistSong(
          title: 'Song A',
          artistName: 'Artist A',
          bpm: 170,
          matchType: BpmMatchType.exact,
          segmentLabel: 'Running',
          segmentIndex: 0,
        ),
      ],
      runPlanName: name,
      totalDurationSeconds: 1800,
      createdAt: DateTime.utc(2026, 2, 5),
      distanceKm: distanceKm,
      paceMinPerKm: paceMinPerKm,
    );

void main() {
  setUp(() {
    SharedPreferences.setMockInitialValues({});
  });

  group('PlaylistHistoryPreferences', () {
    test('load returns null when nothing is stored', () async {
      final result = await PlaylistHistoryPreferences.load();
      expect(result, isNull);
    });

    test('save and load round-trip preserves playlists', () async {
      final playlists = [
        _playlist(id: '1', name: 'Run 1'),
        _playlist(id: '2', name: 'Run 2'),
      ];

      await PlaylistHistoryPreferences.save(playlists);
      final loaded = await PlaylistHistoryPreferences.load();

      expect(loaded, isNotNull);
      expect(loaded!.length, equals(2));
      expect(loaded[0].id, equals('1'));
      expect(loaded[0].runPlanName, equals('Run 1'));
      expect(loaded[0].distanceKm, equals(5.0));
      expect(loaded[0].paceMinPerKm, equals(6.0));
      expect(loaded[0].songs.length, equals(1));
      expect(loaded[1].id, equals('2'));
    });

    test('save trims to maxHistorySize', () async {
      final playlists = List.generate(
        60,
        (i) => _playlist(id: '$i', name: 'Run $i'),
      );

      await PlaylistHistoryPreferences.save(playlists);
      final loaded = await PlaylistHistoryPreferences.load();

      expect(loaded!.length, equals(50));
      expect(loaded.first.id, equals('0'));
      expect(loaded.last.id, equals('49'));
    });

    test('clear removes stored data', () async {
      await PlaylistHistoryPreferences.save([_playlist()]);
      await PlaylistHistoryPreferences.clear();
      final result = await PlaylistHistoryPreferences.load();
      expect(result, isNull);
    });
  });
}
```

**5. Create test for PlaylistHistoryNotifier** at `test/features/playlist/providers/playlist_history_providers_test.dart`:

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:running_playlist_ai/features/bpm_lookup/domain/bpm_song.dart';
import 'package:running_playlist_ai/features/playlist/domain/playlist.dart';
import 'package:running_playlist_ai/features/playlist/providers/playlist_history_providers.dart';
import 'package:shared_preferences/shared_preferences.dart';

Playlist _playlist({
  String id = '1',
  String name = 'Test Run',
}) =>
    Playlist(
      id: id,
      songs: const [
        PlaylistSong(
          title: 'Song',
          artistName: 'Artist',
          bpm: 170,
          matchType: BpmMatchType.exact,
          segmentLabel: 'Running',
          segmentIndex: 0,
        ),
      ],
      runPlanName: name,
      totalDurationSeconds: 1800,
      createdAt: DateTime.utc(2026, 2, 5),
      distanceKm: 5.0,
      paceMinPerKm: 6.0,
    );

void main() {
  setUp(() {
    SharedPreferences.setMockInitialValues({});
  });

  group('PlaylistHistoryNotifier', () {
    test('starts with empty list', () {
      final container = ProviderContainer();
      final state = container.read(playlistHistoryProvider);
      expect(state, isEmpty);
    });

    test('addPlaylist prepends to list and persists', () async {
      final container = ProviderContainer();
      final notifier =
          container.read(playlistHistoryProvider.notifier);

      await notifier.addPlaylist(_playlist(id: '1', name: 'Run 1'));
      await notifier.addPlaylist(_playlist(id: '2', name: 'Run 2'));

      final state = container.read(playlistHistoryProvider);
      expect(state.length, equals(2));
      expect(state[0].id, equals('2'));
      expect(state[1].id, equals('1'));
    });

    test('deletePlaylist removes by id and persists', () async {
      final container = ProviderContainer();
      final notifier =
          container.read(playlistHistoryProvider.notifier);

      await notifier.addPlaylist(_playlist(id: '1'));
      await notifier.addPlaylist(_playlist(id: '2'));
      await notifier.deletePlaylist('1');

      final state = container.read(playlistHistoryProvider);
      expect(state.length, equals(1));
      expect(state[0].id, equals('2'));
    });

    test('loads persisted playlists on construction', () async {
      // First: save some playlists via a notifier
      final container1 = ProviderContainer();
      final notifier1 =
          container1.read(playlistHistoryProvider.notifier);
      await notifier1.addPlaylist(_playlist(id: '1', name: 'Saved'));

      // Second: create new container (simulates app restart)
      final container2 = ProviderContainer();
      // Read the notifier to trigger construction
      container2.read(playlistHistoryProvider.notifier);
      // Wait for async _load() to complete
      await Future<void>.delayed(const Duration(milliseconds: 50));

      final state = container2.read(playlistHistoryProvider);
      expect(state.length, equals(1));
      expect(state[0].runPlanName, equals('Saved'));
    });
  });
}
```

**IMPORTANT NOTES:**
- Do NOT modify any existing test cases. Only ADD new test groups/cases.
- The existing `playlist_providers_test.dart` does NOT need changes -- the auto-save hook will simply call `ref.read(playlistHistoryProvider.notifier).addPlaylist(playlist)` after generation, and those integration tests don't validate history side effects. The new `playlist_history_providers_test.dart` covers the notifier in isolation.
- Ensure the `data/` directory exists under `lib/features/playlist/` before creating `playlist_history_preferences.dart`.
  </action>
  <verify>
Run all tests:
```bash
cd /Users/tijmen/running-playlist-ai && flutter test test/features/playlist/
```

All tests pass (existing and new). Zero failures.

Then verify the auto-save import compiles:
```bash
cd /Users/tijmen/running-playlist-ai && flutter analyze lib/features/playlist/providers/playlist_providers.dart
```

No errors or warnings.
  </verify>
  <done>
- PlaylistHistoryPreferences persists list of playlists to SharedPreferences
- PlaylistHistoryNotifier manages history state with add/delete
- Auto-save hook in PlaylistGenerationNotifier saves every generated playlist
- History capped at 50 playlists
- All tests pass: persistence, notifier, and existing tests unbroken
  </done>
</task>

</tasks>

<verification>
Run the full test suite to confirm nothing is broken:
```bash
cd /Users/tijmen/running-playlist-ai && flutter test test/features/playlist/
```

Verify static analysis:
```bash
cd /Users/tijmen/running-playlist-ai && flutter analyze lib/features/playlist/
```

Both must produce zero errors.
</verification>

<success_criteria>
1. Playlist model has `id` (String?), `distanceKm` (double?), `paceMinPerKm` (double?) fields
2. fromJson is backward-compatible with old JSON missing new fields
3. PlaylistGenerator.generate() populates id, distanceKm, paceMinPerKm
4. PlaylistHistoryPreferences save/load/clear works with SharedPreferences
5. PlaylistHistoryNotifier loads on construction, supports add and delete
6. History is capped at 50 entries
7. Auto-save hook fires after successful generation
8. All existing tests pass unchanged
9. New tests cover model extensions, preferences, and notifier
</success_criteria>

<output>
After completion, create `.planning/phases/15-playlist-history/15-01-SUMMARY.md`
</output>
