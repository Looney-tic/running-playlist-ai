---
phase: 16-scoring-foundation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/features/song_quality/domain/song_quality_scorer.dart
  - test/features/song_quality/domain/song_quality_scorer_test.dart
autonomous: true

must_haves:
  truths:
    - "A song with high danceability scores higher than one with low danceability at the same BPM"
    - "A song matching the user's genre preference scores higher than a non-matching song"
    - "A user with 'chill' energy preference gets different scores than a user with 'intense' preference"
    - "Warm-up segments prefer lower-energy songs and sprint segments prefer higher-energy songs"
    - "A song by the same artist as the previous song receives a penalty"
    - "Scoring degrades gracefully when danceability or taste profile is absent"
  artifacts:
    - path: "lib/features/song_quality/domain/song_quality_scorer.dart"
      provides: "Composite scoring algorithm with 6 weighted dimensions"
      exports: ["SongQualityScorer"]
    - path: "test/features/song_quality/domain/song_quality_scorer_test.dart"
      provides: "Unit tests for all scoring dimensions and edge cases"
      min_lines: 150
  key_links:
    - from: "song_quality_scorer.dart"
      to: "taste_profile.dart"
      via: "imports TasteProfile, EnergyLevel, RunningGenre"
      pattern: "import.*taste_profile"
---

<objective>
Create the SongQualityScorer -- a pure Dart scoring class that computes a composite running-suitability score for candidate songs using danceability, genre match, energy alignment, segment-aware energy, artist diversity, and BPM accuracy.

Purpose: This is the core scoring algorithm for Phase 16. All six QUAL requirements depend on this scorer working correctly. It replaces the simple artist+BPM scoring with a multi-dimensional ranking that makes playlists genuinely better for running.

Output: A tested, pure Dart class with static scoring methods and no Flutter dependencies.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/features/taste_profile/domain/taste_profile.dart
@lib/features/bpm_lookup/domain/bpm_song.dart
@lib/features/playlist/domain/playlist_generator.dart
</context>

<feature>
  <name>SongQualityScorer -- composite running quality scoring</name>
  <files>
    lib/features/song_quality/domain/song_quality_scorer.dart
    test/features/song_quality/domain/song_quality_scorer_test.dart
  </files>
  <behavior>
    SongQualityScorer is a pure Dart class with a single `score()` static method and an `enforceArtistDiversity()` static method.

    ## score() method

    Signature:
    ```dart
    static int score({
      required BpmSong song,
      TasteProfile? tasteProfile,
      int? danceability,           // 0-100, from enrichment (nullable = unknown)
      String? segmentLabel,        // "Warm-up", "Main", "Cool-down", "Work N", "Rest N"
      String? previousArtist,      // artist name of the previously selected song
    })
    ```

    Scoring dimensions and weights:

    1. **Artist match: +10** (existing logic, preserved)
       - Case-insensitive substring match between song.artistName and tasteProfile.artists
       - If tasteProfile is null or artists list is empty: +0

    2. **Genre match: +6** (NEW -- QUAL-03)
       - Compare song artist name against a genre keyword map that maps RunningGenre values to common GetSongBPM genre/artist keywords
       - This is a HEURISTIC since we don't have per-song genre data from the /tempo/ endpoint
       - Use a static map of RunningGenre -> List<String> keywords. For now, leave this as a stub that returns +0 (genre data from API is not confirmed available from /tempo/ endpoint). The scoring slot is reserved and tested with a manual override parameter.
       - Add optional `List<RunningGenre>? songGenres` parameter to score() for future use when enrichment data is available
       - If songGenres is provided AND any match tasteProfile.genres: +6
       - If songGenres is null: +0 (no penalty for unknown genre)

    3. **Danceability score: +8** (NEW -- QUAL-01, QUAL-02)
       - Scale danceability (0-100) to a 0-8 point range
       - Formula: `(danceability / 100 * 8).round().clamp(0, 8)`
       - If danceability is null (not enriched): +4 (neutral midpoint, no penalty)
       - High danceability = high score. This directly implements the Karageorghis rhythm response priority.

    4. **Energy alignment: +4** (NEW -- QUAL-05, QUAL-06)
       - Maps the user's EnergyLevel preference to a preferred danceability range:
         - chill: preferred range 20-50
         - balanced: preferred range 40-70
         - intense: preferred range 60-100
       - If danceability falls within preferred range: +4
       - If danceability is within 15 points of range boundary: +2
       - If danceability is outside range: +0
       - If danceability is null: +2 (neutral)
       - If tasteProfile is null: +2 (neutral)
       - **Segment override** (QUAL-05): When segmentLabel is provided, override the global energy preference:
         - "Warm-up" -> treat as chill regardless of user preference
         - "Cool-down" -> treat as chill regardless of user preference
         - "Rest N" (any rest segment) -> treat as chill regardless of user preference
         - "Work N" (any work/sprint segment) -> treat as intense regardless of user preference
         - "Main", "Running", "Sprint", or null -> use user's actual preference

    5. **Exact BPM match: +3** (existing logic, preserved)
       - song.matchType == BpmMatchType.exact: +3

    6. **Tempo variant match: +1** (existing logic, preserved)
       - song.matchType != BpmMatchType.exact: +1

    7. **Artist diversity penalty: -5** (NEW -- QUAL-04)
       - If previousArtist is not null AND song.artistName matches previousArtist (case-insensitive): -5
       - This discourages consecutive songs by the same artist

    Max possible score: 10 + 6 + 8 + 4 + 3 = 31 (no diversity penalty)
    Min possible score: 0 + 0 + 0 + 0 + 1 - 5 = -4 (worst case with penalty)

    ## enforceArtistDiversity() method

    Signature:
    ```dart
    static List<T> enforceArtistDiversity<T>(
      List<T> rankedSongs,
      String Function(T) getArtist,
    )
    ```

    Post-processing step that reorders a ranked list so no two consecutive songs are by the same artist. Algorithm:
    - Walk through the list. When a consecutive duplicate artist is found, swap it with the next song that has a different artist.
    - If no swap candidate exists (all remaining songs are same artist), leave as-is.
    - Preserves relative ranking as much as possible.

    ## Test cases

    **Danceability scoring:**
    - danceability=90 -> score component = 7
    - danceability=50 -> score component = 4
    - danceability=10 -> score component = 1
    - danceability=null -> score component = 4 (neutral)
    - danceability=0 -> score component = 0
    - danceability=100 -> score component = 8

    **Energy alignment:**
    - energyLevel=chill, danceability=35 -> +4 (in range 20-50)
    - energyLevel=chill, danceability=80 -> +0 (far outside range)
    - energyLevel=intense, danceability=80 -> +4 (in range 60-100)
    - energyLevel=intense, danceability=30 -> +0 (far outside range)
    - energyLevel=balanced, danceability=55 -> +4 (in range 40-70)
    - danceability=null -> +2 (neutral regardless of energy level)
    - tasteProfile=null -> +2 (neutral)

    **Segment energy override:**
    - segmentLabel="Warm-up", energyLevel=intense, danceability=35 -> uses chill range -> +4
    - segmentLabel="Cool-down", energyLevel=intense, danceability=35 -> uses chill range -> +4
    - segmentLabel="Work 1", energyLevel=chill, danceability=80 -> uses intense range -> +4
    - segmentLabel="Rest 2", energyLevel=intense, danceability=35 -> uses chill range -> +4
    - segmentLabel="Main", energyLevel=intense, danceability=80 -> uses intense (no override) -> +4
    - segmentLabel=null -> uses user preference

    **Artist match:**
    - tasteProfile.artists=["Eminem"], song.artistName="Eminem" -> +10
    - tasteProfile.artists=["eminem"], song.artistName="EMINEM" -> +10
    - tasteProfile.artists=["Eminem"], song.artistName="Unknown" -> +0
    - tasteProfile=null -> +0

    **Genre match:**
    - songGenres=[RunningGenre.rock], tasteProfile.genres=[RunningGenre.rock] -> +6
    - songGenres=[RunningGenre.rock], tasteProfile.genres=[RunningGenre.pop] -> +0
    - songGenres=null -> +0
    - tasteProfile.genres=[] -> +0

    **BPM match:**
    - matchType=exact -> +3
    - matchType=halfTime -> +1
    - matchType=doubleTime -> +1

    **Artist diversity penalty:**
    - previousArtist="Eminem", song.artistName="Eminem" -> -5
    - previousArtist="eminem", song.artistName="EMINEM" -> -5
    - previousArtist="Eminem", song.artistName="Drake" -> 0
    - previousArtist=null -> 0

    **Composite scoring:**
    - Artist match(10) + high danceability(7) + energy aligned(4) + exact BPM(3) + genre match(6) = 30
    - No match(0) + low danceability(1) + energy misaligned(0) + variant BPM(1) + no genre(0) = 2
    - Verify: same BPM, high danceability beats low danceability (QUAL-02 success criterion)
    - Verify: chill user scores differently than intense user on same song (QUAL-06 success criterion)

    **enforceArtistDiversity:**
    - [A, A, B, C] -> [A, B, A, C] (swap consecutive duplicate)
    - [A, B, C] -> [A, B, C] (no change needed)
    - [A, A, A] -> [A, A, A] (can't fix, leave as-is)
    - [A, A, B, B, C] -> [A, B, A, B, C] (multiple swaps)
    - Empty list -> empty list
  </behavior>
  <implementation>
    Create `lib/features/song_quality/domain/song_quality_scorer.dart`:

    1. Import BpmSong (for BpmMatchType), TasteProfile (for EnergyLevel, RunningGenre)
    2. Create SongQualityScorer class with static methods
    3. Implement score() with all 7 dimensions
    4. Implement _resolveEnergyLevel() private helper that handles segment label overrides
    5. Implement _energyRange() that maps EnergyLevel to (min, max) tuple
    6. Implement _energyAlignmentScore() that computes 0/2/4 based on range proximity
    7. Implement _danceabilityScore() that scales 0-100 to 0-8
    8. Implement _artistMatchScore() preserving exact existing logic from PlaylistGenerator
    9. Implement _genreMatchScore() with songGenres parameter
    10. Implement _bpmMatchScore() preserving exact existing logic
    11. Implement _artistDiversityPenalty() for consecutive artist check
    12. Implement enforceArtistDiversity() generic reordering
    13. All weight constants are public static const for testability and future tuning

    NO Flutter dependencies. Pure Dart only. This file must be importable from test/ without flutter_test.
  </implementation>
</feature>

<verification>
1. `cd /Users/tijmen/running-playlist-ai && flutter test test/features/song_quality/domain/song_quality_scorer_test.dart` -- all tests pass
2. `flutter analyze lib/features/song_quality/` -- no lint errors
3. All test cases from the behavior section are covered
4. No Flutter imports in song_quality_scorer.dart (verify with grep)
</verification>

<success_criteria>
- SongQualityScorer.score() returns correct composite scores for all dimension combinations
- Danceability=90 song scores higher than danceability=10 song at same BPM (QUAL-02)
- chill user gets different scores than intense user on same song (QUAL-06)
- Warm-up segment overrides user energy to chill (QUAL-05)
- Work segment overrides user energy to intense (QUAL-05)
- Artist diversity penalty applied for consecutive same-artist songs (QUAL-04)
- enforceArtistDiversity() reorders list to avoid consecutive same-artist songs
- Null danceability, null tasteProfile, null segmentLabel all handled gracefully
- Zero Flutter dependencies in scorer
</success_criteria>

<output>
After completion, create `.planning/phases/16-scoring-foundation/16-01-SUMMARY.md`
</output>
