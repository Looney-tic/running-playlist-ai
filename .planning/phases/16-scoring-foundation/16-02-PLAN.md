---
phase: 16-scoring-foundation
plan: 02
type: execute
wave: 2
depends_on: ["16-01"]
files_modified:
  - lib/features/bpm_lookup/domain/bpm_song.dart
  - lib/features/playlist/domain/playlist_generator.dart
  - lib/features/playlist/domain/playlist.dart
  - lib/features/playlist/providers/playlist_providers.dart
  - test/features/playlist/domain/playlist_generator_test.dart
  - test/features/bpm_lookup/domain/bpm_song_test.dart
autonomous: true

must_haves:
  truths:
    - "Generated playlist songs are ranked by composite score -- not BPM alone"
    - "No two consecutive songs in a generated playlist are by the same artist"
    - "BpmSong model includes optional danceability field parsed from API"
    - "PlaylistGenerator delegates scoring to SongQualityScorer"
    - "All existing playlist generator tests continue to pass"
    - "Warm-up segments contain lower-energy scores and sprint segments higher-energy scores"
  artifacts:
    - path: "lib/features/playlist/domain/playlist_generator.dart"
      provides: "Enhanced generator using SongQualityScorer"
      contains: "SongQualityScorer"
    - path: "lib/features/bpm_lookup/domain/bpm_song.dart"
      provides: "BpmSong with optional danceability field"
      contains: "danceability"
    - path: "lib/features/playlist/domain/playlist.dart"
      provides: "PlaylistSong with optional runningQuality and isEnriched fields"
      contains: "runningQuality"
  key_links:
    - from: "playlist_generator.dart"
      to: "song_quality_scorer.dart"
      via: "import and call SongQualityScorer.score()"
      pattern: "SongQualityScorer\\.score"
    - from: "playlist_generator.dart"
      to: "song_quality_scorer.dart"
      via: "call enforceArtistDiversity()"
      pattern: "enforceArtistDiversity"
    - from: "playlist_providers.dart"
      to: "playlist_generator.dart"
      via: "passes tasteProfile and songsByBpm to generate()"
      pattern: "PlaylistGenerator\\.generate"
---

<objective>
Integrate SongQualityScorer into the existing PlaylistGenerator and provider pipeline so generated playlists use composite quality scoring instead of simple artist+BPM ranking.

Purpose: This wires the scoring algorithm (Plan 01) into the actual playlist generation flow, making all QUAL requirements active at runtime. Also extends BpmSong and PlaylistSong models with quality data fields.

Output: Enhanced PlaylistGenerator that delegates to SongQualityScorer, BpmSong with danceability field, PlaylistSong with quality metadata, all existing tests passing.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-scoring-foundation/16-01-SUMMARY.md
@lib/features/playlist/domain/playlist_generator.dart
@lib/features/playlist/providers/playlist_providers.dart
@lib/features/bpm_lookup/domain/bpm_song.dart
@lib/features/playlist/domain/playlist.dart
@test/features/playlist/domain/playlist_generator_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend BpmSong and PlaylistSong models with quality fields</name>
  <files>
    lib/features/bpm_lookup/domain/bpm_song.dart
    lib/features/playlist/domain/playlist.dart
    test/features/bpm_lookup/domain/bpm_song_test.dart
  </files>
  <action>
    **BpmSong model changes** (`lib/features/bpm_lookup/domain/bpm_song.dart`):

    1. Add optional `danceability` field (type `int?`) to BpmSong constructor
    2. In `fromApiJson()`: parse `danceability` field -- `int.tryParse(json['danceability']?.toString() ?? '')` (the API may return it as string or int; handle both). This is a forward-compatible change -- the /tempo/ endpoint may or may not include it.
    3. In `fromJson()` (cache deserialization): parse `danceability` as `(json['danceability'] as num?)?.toInt()`
    4. In `toJson()`: add `if (danceability != null) 'danceability': danceability`
    5. In `withMatchType()`: copy danceability to the new instance

    **PlaylistSong model changes** (`lib/features/playlist/domain/playlist.dart`):

    1. Add optional `int? runningQuality` field (1-31 score range) to PlaylistSong constructor
    2. Add optional `bool isEnriched` field (default false) -- true if danceability data was available during scoring
    3. Add these fields to `fromJson()` and `toJson()` -- both nullable/optional for backward compatibility with existing saved playlists
    4. Existing PlaylistSong JSON without these fields will deserialize with null/false defaults

    **BpmSong tests** (create `test/features/bpm_lookup/domain/bpm_song_test.dart` if it doesn't exist, or update):

    1. Test that `fromApiJson` parses danceability when present (e.g., `{"danceability": "55"}`)
    2. Test that `fromApiJson` handles missing danceability (null)
    3. Test that `toJson()` / `fromJson()` roundtrip includes danceability
    4. Test that `withMatchType()` preserves danceability

    IMPORTANT: Do NOT change the BpmSong constructor's required parameters. `danceability` is optional with no default.
  </action>
  <verify>
    `flutter test test/features/bpm_lookup/` -- all tests pass
    `flutter analyze lib/features/bpm_lookup/domain/bpm_song.dart lib/features/playlist/domain/playlist.dart` -- no errors
  </verify>
  <done>
    BpmSong has optional danceability field that parses from API JSON and roundtrips through cache serialization. PlaylistSong has optional runningQuality and isEnriched fields. All backward compatible.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SongQualityScorer into PlaylistGenerator</name>
  <files>
    lib/features/playlist/domain/playlist_generator.dart
    test/features/playlist/domain/playlist_generator_test.dart
  </files>
  <action>
    **PlaylistGenerator changes** (`lib/features/playlist/domain/playlist_generator.dart`):

    1. Add import for SongQualityScorer: `import 'package:running_playlist_ai/features/song_quality/domain/song_quality_scorer.dart';`

    2. **Modify `_scoreAndRank()` method** to delegate to SongQualityScorer:
       - Keep the same method signature
       - Add `String? segmentLabel` parameter to `_scoreAndRank()`
       - Replace the inline scoring logic with a call to `SongQualityScorer.score()` for each candidate
       - Track the previous song's artist to pass as `previousArtist` parameter (for first song, previousArtist is null)
       - Pass `song.danceability` as the danceability parameter
       - Pass `segmentLabel` for segment-aware energy
       - The shuffle-then-stable-sort pattern MUST be preserved exactly as-is
       - Remove the private score constants (_artistMatchScore, _exactMatchScore, _tempoVariantScore) since scoring is now in SongQualityScorer

    3. **Modify `generate()` method**:
       - Pass `segmentLabel` to `_scoreAndRank()` calls
       - After scoring and selecting songs for a segment, call `SongQualityScorer.enforceArtistDiversity()` on the selected songs to ensure no consecutive same-artist
       - When building PlaylistSong objects, set `runningQuality` to the computed score and `isEnriched` to `song.danceability != null`

    4. **Update PlaylistSong construction** in the generate() method:
       - Add `runningQuality: entry.score` to each PlaylistSong
       - Add `isEnriched: entry.song.danceability != null`

    **Test updates** (`test/features/playlist/domain/playlist_generator_test.dart`):

    1. ALL existing tests MUST continue to pass without modification. The scoring change is backward compatible because:
       - Artist match is preserved at +10
       - Exact BPM is preserved at +3
       - Tempo variant is preserved at +1
       - New scoring dimensions (danceability, energy, genre) add neutral scores when data is absent
    2. Add NEW test: "ranks high-danceability songs above low-danceability songs"
       - Create two songs at same BPM, one with danceability=90 and one with danceability=10
       - Verify the high-danceability song appears first in the generated playlist
    3. Add NEW test: "no consecutive same-artist songs in generated playlist"
       - Create a song pool where one artist has many songs
       - Generate a multi-song playlist
       - Verify no two consecutive songs have the same artistName
    4. Add NEW test: "warm-up segment prefers lower-danceability songs"
       - Create a warm-up segment and main segment with same BPM pool
       - Songs have varying danceability (some high, some low)
       - Verify warm-up segment's first song has lower danceability than main segment's first song
       - Use a TasteProfile with energyLevel=intense to show that warm-up overrides to chill

    IMPORTANT: The _ScoredSong class must now store the score from SongQualityScorer. It is already structured this way, just needs to receive the new score values.
  </action>
  <verify>
    `flutter test test/features/playlist/domain/playlist_generator_test.dart` -- ALL tests pass (existing + new)
    `flutter test test/features/song_quality/` -- scorer tests still pass
    `flutter analyze lib/features/playlist/` -- no errors
  </verify>
  <done>
    PlaylistGenerator delegates all scoring to SongQualityScorer. Generated playlists rank songs by composite quality (danceability + energy + artist + BPM + diversity penalty). No consecutive same-artist songs. Warm-up segments prefer lower-energy songs. All existing tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire scoring through PlaylistGenerationNotifier provider</name>
  <files>
    lib/features/playlist/providers/playlist_providers.dart
  </files>
  <action>
    **PlaylistGenerationNotifier changes** (`lib/features/playlist/providers/playlist_providers.dart`):

    The PlaylistGenerator.generate() signature is NOT changing (no new required parameters). The scorer is invoked INSIDE PlaylistGenerator, not passed in from outside. So the provider layer needs MINIMAL changes:

    1. The existing call `PlaylistGenerator.generate(runPlan: runPlan, tasteProfile: tasteProfile, songsByBpm: songsByBpm)` remains the same. No changes needed to the provider for scoring.

    2. **However**, verify that tasteProfile is being passed correctly (it already is -- line 95 of current file).

    3. No new providers needed for Phase 16. The RunningQualityIndex provider (for curated data) is Phase 17 work. Phase 16 scoring works with data already available on BpmSong (danceability from API) and TasteProfile (energy level, genres, artists).

    This task is intentionally minimal. The scoring integration happens entirely within PlaylistGenerator (Task 2). The provider layer just passes through the existing data.

    **Verify the full pipeline works:**
    - Run the existing playlist_providers_test.dart to confirm no regressions
    - The provider tests mock the API and generator, so they should pass without changes
  </action>
  <verify>
    `flutter test test/features/playlist/providers/playlist_providers_test.dart` -- passes
    `flutter test` -- full test suite passes (all 229+ tests)
    `flutter analyze` -- no errors across entire project
  </verify>
  <done>
    Full pipeline works: PlaylistGenerationNotifier -> PlaylistGenerator (with SongQualityScorer) -> scored Playlist. All tests pass. No regressions.
  </done>
</task>

</tasks>

<verification>
1. `flutter test` -- entire test suite passes (229+ existing tests + new scorer and generator tests)
2. `flutter analyze` -- zero errors, zero warnings
3. Manual check: in playlist_generator.dart, confirm `SongQualityScorer.score` is called (not inline scoring)
4. Manual check: in playlist_generator.dart, confirm `enforceArtistDiversity` is called on selected songs
5. Manual check: BpmSong.fromApiJson parses danceability field
6. Manual check: PlaylistSong.toJson/fromJson handles runningQuality field
</verification>

<success_criteria>
- Generated playlists use composite scoring (not just artist+BPM) -- verified by new tests showing danceability affects ranking
- No two consecutive songs by the same artist in any generated playlist -- verified by test
- Warm-up segments prefer lower-energy songs when danceability data is available -- verified by test
- All 229+ existing tests pass without modification (backward compatibility)
- BpmSong.danceability is parsed from API responses and survives cache roundtrip
- PlaylistSong carries runningQuality metadata for future UI display
</success_criteria>

<output>
After completion, create `.planning/phases/16-scoring-foundation/16-02-SUMMARY.md`
</output>
