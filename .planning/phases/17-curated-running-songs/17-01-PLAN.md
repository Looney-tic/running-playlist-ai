---
phase: 17-curated-running-songs
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/features/curated_songs/domain/curated_song.dart
  - test/features/curated_songs/domain/curated_song_test.dart
  - lib/features/song_quality/domain/song_quality_scorer.dart
  - test/features/song_quality/domain/song_quality_scorer_test.dart
  - lib/features/playlist/domain/playlist_generator.dart
  - test/features/playlist/domain/playlist_generator_test.dart
autonomous: true

must_haves:
  truths:
    - "CuratedSong model can deserialize from both bundled JSON (camelCase) and Supabase rows (snake_case)"
    - "CuratedSong.lookupKey produces a normalized 'artist|title' string for cross-source matching"
    - "SongQualityScorer.score() returns +5 higher for curated songs vs identical non-curated songs"
    - "PlaylistGenerator.generate() accepts an optional curatedLookupKeys set and passes curated status to scorer"
    - "Non-curated songs still receive valid scores (curated bonus is additive, not required)"
  artifacts:
    - path: "lib/features/curated_songs/domain/curated_song.dart"
      provides: "CuratedSong model with fromJson, fromSupabaseRow, lookupKey, toJson"
      contains: "class CuratedSong"
    - path: "test/features/curated_songs/domain/curated_song_test.dart"
      provides: "Unit tests for CuratedSong model"
      contains: "CuratedSong"
    - path: "lib/features/song_quality/domain/song_quality_scorer.dart"
      provides: "curatedBonusWeight constant and isCurated parameter on score()"
      contains: "curatedBonusWeight"
    - path: "test/features/song_quality/domain/song_quality_scorer_test.dart"
      provides: "Tests for curated bonus scoring dimension"
      contains: "curated"
    - path: "lib/features/playlist/domain/playlist_generator.dart"
      provides: "curatedLookupKeys optional parameter on generate()"
      contains: "curatedLookupKeys"
    - path: "test/features/playlist/domain/playlist_generator_test.dart"
      provides: "Test verifying curated songs rank higher than equivalent non-curated"
      contains: "curated"
  key_links:
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/song_quality/domain/song_quality_scorer.dart"
      via: "isCurated parameter passed to SongQualityScorer.score()"
      pattern: "isCurated"
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/curated_songs/domain/curated_song.dart"
      via: "Uses CuratedSong.lookupKey format for Set<String> matching"
      pattern: "curatedLookupKeys"
---

<objective>
Create the CuratedSong domain model, add a curated bonus dimension to SongQualityScorer, and wire the curated lookup into PlaylistGenerator -- all with TDD.

Purpose: Establishes the pure Dart domain layer for curated songs (CURA-01 model, CURA-02 scoring boost, CURA-04 expansible structure) so that the data layer (Plan 02) can populate and wire it.
Output: CuratedSong model, curatedBonusWeight in scorer, curatedLookupKeys in generator, with full test coverage.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-curated-running-songs/17-RESEARCH.md
@lib/features/song_quality/domain/song_quality_scorer.dart
@test/features/song_quality/domain/song_quality_scorer_test.dart
@lib/features/playlist/domain/playlist_generator.dart
@test/features/playlist/domain/playlist_generator_test.dart
@lib/features/bpm_lookup/domain/bpm_song.dart
@lib/features/taste_profile/domain/taste_profile.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: TDD CuratedSong model</name>
  <files>
    lib/features/curated_songs/domain/curated_song.dart
    test/features/curated_songs/domain/curated_song_test.dart
  </files>
  <action>
RED: Write tests first in test/features/curated_songs/domain/curated_song_test.dart:

1. **fromJson** - deserializes camelCase JSON (bundled asset format):
   ```dart
   final json = {'title': 'Lose Yourself', 'artistName': 'Eminem', 'genre': 'hipHop', 'bpm': 171, 'danceability': 72, 'energyLevel': 'intense'};
   final song = CuratedSong.fromJson(json);
   expect(song.title, 'Lose Yourself');
   expect(song.bpm, 171);
   ```

2. **fromJson with null optionals** - danceability and energyLevel can be null:
   ```dart
   final json = {'title': 'Test', 'artistName': 'Artist', 'genre': 'pop', 'bpm': 140};
   final song = CuratedSong.fromJson(json);
   expect(song.danceability, isNull);
   expect(song.energyLevel, isNull);
   ```

3. **fromSupabaseRow** - deserializes snake_case (Supabase format):
   ```dart
   final row = {'title': 'Lose Yourself', 'artist_name': 'Eminem', 'genre': 'hipHop', 'bpm': 171, 'danceability': 72, 'energy_level': 'intense'};
   final song = CuratedSong.fromSupabaseRow(row);
   expect(song.artistName, 'Eminem');
   expect(song.energyLevel, 'intense');
   ```

4. **lookupKey** - normalized lowercase trimmed "artist|title":
   ```dart
   final song = CuratedSong(title: '  Lose Yourself ', artistName: ' Eminem ', genre: 'hipHop', bpm: 171);
   expect(song.lookupKey, 'eminem|lose yourself');
   ```

5. **toJson** - roundtrip (fromJson(toJson) produces identical object):
   ```dart
   final original = CuratedSong(...);
   final roundtripped = CuratedSong.fromJson(original.toJson());
   expect(roundtripped.lookupKey, original.lookupKey);
   expect(roundtripped.bpm, original.bpm);
   ```

GREEN: Create lib/features/curated_songs/domain/curated_song.dart following the exact model from RESEARCH.md:
- Pure Dart class (no Flutter imports)
- Required fields: title, artistName, genre (String), bpm (int)
- Optional fields: danceability (int?), energyLevel (String?)
- Factory: fromJson (camelCase), fromSupabaseRow (snake_case), const constructor
- Getter: lookupKey -> '${artistName.toLowerCase().trim()}|${title.toLowerCase().trim()}'
- Method: toJson() -> camelCase map

All tests must pass. Run `dart test test/features/curated_songs/domain/curated_song_test.dart`.
  </action>
  <verify>dart test test/features/curated_songs/domain/curated_song_test.dart -- all 5+ tests pass</verify>
  <done>CuratedSong model deserializes from both JSON formats, produces normalized lookup keys, and roundtrips through toJson</done>
</task>

<task type="auto">
  <name>Task 2: TDD curated bonus in SongQualityScorer</name>
  <files>
    lib/features/song_quality/domain/song_quality_scorer.dart
    test/features/song_quality/domain/song_quality_scorer_test.dart
  </files>
  <action>
RED: Add tests to existing test/features/song_quality/domain/song_quality_scorer_test.dart:

1. **curated bonus adds +5 to score**:
   ```dart
   final base = SongQualityScorer.score(song: song, isCurated: false);
   final curated = SongQualityScorer.score(song: song, isCurated: true);
   expect(curated - base, 5);
   ```

2. **non-curated songs get zero curated bonus** (default behavior unchanged):
   ```dart
   // Existing score call without isCurated should produce same result as isCurated: false
   final defaultScore = SongQualityScorer.score(song: song);
   final explicitFalse = SongQualityScorer.score(song: song, isCurated: false);
   expect(defaultScore, explicitFalse);
   ```

3. **curated bonus is additive, not multiplicative** (total score = base + 5):
   ```dart
   // Song with known base score (e.g., exact BPM = +3) + curated = +3 + 5 = 8
   final curated = SongQualityScorer.score(song: exactBpmSong, isCurated: true);
   expect(curated, greaterThanOrEqualTo(8)); // 3 (bpm) + 5 (curated) at minimum
   ```

GREEN: Modify lib/features/song_quality/domain/song_quality_scorer.dart:

1. Add public constant: `static const curatedBonusWeight = 5;`
2. Add `bool isCurated = false` optional parameter to `score()` method
3. Add `total += _curatedBonus(isCurated);` line in score() body (after existing dimensions)
4. Add private helper: `static int _curatedBonus(bool isCurated) => isCurated ? curatedBonusWeight : 0;`

This is ADDITIVE to existing scoring. No existing behavior changes. The default `isCurated: false` preserves all existing callers.

Run `dart test test/features/song_quality/domain/song_quality_scorer_test.dart` -- all existing + new tests pass.
  </action>
  <verify>dart test test/features/song_quality/domain/song_quality_scorer_test.dart -- all tests pass (existing + 3 new curated tests)</verify>
  <done>SongQualityScorer has curatedBonusWeight=5, score() accepts isCurated parameter, curated songs score +5 higher than equivalent non-curated songs, all existing tests still pass</done>
</task>

<task type="auto">
  <name>Task 3: Wire curated lookup into PlaylistGenerator</name>
  <files>
    lib/features/playlist/domain/playlist_generator.dart
    test/features/playlist/domain/playlist_generator_test.dart
  </files>
  <action>
RED: Add test to existing test/features/playlist/domain/playlist_generator_test.dart:

1. **curated songs rank higher than equivalent non-curated songs**:
   - Create two BpmSong objects: one that will match the curated set, one that will not
   - Both at same BPM, same artist quality (no artist match), same everything
   - Pass curatedLookupKeys containing only one song's normalized key
   - Generate playlist and verify the curated song appears before the non-curated one
   - Use fixed Random for deterministic results

2. **empty curatedLookupKeys produces same results as no curatedLookupKeys**:
   - Generate with `curatedLookupKeys: {}` and `curatedLookupKeys: null`
   - Results should be identical (regression safety)

GREEN: Modify lib/features/playlist/domain/playlist_generator.dart:

1. Add optional parameter to `generate()`: `Set<String>? curatedLookupKeys`
2. Pass `curatedLookupKeys` to `_scoreAndRank()` as a new parameter
3. In `_scoreAndRank()`, add `Set<String>? curatedLookupKeys` parameter
4. Before scoring each candidate, compute: `final isCurated = curatedLookupKeys != null && curatedLookupKeys.contains('${song.artistName.toLowerCase().trim()}|${song.title.toLowerCase().trim()}');`
5. Pass `isCurated: isCurated` to `SongQualityScorer.score()`

The lookup key format matches CuratedSong.lookupKey: `'${artist.toLowerCase().trim()}|${title.toLowerCase().trim()}'`.

No changes to the BpmSong model. The generator only receives a Set<String> of pre-computed lookup keys -- it does not import CuratedSong.

Run full test suite: `flutter test` -- all tests pass.
  </action>
  <verify>flutter test -- all tests pass (existing + new curated ranking tests)</verify>
  <done>PlaylistGenerator.generate() accepts curatedLookupKeys, curated songs rank higher than equivalent non-curated songs, non-curated songs still appear (boost not filter), all existing tests pass unchanged</done>
</task>

</tasks>

<verification>
1. `dart test test/features/curated_songs/` -- CuratedSong model tests pass
2. `dart test test/features/song_quality/` -- scorer tests pass (existing + curated bonus)
3. `dart test test/features/playlist/` -- generator tests pass (existing + curated ranking)
4. `flutter test` -- full suite passes with zero regressions
5. `flutter analyze` -- zero issues
</verification>

<success_criteria>
- CuratedSong model exists with fromJson, fromSupabaseRow, lookupKey, toJson
- SongQualityScorer has curatedBonusWeight=5, score() accepts isCurated
- PlaylistGenerator.generate() accepts curatedLookupKeys Set<String>
- Curated songs score 5 points higher than equivalent non-curated songs
- All existing tests pass unchanged (backward compatible)
- New test coverage for all three additions
</success_criteria>

<output>
After completion, create `.planning/phases/17-curated-running-songs/17-01-SUMMARY.md`
</output>
