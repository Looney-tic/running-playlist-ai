---
phase: 17-curated-running-songs
plan: 02
type: execute
wave: 2
depends_on: ["17-01"]
files_modified:
  - assets/curated_songs.json
  - pubspec.yaml
  - lib/features/curated_songs/data/curated_song_repository.dart
  - lib/features/curated_songs/providers/curated_song_providers.dart
  - lib/features/playlist/providers/playlist_providers.dart
autonomous: true

user_setup:
  - service: supabase
    why: "Remote curated song updates without app store release (CURA-03)"
    env_vars: []
    dashboard_config:
      - task: "Create curated_songs table with columns: id (UUID), title (TEXT), artist_name (TEXT), genre (TEXT), bpm (INT), danceability (INT nullable), energy_level (TEXT nullable), created_at (TIMESTAMPTZ)"
        location: "Supabase Dashboard -> SQL Editor"
      - task: "Create curated_songs_version table with columns: id (INT default 1), version (INT default 1), updated_at (TIMESTAMPTZ)"
        location: "Supabase Dashboard -> SQL Editor"
      - task: "Enable RLS on curated_songs and curated_songs_version with SELECT-only policy for anon role"
        location: "Supabase Dashboard -> Authentication -> Policies"

must_haves:
  truths:
    - "App ships with 200+ curated running songs as a bundled JSON asset"
    - "Curated dataset covers all 15 RunningGenre values with at least 10 songs each"
    - "CuratedSongRepository loads from bundled asset on first launch (no network required)"
    - "CuratedSongRepository refreshes from Supabase when cache is expired (24h TTL)"
    - "CuratedSongRepository falls back to bundled asset when Supabase is unavailable"
    - "Generated playlists use curated lookup keys during scoring (provider passes data through)"
    - "Curated songs appear higher in rankings than equivalent non-curated songs in generated playlists"
  artifacts:
    - path: "assets/curated_songs.json"
      provides: "Bundled curated song dataset with 200+ songs across all 15 genres"
      contains: "artistName"
    - path: "pubspec.yaml"
      provides: "Asset declaration for curated_songs.json"
      contains: "curated_songs.json"
    - path: "lib/features/curated_songs/data/curated_song_repository.dart"
      provides: "CuratedSongRepository with bundled-first + Supabase refresh + cache"
      contains: "class CuratedSongRepository"
    - path: "lib/features/curated_songs/providers/curated_song_providers.dart"
      provides: "Riverpod provider for curated song data"
      contains: "curatedSong"
    - path: "lib/features/playlist/providers/playlist_providers.dart"
      provides: "Updated PlaylistGenerationNotifier that loads curated data before generation"
      contains: "curatedLookupKeys"
  key_links:
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/curated_songs/providers/curated_song_providers.dart"
      via: "Reads curated songs, builds lookup set, passes to PlaylistGenerator.generate()"
      pattern: "curatedLookupKeys"
    - from: "lib/features/curated_songs/data/curated_song_repository.dart"
      to: "assets/curated_songs.json"
      via: "rootBundle.loadString for bundled asset fallback"
      pattern: "rootBundle.*curated_songs"
    - from: "lib/features/curated_songs/data/curated_song_repository.dart"
      to: "supabase_flutter"
      via: "Supabase.instance.client.from('curated_songs').select()"
      pattern: "from.*curated_songs.*select"
---

<objective>
Create the curated song dataset, data repository, and wire everything into the playlist generation flow so curated songs boost ranking in generated playlists.

Purpose: Completes all CURA requirements -- bundled dataset (CURA-01), scoring integration via provider wiring (CURA-02), Supabase remote refresh (CURA-03), and expansible data structure (CURA-04).
Output: assets/curated_songs.json with 200+ songs, CuratedSongRepository with three-tier loading, Riverpod provider, and PlaylistGenerationNotifier wiring.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-curated-running-songs/17-RESEARCH.md
@.planning/phases/17-curated-running-songs/17-01-SUMMARY.md
@lib/features/curated_songs/domain/curated_song.dart
@lib/features/bpm_lookup/data/bpm_cache_preferences.dart
@lib/features/playlist/providers/playlist_providers.dart
@lib/features/taste_profile/domain/taste_profile.dart
@pubspec.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create curated song dataset and asset declaration</name>
  <files>
    assets/curated_songs.json
    pubspec.yaml
  </files>
  <action>
Create `assets/curated_songs.json` with 200-300 curated running songs. Each song is a JSON object with camelCase keys matching CuratedSong.fromJson:

```json
[
  {"title": "Lose Yourself", "artistName": "Eminem", "genre": "hipHop", "bpm": 171, "danceability": 72, "energyLevel": "intense"},
  ...
]
```

**Genre distribution requirements** -- at least 13 songs per genre (200 / 15 = ~13), covering all 15 RunningGenre enum values:
- `pop`, `hipHop`, `electronic`, `edm`, `rock`, `indie`, `dance`, `house`, `drumAndBass`, `rnb`, `latin`, `metal`, `punk`, `funk`, `kPop`

**Genre field values must use RunningGenre enum names exactly** (camelCase, e.g., `hipHop` not `hip-hop`).

**BPM range:** 120-200 (running cadence range). Include a spread across this range per genre.

**Song selection criteria:** Use well-known, real songs that are genuinely good for running. Sources to draw from:
- Classic running anthems (Eye of the Tiger, Stronger, Till I Collapse, etc.)
- High-energy popular songs with clear driving beats
- Genre-appropriate songs with BPMs in the running cadence range

**danceability:** 0-100 integer (can be null for some songs). Higher for dance/EDM/pop, moderate for rock/metal.
**energyLevel:** One of "chill", "balanced", "intense" (can be null). Match the song's actual energy.

After creating the JSON file, add the asset to pubspec.yaml:
```yaml
flutter:
  uses-material-design: true
  assets:
    - .env
    - assets/curated_songs.json
```

Validate the JSON is well-formed by running: `dart run -e "import 'dart:convert'; import 'dart:io'; final f = File('assets/curated_songs.json'); final list = jsonDecode(f.readAsStringSync()) as List; print('Songs: \${list.length}'); final genres = list.map((s) => s['genre']).toSet(); print('Genres: \${genres.length} - \$genres');"`

Verify all 15 genres are present and each has at least 10 songs.
  </action>
  <verify>
1. JSON parses without error
2. 200+ songs total
3. All 15 RunningGenre enum values represented
4. Each genre has at least 10 songs
5. All BPMs are in 80-200 range
6. pubspec.yaml declares the asset
  </verify>
  <done>Bundled curated_songs.json exists with 200+ real running songs across all 15 genres, declared in pubspec.yaml assets</done>
</task>

<task type="auto">
  <name>Task 2: Create CuratedSongRepository with three-tier loading</name>
  <files>
    lib/features/curated_songs/data/curated_song_repository.dart
    lib/features/curated_songs/providers/curated_song_providers.dart
  </files>
  <action>
Create `lib/features/curated_songs/data/curated_song_repository.dart`:

**CuratedSongRepository** with static methods (matches BpmCachePreferences pattern):

1. **Main entry point: `loadCuratedSongs()`**
   ```
   Flow:
   1. Try SharedPreferences cache (check TTL)
   2. If cache valid -> return cached songs
   3. If cache expired/empty -> try Supabase fetch
   4. If Supabase succeeds -> save to cache, return fresh data
   5. If Supabase fails -> load bundled JSON asset as fallback
   ```

2. **Cache layer** (following BpmCachePreferences pattern):
   - Key: `curated_songs_cache`
   - TTL: 24 hours (`static const cacheTtl = Duration(hours: 24)`)
   - Format: `{"cachedAt": "ISO8601", "songs": [...]}`
   - Load: parse cachedAt, check TTL, deserialize songs via CuratedSong.fromJson
   - Save: serialize songs via toJson, add cachedAt timestamp

3. **Supabase fetch**:
   ```dart
   static Future<List<CuratedSong>?> _fetchFromSupabase() async {
     try {
       final response = await Supabase.instance.client
           .from('curated_songs')
           .select();
       return (response as List<dynamic>)
           .map((row) => CuratedSong.fromSupabaseRow(row as Map<String, dynamic>))
           .toList();
     } catch (_) {
       return null; // Graceful degradation
     }
   }
   ```
   - Wrap in try/catch -- ANY failure returns null (graceful degradation)
   - No authentication needed (RLS anon SELECT policy)

4. **Bundled asset fallback**:
   ```dart
   static Future<List<CuratedSong>> _loadBundledAsset() async {
     final jsonString = await rootBundle.loadString('assets/curated_songs.json');
     final jsonList = jsonDecode(jsonString) as List<dynamic>;
     return jsonList
         .map((item) => CuratedSong.fromJson(item as Map<String, dynamic>))
         .toList();
   }
   ```

5. **Lookup set builder** (convenience method):
   ```dart
   static Set<String> buildLookupSet(List<CuratedSong> songs) {
     return songs.map((s) => s.lookupKey).toSet();
   }
   ```

Create `lib/features/curated_songs/providers/curated_song_providers.dart`:

Simple Riverpod provider that exposes the curated song lookup set:

```dart
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:running_playlist_ai/features/curated_songs/data/curated_song_repository.dart';

/// Provides the curated song lookup set for playlist generation.
///
/// Loads curated songs on first access (cache-first, Supabase refresh,
/// bundled fallback). Returns a Set<String> of normalized lookup keys
/// for O(1) membership checks during scoring.
final curatedLookupKeysProvider = FutureProvider<Set<String>>((ref) async {
  final songs = await CuratedSongRepository.loadCuratedSongs();
  return CuratedSongRepository.buildLookupSet(songs);
});
```

This is a FutureProvider because loading is async (SharedPreferences + potential network). It auto-caches in Riverpod's state -- subsequent reads within the same app session return instantly.
  </action>
  <verify>
1. `flutter analyze` -- zero issues on new files
2. Repository has three-tier loading (cache -> Supabase -> bundled)
3. Provider returns Set<String> of lookup keys
4. Cache uses 24h TTL with SharedPreferences
5. Supabase failure gracefully falls back to bundled asset
  </verify>
  <done>CuratedSongRepository loads curated songs with cache-first + Supabase refresh + bundled fallback; Riverpod provider exposes lookup key set for playlist generation</done>
</task>

<task type="auto">
  <name>Task 3: Wire curated data into playlist generation provider</name>
  <files>
    lib/features/playlist/providers/playlist_providers.dart
  </files>
  <action>
Modify `lib/features/playlist/providers/playlist_providers.dart` to load curated lookup keys before calling PlaylistGenerator.generate():

1. Add import for curated song providers:
   ```dart
   import 'package:running_playlist_ai/features/curated_songs/providers/curated_song_providers.dart';
   ```

2. In `PlaylistGenerationNotifier.generatePlaylist()`, after fetching songsByBpm and before calling `PlaylistGenerator.generate()`, load curated lookup keys:
   ```dart
   // Load curated song lookup keys for scoring bonus
   Set<String> curatedLookupKeys = {};
   try {
     curatedLookupKeys = await ref.read(curatedLookupKeysProvider.future);
   } catch (_) {
     // Graceful degradation: if curated data unavailable, generate without it
   }
   ```

3. Pass curatedLookupKeys to PlaylistGenerator.generate():
   ```dart
   final playlist = PlaylistGenerator.generate(
     runPlan: runPlan,
     tasteProfile: tasteProfile,
     songsByBpm: songsByBpm,
     curatedLookupKeys: curatedLookupKeys.isNotEmpty ? curatedLookupKeys : null,
   );
   ```

**Important:** The curated data loading is wrapped in try/catch for graceful degradation. If curated data fails to load for any reason (first launch before assets are warm, Supabase down, etc.), playlist generation proceeds without curated bonus. This ensures curated data is a BOOST, never a blocker.

The curatedLookupKeysProvider is a FutureProvider, so subsequent calls within the same session return the cached result instantly (no repeated loading).

Run full test suite: `flutter test` -- all tests pass. The provider test already mocks dependencies and should not be affected since curatedLookupKeys defaults to null in the generator.
  </action>
  <verify>
1. `flutter test` -- all tests pass (existing provider tests unaffected)
2. `flutter analyze` -- zero issues
3. PlaylistGenerationNotifier loads curated keys before generation
4. Curated loading failure does not break playlist generation
  </verify>
  <done>PlaylistGenerationNotifier loads curated lookup keys from provider and passes them to PlaylistGenerator.generate(); curated songs receive +5 scoring bonus in generated playlists; failure to load curated data degrades gracefully to no bonus</done>
</task>

</tasks>

<verification>
1. `flutter test` -- full suite passes with zero regressions
2. `flutter analyze` -- zero issues
3. `assets/curated_songs.json` exists with 200+ songs across all 15 genres
4. `pubspec.yaml` declares `assets/curated_songs.json`
5. CuratedSongRepository has cache-first + Supabase + bundled fallback
6. PlaylistGenerationNotifier passes curated lookup keys to generator
7. Manual verification: the data flow is complete from bundled JSON -> repository -> provider -> generator -> scorer
</verification>

<success_criteria>
- Bundled JSON asset with 200+ curated songs covering all 15 RunningGenre values
- CuratedSongRepository with three-tier loading (cache -> Supabase -> bundled)
- Provider wiring loads curated data and passes to generator during playlist generation
- Curated songs receive +5 scoring bonus (from Plan 01 scorer integration)
- Non-curated songs still appear (curated is boost, not filter)
- Supabase refresh works when table exists; graceful degradation when it does not
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/17-curated-running-songs/17-02-SUMMARY.md`
</output>
