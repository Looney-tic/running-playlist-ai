---
phase: 19-regeneration-reliability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/run_plan/providers/run_plan_providers.dart
  - lib/features/taste_profile/providers/taste_profile_providers.dart
  - lib/features/playlist/providers/playlist_providers.dart
autonomous: true

must_haves:
  truths:
    - "shufflePlaylist() reuses state.songPool with a new Random seed -- no API call, no loading spinner"
    - "generatePlaylist() awaits library readiness before reading provider state -- no null on cold start"
    - "generatePlaylist() reads current selections from providers, not stale stored values"
  artifacts:
    - path: "lib/features/run_plan/providers/run_plan_providers.dart"
      provides: "ensureLoaded() readiness guard on RunPlanLibraryNotifier"
      contains: "ensureLoaded"
    - path: "lib/features/taste_profile/providers/taste_profile_providers.dart"
      provides: "ensureLoaded() readiness guard on TasteProfileLibraryNotifier"
      contains: "ensureLoaded"
    - path: "lib/features/playlist/providers/playlist_providers.dart"
      provides: "shufflePlaylist() method reusing songPool, generatePlaylist() with readiness awaits"
      contains: "shufflePlaylist"
  key_links:
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "RunPlanLibraryNotifier.ensureLoaded()"
      via: "await before ref.read() in generatePlaylist()"
      pattern: "ensureLoaded"
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "PlaylistGenerator.generate"
      via: "shufflePlaylist calls generate with state.songPool"
      pattern: "state\\.songPool"
---

<objective>
Add readiness guards and instant shuffle to the playlist provider layer.

Purpose: Fix the cold-start race condition (REGEN-02) where generatePlaylist() reads null from providers that haven't finished async loading, and add a shufflePlaylist() method (REGEN-01) that reuses the stored song pool with a new Random seed for instant regeneration without API calls. Also ensure generatePlaylist() always reads current provider selections (REGEN-03).

Output: Updated provider files with ensureLoaded() on library notifiers and shufflePlaylist()/fixed generatePlaylist() on PlaylistGenerationNotifier.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/features/playlist/providers/playlist_providers.dart
@lib/features/run_plan/providers/run_plan_providers.dart
@lib/features/taste_profile/providers/taste_profile_providers.dart
@lib/features/playlist/domain/playlist_generator.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ensureLoaded() readiness guards to library notifiers</name>
  <files>
    lib/features/run_plan/providers/run_plan_providers.dart
    lib/features/taste_profile/providers/taste_profile_providers.dart
  </files>
  <action>
Add a Completer-based `ensureLoaded()` method to both `RunPlanLibraryNotifier` and `TasteProfileLibraryNotifier`. The pattern:

1. Add `import 'dart:async';` at top of each file.
2. Add a private `Completer<void> _loadCompleter = Completer<void>();` field to each notifier class.
3. In the existing `_load()` method, after the state assignment at the end, add `_loadCompleter.complete();` (wrap in try/catch so it completes even on error -- use `if (!_loadCompleter.isCompleted) _loadCompleter.complete();` in a finally block).
4. Add a public method:
   ```dart
   /// Waits until the initial async load from preferences is complete.
   /// Safe to call multiple times -- returns immediately if already loaded.
   Future<void> ensureLoaded() => _loadCompleter.future;
   ```

This ensures any caller can await readiness without re-triggering the load. The Completer completes exactly once when `_load()` finishes (success or failure).

Important: Do NOT change the constructor signature or the fire-and-forget `_load()` call pattern. Only add the Completer field, complete it in `_load()`, and expose `ensureLoaded()`.
  </action>
  <verify>
Run `dart analyze lib/features/run_plan/providers/run_plan_providers.dart lib/features/taste_profile/providers/taste_profile_providers.dart` -- no errors.
Grep both files for `ensureLoaded` and `_loadCompleter` to confirm the pattern exists.
  </verify>
  <done>
Both RunPlanLibraryNotifier and TasteProfileLibraryNotifier expose ensureLoaded() that resolves when _load() completes. Completer is properly guarded with isCompleted check.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add shufflePlaylist() and fix generatePlaylist() readiness</name>
  <files>
    lib/features/playlist/providers/playlist_providers.dart
  </files>
  <action>
Two changes to PlaylistGenerationNotifier:

**A) Fix generatePlaylist() to await readiness before reading state:**

At the START of `generatePlaylist()`, before the `ref.read(runPlanNotifierProvider)` call, add:
```dart
// Ensure library notifiers have finished loading from preferences.
// Fixes cold-start race condition where ref.read() returns null
// because the constructor's fire-and-forget _load() hasn't completed.
await ref.read(runPlanLibraryProvider.notifier).ensureLoaded();
await ref.read(tasteProfileLibraryProvider.notifier).ensureLoaded();
```

This must come BEFORE `state = PlaylistGenerationState.loading()` so the loading indicator only shows after we know the providers are ready. Actually, set loading state first for UX, then await:
```dart
state = const PlaylistGenerationState.loading();
await ref.read(runPlanLibraryProvider.notifier).ensureLoaded();
await ref.read(tasteProfileLibraryProvider.notifier).ensureLoaded();
final runPlan = ref.read(runPlanNotifierProvider);
```
Move the loading state assignment to before the awaits, and move the runPlan/tasteProfile reads to after the awaits.

**B) Add shufflePlaylist() method:**

Add a new method to PlaylistGenerationNotifier:
```dart
/// Regenerates the playlist using the stored song pool with a new random seed.
///
/// This is instant -- no API call, no loading spinner. Reuses [state.songPool]
/// and reads the CURRENT run plan and taste profile from providers.
/// Falls back to [generatePlaylist] if no song pool exists.
void shufflePlaylist() {
  if (state.songPool.isEmpty || state.runPlan == null) {
    generatePlaylist();
    return;
  }

  final runPlan = ref.read(runPlanNotifierProvider) ?? state.runPlan!;
  final tasteProfile = ref.read(tasteProfileNotifierProvider) ?? state.tasteProfile;

  // Load curated runnability synchronously from cache if available
  // (it was already loaded during the original generation)
  var curatedRunnability = <String, int>{};
  try {
    final cached = ref.read(curatedRunnabilityProvider).valueOrNull;
    if (cached != null) curatedRunnability = cached;
  } catch (_) {
    // Graceful degradation
  }

  final playlist = PlaylistGenerator.generate(
    runPlan: runPlan,
    tasteProfile: tasteProfile,
    songsByBpm: state.songPool,
    curatedRunnability: curatedRunnability.isNotEmpty ? curatedRunnability : null,
  );

  state = PlaylistGenerationState.loaded(
    playlist,
    songPool: state.songPool,
    runPlan: runPlan,
    tasteProfile: tasteProfile,
  );

  // Auto-save shuffled playlist to history
  unawaited(
    ref.read(playlistHistoryProvider.notifier).addPlaylist(playlist),
  );
}
```

Key design points:
- `shufflePlaylist()` is SYNCHRONOUS (returns void, not Future) -- PlaylistGenerator.generate is already sync. No loading spinner needed.
- Uses `ref.read(runPlanNotifierProvider)` for current selection (falls back to stored if null).
- A new `Random()` instance is created implicitly by `PlaylistGenerator.generate()` (it uses `Random()` when no explicit random is passed), so each call produces different ordering via the shuffle step in `_scoreAndRank`.
- The `curatedRunnabilityProvider` is read synchronously from its cached value (it's a FutureProvider that should already be resolved from the original generation).

**C) Clean up regeneratePlaylist():**

The existing `regeneratePlaylist()` re-fetches songs from API. Keep it but rename conceptually: it serves as a "full regenerate" that fetches fresh songs. No code change needed -- the UI plan (19-02) will wire "Shuffle" to `shufflePlaylist()` and keep `regeneratePlaylist()` available for explicit "fetch new songs" if ever needed. However, for clarity, add a doc comment update:
```dart
/// Regenerates the playlist by re-fetching songs from the API.
///
/// This performs a full re-fetch, unlike [shufflePlaylist] which reuses
/// the stored song pool. Falls back to [generatePlaylist] if no prior
/// generation state exists.
```

Also add the readiness guards to regeneratePlaylist() the same way as generatePlaylist(), before reading state.
  </action>
  <verify>
Run `dart analyze lib/features/playlist/providers/playlist_providers.dart` -- no errors.
Grep for `shufflePlaylist` and `ensureLoaded` in the file to confirm both exist.
Run `flutter test` to check no regressions (expect pre-existing widget_test failure only).
  </verify>
  <done>
PlaylistGenerationNotifier has:
1. shufflePlaylist() that reuses state.songPool with new Random seed -- synchronous, instant, no API call.
2. generatePlaylist() awaits ensureLoaded() on both library notifiers before reading state -- no null crash on cold start.
3. generatePlaylist() reads current provider selections (already did, now confirmed safe with readiness guards).
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/playlist/providers/ lib/features/run_plan/providers/ lib/features/taste_profile/providers/` passes with no errors.
2. `flutter test` passes (excluding pre-existing widget_test failure).
3. Grep confirms: `shufflePlaylist` exists in playlist_providers.dart, `ensureLoaded` exists in both library notifier files.
</verification>

<success_criteria>
- shufflePlaylist() method exists and calls PlaylistGenerator.generate with state.songPool (no _fetchAllSongs call)
- ensureLoaded() method exists on both RunPlanLibraryNotifier and TasteProfileLibraryNotifier
- generatePlaylist() awaits ensureLoaded() before ref.read() calls
- No analyzer errors in modified files
</success_criteria>

<output>
After completion, create `.planning/phases/19-regeneration-reliability/19-01-SUMMARY.md`
</output>
