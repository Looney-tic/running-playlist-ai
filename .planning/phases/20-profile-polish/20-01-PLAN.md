---
phase: 20-profile-polish
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/features/taste_profile/domain/taste_profile.dart
  - lib/features/run_plan/domain/run_plan.dart
  - lib/features/bpm_lookup/domain/bpm_song.dart
  - lib/features/taste_profile/data/taste_profile_preferences.dart
  - test/features/taste_profile/domain/taste_profile_test.dart
  - test/features/run_plan/domain/run_plan_test.dart
  - test/features/bpm_lookup/domain/bpm_song_test.dart
autonomous: true

must_haves:
  truths:
    - "App loads without crash when stored taste profile JSON contains an unknown enum value (e.g. genre 'countryRock' from a newer app version)"
    - "Unknown genre values in a profile are silently dropped -- the rest of the profile loads correctly"
    - "Unknown RunType in a run plan falls back to 'steady' -- the plan is still usable"
    - "Unknown BpmMatchType falls back to 'exact' -- song data is still usable"
    - "Unknown EnergyLevel falls back to 'balanced' -- the profile is still usable"
    - "A single corrupt profile in the library does not prevent other profiles from loading"
  artifacts:
    - path: "lib/features/taste_profile/domain/taste_profile.dart"
      provides: "Safe enum deserializers with orElse fallbacks"
      contains: "orElse"
    - path: "lib/features/run_plan/domain/run_plan.dart"
      provides: "Safe RunType.fromJson with orElse"
      contains: "orElse"
    - path: "lib/features/bpm_lookup/domain/bpm_song.dart"
      provides: "Safe BpmMatchType.fromJson with orElse"
      contains: "orElse"
    - path: "test/features/taste_profile/domain/taste_profile_test.dart"
      provides: "Enum fallback and corrupt JSON tests"
      min_lines: 40
  key_links:
    - from: "TasteProfile.fromJson"
      to: "RunningGenre.fromJson"
      via: "filtered map with tryParse pattern"
      pattern: "whereType|where.*null"
    - from: "TasteProfilePreferences.loadAll"
      to: "TasteProfile.fromJson"
      via: "try-catch per profile"
      pattern: "try.*fromJson|catch"
---

<objective>
Harden all enum deserializers and JSON parsing to survive corrupt or future-version data without crashing.

Purpose: PROF-02 requires that unknown enum values degrade gracefully. Currently, `EnergyLevel.fromJson`, `RunningGenre.fromJson`, `BpmMatchType.fromJson`, and `RunType.fromJson` use `firstWhere` without `orElse`, which throws `StateError` on unknown values. A single corrupt profile also crashes the entire library load.

Output: Safe deserializers with orElse fallbacks, filtered list parsing for genres/decades, try-catch in preferences, and unit tests proving the safety.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/features/taste_profile/domain/taste_profile.dart
@lib/features/run_plan/domain/run_plan.dart
@lib/features/bpm_lookup/domain/bpm_song.dart
@lib/features/taste_profile/data/taste_profile_preferences.dart
</context>

<feature>
  <name>Safe enum deserialization with orElse fallbacks</name>
  <files>
    lib/features/taste_profile/domain/taste_profile.dart
    lib/features/run_plan/domain/run_plan.dart
    lib/features/bpm_lookup/domain/bpm_song.dart
    lib/features/taste_profile/data/taste_profile_preferences.dart
    test/features/taste_profile/domain/taste_profile_test.dart
    test/features/run_plan/domain/run_plan_test.dart
    test/features/bpm_lookup/domain/bpm_song_test.dart
  </files>
  <behavior>
    Enum deserialization safety:
    - EnergyLevel.fromJson('unknownValue') -> EnergyLevel.balanced
    - RunningGenre.fromJson('countryRock') -> null (caller must handle)
    - RunType.fromJson('unknownType') -> RunType.steady
    - BpmMatchType.fromJson('unknownMatch') -> BpmMatchType.exact

    Add a static `tryFromJson` to RunningGenre that returns null for unknown values.
    Keep existing `fromJson` with orElse for backward compat (returns first value as fallback).

    TasteProfile.fromJson genre list parsing:
    - Use RunningGenre.tryFromJson for each entry, filter out nulls
    - Input: ['pop', 'countryRock', 'rock'] -> Output: [RunningGenre.pop, RunningGenre.rock]

    TasteProfile.fromJson decade list parsing:
    - Same pattern: MusicDecade already has orElse, but add tryFromJson and filter for lists

    TasteProfilePreferences.loadAll resilience:
    - Wrap each TasteProfile.fromJson in try-catch
    - Skip corrupt profiles, load the rest
    - Same for RunPlanPreferences.loadAll (wrap RunPlan.fromJson in try-catch)

    Test cases:
    - EnergyLevel.fromJson('chill') == EnergyLevel.chill (happy path)
    - EnergyLevel.fromJson('superHigh') == EnergyLevel.balanced (fallback)
    - RunningGenre.tryFromJson('pop') == RunningGenre.pop (happy path)
    - RunningGenre.tryFromJson('countryRock') == null (unknown)
    - RunType.fromJson('steady') == RunType.steady (happy path)
    - RunType.fromJson('fartlek') == RunType.steady (fallback)
    - BpmMatchType.fromJson('exact') == BpmMatchType.exact (happy path)
    - BpmMatchType.fromJson('tripleTime') == BpmMatchType.exact (fallback)
    - TasteProfile.fromJson with unknown genre in list -> genre is filtered out
    - TasteProfile.fromJson with unknown energyLevel -> falls back to balanced
    - RunPlan.fromJson with unknown RunType -> falls back to steady
  </behavior>
  <implementation>
    RED: Write failing tests for all enum fallback cases and corrupt JSON parsing.

    GREEN:
    1. Add orElse to EnergyLevel.fromJson -> returns EnergyLevel.balanced
    2. Add orElse to RunningGenre.fromJson -> returns RunningGenre.pop (keep as non-crashing)
    3. Add static RunningGenre.tryFromJson that returns null for unknown values
    4. Add orElse to RunType.fromJson -> returns RunType.steady
    5. Add orElse to BpmMatchType.fromJson -> returns BpmMatchType.exact
    6. Update TasteProfile.fromJson genres list: use .map + tryFromJson + .whereType<RunningGenre>().toList()
    7. Update TasteProfile.fromJson decades list: same tryFromJson pattern for MusicDecade
    8. Add try-catch around each profile in TasteProfilePreferences.loadAll
    9. Add try-catch around each plan in RunPlanPreferences.loadAll (read run_plan_preferences.dart first)

    REFACTOR: Ensure consistent pattern across all enums. Add doc comments explaining fallback behavior.
  </implementation>
</feature>

<verification>
- `dart analyze lib/features/taste_profile/domain/taste_profile.dart` -- no errors
- `dart analyze lib/features/run_plan/domain/run_plan.dart` -- no errors
- `dart analyze lib/features/bpm_lookup/domain/bpm_song.dart` -- no errors
- `flutter test test/features/taste_profile/domain/taste_profile_test.dart` -- all pass
- `flutter test test/features/run_plan/domain/run_plan_test.dart` -- all pass
- `flutter test test/features/bpm_lookup/domain/bpm_song_test.dart` -- all pass
</verification>

<success_criteria>
All enum fromJson methods have orElse fallbacks. TasteProfile.fromJson filters unknown genres/decades. Preferences loading survives corrupt entries. All tests green.
</success_criteria>

<output>
After completion, create `.planning/phases/20-profile-polish/20-01-SUMMARY.md`
</output>
