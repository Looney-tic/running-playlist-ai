---
phase: 20-profile-polish
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - lib/features/taste_profile/presentation/taste_profile_library_screen.dart
  - lib/features/run_plan/presentation/run_plan_library_screen.dart
  - test/features/taste_profile/taste_profile_lifecycle_test.dart
autonomous: true

must_haves:
  truths:
    - "User sees a confirmation dialog before a taste profile is permanently deleted"
    - "User sees a confirmation dialog before a run plan is permanently deleted"
    - "Tapping 'Cancel' on the delete dialog does NOT delete the profile"
    - "Tapping 'Delete' on the delete dialog removes the profile"
    - "Multi-profile lifecycle works: create, edit, select, delete different, switch back"
  artifacts:
    - path: "lib/features/taste_profile/presentation/taste_profile_library_screen.dart"
      provides: "Delete confirmation dialog for taste profiles"
      contains: "AlertDialog"
    - path: "lib/features/run_plan/presentation/run_plan_library_screen.dart"
      provides: "Delete confirmation dialog for run plans"
      contains: "AlertDialog"
    - path: "test/features/taste_profile/taste_profile_lifecycle_test.dart"
      provides: "Multi-profile lifecycle unit tests"
      min_lines: 60
  key_links:
    - from: "_TasteProfileCard.onDelete"
      to: "showDialog"
      via: "confirmation before deleteProfile"
      pattern: "showDialog.*AlertDialog"
    - from: "_RunPlanCard.onDelete"
      to: "showDialog"
      via: "confirmation before deletePlan"
      pattern: "showDialog.*AlertDialog"
---

<objective>
Add delete confirmation dialogs to both library screens and verify the multi-profile lifecycle with tests.

Purpose: PROF-01 requires confirmation before destructive delete. PROF-03 requires verified create/edit/delete/switch lifecycle. Currently both library screens call delete immediately on tap -- a single accidental tap destroys data with no recovery.

Output: Confirmation dialogs on delete for both taste profiles and run plans, plus lifecycle tests for the TasteProfileLibraryNotifier.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-profile-polish/20-01-SUMMARY.md

@lib/features/taste_profile/presentation/taste_profile_library_screen.dart
@lib/features/run_plan/presentation/run_plan_library_screen.dart
@lib/features/taste_profile/providers/taste_profile_providers.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add delete confirmation dialogs to both library screens</name>
  <files>
    lib/features/taste_profile/presentation/taste_profile_library_screen.dart
    lib/features/run_plan/presentation/run_plan_library_screen.dart
  </files>
  <action>
    In TasteProfileLibraryScreen, change the `onDelete` callback for `_TasteProfileCard` to show a confirmation dialog BEFORE calling `deleteProfile`:

    ```dart
    onDelete: () async {
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text('Delete Profile'),
          content: Text(
            'Delete "${profile.name ?? 'this profile'}"? This cannot be undone.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(false),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(true),
              style: TextButton.styleFrom(
                foregroundColor: Theme.of(ctx).colorScheme.error,
              ),
              child: const Text('Delete'),
            ),
          ],
        ),
      );
      if (confirmed == true && context.mounted) {
        ref.read(tasteProfileLibraryProvider.notifier).deleteProfile(profile.id);
      }
    },
    ```

    Apply the same pattern in RunPlanLibraryScreen for the `onDelete` callback:
    - Title: 'Delete Run Plan'
    - Content: 'Delete "${plan.name ?? 'this run plan'}"? This cannot be undone.'
    - Same Cancel/Delete buttons with error color on Delete
    - Guard with `context.mounted` before calling `deletePlan`

    IMPORTANT: The `onDelete` type changes from `VoidCallback` to `VoidCallback` (the async closure is still void-returning since we don't await it in the card). The card widget signature stays the same -- it's the caller that wraps the dialog.
  </action>
  <verify>
    `dart analyze lib/features/taste_profile/presentation/taste_profile_library_screen.dart` -- no errors
    `dart analyze lib/features/run_plan/presentation/run_plan_library_screen.dart` -- no errors
  </verify>
  <done>
    Tapping delete on a taste profile or run plan shows a confirmation dialog. Cancel dismisses without deletion. Confirm deletes the item.
  </done>
</task>

<task type="auto">
  <name>Task 2: Multi-profile lifecycle unit tests</name>
  <files>
    test/features/taste_profile/taste_profile_lifecycle_test.dart
  </files>
  <action>
    Create a unit test file that tests the TasteProfileLibraryNotifier lifecycle WITHOUT SharedPreferences (mock-free, state-only testing).

    Since TasteProfileLibraryNotifier calls SharedPreferences in its constructor via `_load()`, create a **testable subclass** or test at the state level. The simplest approach: test the notifier's public methods by:

    1. Setting up SharedPreferences test values using `SharedPreferences.setMockInitialValues({})` (Flutter test utility)
    2. Creating a ProviderContainer with the real provider
    3. Awaiting `ensureLoaded()` to ensure initialization completes

    Test cases (each as a separate test):

    a) **Create profile**: Call `addProfile(profile1)`. Verify state has 1 profile and it's selected.

    b) **Create second profile**: After adding profile1, add profile2. Verify state has 2 profiles, profile2 is selected (addProfile selects it).

    c) **Edit profile**: After adding profile1, call `updateProfile(profile1.copyWith(name: 'Updated'))`. Verify the name changed in state.

    d) **Select profile**: After adding profile1 and profile2, call `selectProfile(profile1.id)`. Verify profile1 is now selected.

    e) **Delete non-selected profile**: With profile1 selected and profile2 also present, call `deleteProfile(profile2.id)`. Verify profile1 is still selected and profile2 is gone.

    f) **Delete selected profile falls back**: With profile2 selected, call `deleteProfile(profile2.id)`. Verify the first remaining profile becomes selected.

    g) **Full lifecycle**: Create profile1, create profile2, edit profile1 (change name), select profile1, delete profile2, verify profile1 is selected and has updated name. This is the PROF-03 end-to-end flow.

    h) **Persistence round-trip**: After full lifecycle, create a NEW notifier (fresh ProviderContainer), await `ensureLoaded()`, verify state matches what was saved. This proves persistence across "app restart".

    Use `flutter_test` package. Import `package:flutter/services.dart` for `SharedPreferences.setMockInitialValues`.
  </action>
  <verify>
    `flutter test test/features/taste_profile/taste_profile_lifecycle_test.dart` -- all tests pass
  </verify>
  <done>
    8 tests covering create, edit, select, delete, lifecycle, and persistence round-trip all pass. PROF-03 requirement verified.
  </done>
</task>

</tasks>

<verification>
- `dart analyze lib/` -- no new errors
- `flutter test test/features/taste_profile/taste_profile_lifecycle_test.dart` -- all pass
- Manual check: both library screens show AlertDialog before delete
</verification>

<success_criteria>
Delete confirmation dialogs prevent accidental data loss on both screens. Multi-profile lifecycle (create, edit, select, delete, switch, persist) is verified by passing tests.
</success_criteria>

<output>
After completion, create `.planning/phases/20-profile-polish/20-02-SUMMARY.md`
</output>
