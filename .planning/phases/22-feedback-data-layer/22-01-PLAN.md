---
phase: 22-feedback-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/song_feedback/domain/song_feedback.dart
  - lib/features/song_feedback/data/song_feedback_preferences.dart
  - lib/features/curated_songs/domain/curated_song.dart
  - lib/features/bpm_lookup/domain/bpm_song.dart
  - lib/features/playlist/domain/playlist_generator.dart
autonomous: true

must_haves:
  truths:
    - "SongKey.normalize() produces identical keys for same song across curated data and API results"
    - "SongFeedback model round-trips through JSON without data loss"
    - "SongFeedbackPreferences persists and loads a Map<String, SongFeedback> via SharedPreferences"
    - "CuratedSong.lookupKey and PlaylistGenerator both delegate to SongKey.normalize()"
  artifacts:
    - path: "lib/features/song_feedback/domain/song_feedback.dart"
      provides: "SongKey utility class and SongFeedback model"
      contains: "class SongKey"
    - path: "lib/features/song_feedback/data/song_feedback_preferences.dart"
      provides: "SharedPreferences persistence wrapper for feedback map"
      contains: "class SongFeedbackPreferences"
    - path: "lib/features/curated_songs/domain/curated_song.dart"
      provides: "lookupKey delegating to SongKey.normalize()"
      contains: "SongKey.normalize"
    - path: "lib/features/bpm_lookup/domain/bpm_song.dart"
      provides: "lookupKey getter on BpmSong"
      contains: "String get lookupKey"
    - path: "lib/features/playlist/domain/playlist_generator.dart"
      provides: "Uses SongKey.normalize() instead of inline normalization"
      contains: "SongKey.normalize"
  key_links:
    - from: "lib/features/curated_songs/domain/curated_song.dart"
      to: "lib/features/song_feedback/domain/song_feedback.dart"
      via: "import and SongKey.normalize() call"
      pattern: "SongKey\\.normalize\\(artistName, title\\)"
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/song_feedback/domain/song_feedback.dart"
      via: "import and SongKey.normalize() call"
      pattern: "SongKey\\.normalize"
---

<objective>
Create the SongFeedback domain model, centralized song key normalization utility, and SharedPreferences persistence layer. Refactor existing lookupKey usages to use the centralized SongKey.normalize().

Purpose: Establishes the data types and persistence foundation that the SongFeedbackNotifier (Plan 02) and all downstream phases (23-27) depend on. Centralizing song key normalization prevents key drift bugs across curated, API, and feedback data sources.

Output: SongFeedback model, SongKey utility, SongFeedbackPreferences, BpmSong.lookupKey getter, refactored CuratedSong and PlaylistGenerator.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-feedback-data-layer/22-RESEARCH.md

@lib/features/taste_profile/data/taste_profile_preferences.dart
@lib/features/curated_songs/domain/curated_song.dart
@lib/features/bpm_lookup/domain/bpm_song.dart
@lib/features/playlist/domain/playlist_generator.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: SongKey utility and SongFeedback model</name>
  <files>lib/features/song_feedback/domain/song_feedback.dart</files>
  <action>
Create `lib/features/song_feedback/domain/song_feedback.dart` containing two classes:

**SongKey utility:**
- Private constructor `SongKey._()` to prevent instantiation
- Static method `normalize(String artist, String title)` returning `'${artist.toLowerCase().trim()}|${title.toLowerCase().trim()}'`
- This is the single source of truth for song key normalization used everywhere

**SongFeedback model:**
- Immutable class with fields: `songKey` (String), `isLiked` (bool), `feedbackDate` (DateTime), `songTitle` (String), `songArtist` (String), `genre` (String?, optional for Phase 27 taste learning)
- `factory SongFeedback.fromJson(Map<String, dynamic> json)` -- parse all fields, use `DateTime.parse()` for feedbackDate
- `Map<String, dynamic> toJson()` -- serialize all fields, use `DateTime.toIso8601String()` for feedbackDate, conditionally include genre only if non-null
- `SongFeedback copyWith({bool? isLiked, DateTime? feedbackDate})` -- for toggling like/dislike

Follow the exact style of existing domain models (CuratedSong, TasteProfile). No Flutter dependencies -- pure Dart.
  </action>
  <verify>Run `dart analyze lib/features/song_feedback/domain/song_feedback.dart` with zero errors.</verify>
  <done>SongKey.normalize() and SongFeedback model exist with toJson/fromJson/copyWith. File compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: SongFeedbackPreferences and lookupKey centralization</name>
  <files>
    lib/features/song_feedback/data/song_feedback_preferences.dart
    lib/features/curated_songs/domain/curated_song.dart
    lib/features/bpm_lookup/domain/bpm_song.dart
    lib/features/playlist/domain/playlist_generator.dart
  </files>
  <action>
**Create SongFeedbackPreferences** (`lib/features/song_feedback/data/song_feedback_preferences.dart`):
- Follow TasteProfilePreferences pattern exactly (static class, SharedPreferences)
- `static const _key = 'song_feedback'`
- `static Future<Map<String, SongFeedback>> load()`:
  - Get SharedPreferences instance
  - Read JSON string from `_key`, return empty map if null
  - `jsonDecode` to `Map<String, dynamic>`
  - Iterate entries, try/catch per entry calling `SongFeedback.fromJson()` (corrupt-entry resilience, use `catch (_)`)
  - Return `Map<String, SongFeedback>` result
- `static Future<void> save(Map<String, SongFeedback> feedback)`:
  - Serialize via `feedback.map((k, v) => MapEntry(k, v.toJson()))`
  - `jsonEncode` and `prefs.setString(_key, ...)`
- `static Future<void> clear()`:
  - `prefs.remove(_key)`
- Import dart:convert and shared_preferences

**Refactor CuratedSong.lookupKey** (`lib/features/curated_songs/domain/curated_song.dart`):
- Add import for `song_feedback.dart` (specifically `SongKey`)
- Change `lookupKey` getter body to: `SongKey.normalize(artistName, title)`
- The external behavior is identical -- this is a pure refactor

**Add BpmSong.lookupKey** (`lib/features/bpm_lookup/domain/bpm_song.dart`):
- Add import for `song_feedback.dart` (specifically `SongKey`)
- Add getter: `String get lookupKey => SongKey.normalize(artistName, title);`
- This is a new non-breaking getter addition

**Refactor PlaylistGenerator** (`lib/features/playlist/domain/playlist_generator.dart`):
- Add import for `song_feedback.dart` (specifically `SongKey`)
- In `_scoreAndRank`, replace the inline key construction:
  ```
  final lookupKey = '${song.artistName.toLowerCase().trim()}|${song.title.toLowerCase().trim()}';
  ```
  with:
  ```
  final lookupKey = SongKey.normalize(song.artistName, song.title);
  ```
- Alternatively, use `song.lookupKey` since BpmSong now has the getter

Note: The import path will be `package:running_playlist_ai/features/song_feedback/domain/song_feedback.dart`.
  </action>
  <verify>Run `dart analyze lib/features/song_feedback/ lib/features/curated_songs/domain/curated_song.dart lib/features/bpm_lookup/domain/bpm_song.dart lib/features/playlist/domain/playlist_generator.dart` with zero errors. Then run `flutter test test/features/playlist/` to verify PlaylistGenerator tests still pass after refactor.</verify>
  <done>SongFeedbackPreferences load/save/clear exist. CuratedSong.lookupKey delegates to SongKey.normalize(). BpmSong has lookupKey getter. PlaylistGenerator uses SongKey.normalize() or BpmSong.lookupKey. All existing tests pass.</done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/song_feedback/` -- zero errors on new files
2. `dart analyze lib/features/curated_songs/domain/curated_song.dart lib/features/bpm_lookup/domain/bpm_song.dart lib/features/playlist/domain/playlist_generator.dart` -- zero errors on refactored files
3. `flutter test test/features/playlist/` -- existing playlist tests pass (validates PlaylistGenerator refactor is behavior-preserving)
4. `flutter test test/features/curated_songs/` -- existing curated songs tests pass (if any)
5. `flutter test test/features/song_quality/` -- scoring tests pass (uses lookupKey indirectly)
</verification>

<success_criteria>
- SongKey.normalize('  Eminem ', ' Lose Yourself ') returns 'eminem|lose yourself'
- SongFeedback round-trips through toJson/fromJson without data loss
- SongFeedbackPreferences can save and load a Map<String, SongFeedback>
- CuratedSong.lookupKey produces same output as before (behavior-preserving refactor)
- BpmSong.lookupKey produces same key as CuratedSong.lookupKey for matching songs
- All existing tests pass (no regressions from refactor)
</success_criteria>

<output>
After completion, create `.planning/phases/22-feedback-data-layer/22-01-SUMMARY.md`
</output>
