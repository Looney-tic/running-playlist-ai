---
phase: 25-freshness
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/features/playlist_freshness/domain/playlist_freshness.dart
  - lib/features/playlist_freshness/data/playlist_freshness_preferences.dart
  - lib/features/playlist_freshness/providers/playlist_freshness_providers.dart
  - test/features/playlist_freshness/domain/playlist_freshness_test.dart
autonomous: true

must_haves:
  truths:
    - "PlayHistory.freshnessPenalty returns 0 for never-played songs"
    - "PlayHistory.freshnessPenalty returns -8 for songs played 0-2 days ago"
    - "PlayHistory.freshnessPenalty returns -5 for songs played 3-6 days ago"
    - "PlayHistory.freshnessPenalty returns -2 for songs played 7-13 days ago"
    - "PlayHistory.freshnessPenalty returns 0 for songs played 14+ days ago"
    - "PlayHistory.recordPlaylist merges new song entries with existing map"
    - "PlayHistory prunes entries older than 30 days on construction"
    - "FreshnessMode enum has keepItFresh and optimizeForTaste values"
    - "PlayHistoryPreferences round-trips a PlayHistory through save/load"
    - "FreshnessPreferences round-trips a FreshnessMode through save/load"
    - "FreshnessMode defaults to keepItFresh when no saved preference exists"
  artifacts:
    - path: "lib/features/playlist_freshness/domain/playlist_freshness.dart"
      provides: "PlayHistory model, FreshnessMode enum"
      contains: "freshnessPenalty"
    - path: "lib/features/playlist_freshness/data/playlist_freshness_preferences.dart"
      provides: "PlayHistoryPreferences, FreshnessPreferences persistence"
      contains: "SharedPreferences"
    - path: "lib/features/playlist_freshness/providers/playlist_freshness_providers.dart"
      provides: "PlayHistoryNotifier, FreshnessModeNotifier, providers"
      contains: "StateNotifierProvider"
    - path: "test/features/playlist_freshness/domain/playlist_freshness_test.dart"
      provides: "Unit tests for PlayHistory and FreshnessMode"
      contains: "freshnessPenalty"
  key_links:
    - from: "lib/features/playlist_freshness/providers/playlist_freshness_providers.dart"
      to: "lib/features/playlist_freshness/data/playlist_freshness_preferences.dart"
      via: "PlayHistoryPreferences.load/save calls"
      pattern: "PlayHistoryPreferences\\.(load|save)"
    - from: "lib/features/playlist_freshness/providers/playlist_freshness_providers.dart"
      to: "lib/features/playlist_freshness/domain/playlist_freshness.dart"
      via: "StateNotifier<PlayHistory> and StateNotifier<FreshnessMode>"
      pattern: "StateNotifier<PlayHistory>"
---

<objective>
Build the freshness data layer: PlayHistory domain model with time-decayed penalty scoring, FreshnessMode enum, SharedPreferences persistence, and Riverpod providers.

Purpose: Provides the data foundation for playlist freshness tracking (FRSH-01 recording, FRSH-02 penalty computation, FRSH-03 mode toggle persistence). Plan 02 wires these into the generation pipeline and UI.

Output: Tested domain model, persistence layer, and providers for play history and freshness mode.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/features/song_feedback/domain/song_feedback.dart
@lib/features/song_feedback/data/song_feedback_preferences.dart
@lib/features/song_feedback/providers/song_feedback_providers.dart
@lib/features/playlist/domain/playlist.dart
</context>

<feature>
  <name>PlayHistory freshness penalty scoring + persistence + providers</name>
  <files>
    lib/features/playlist_freshness/domain/playlist_freshness.dart
    lib/features/playlist_freshness/data/playlist_freshness_preferences.dart
    lib/features/playlist_freshness/providers/playlist_freshness_providers.dart
    test/features/playlist_freshness/domain/playlist_freshness_test.dart
  </files>
  <behavior>
    PlayHistory is an immutable class holding Map<String, DateTime> (songKey -> lastPlayedAt).

    PlayHistory.freshnessPenalty(songKey, {now}):
    - songKey not in entries -> 0
    - 0-2 days since last played -> -8
    - 3-6 days -> -5
    - 7-13 days -> -2
    - 14+ days -> 0

    PlayHistory.recordPlaylist(Playlist playlist):
    - For each song in playlist.songs, set entries[song.lookupKey] = playlist.createdAt
    - Returns new PlayHistory with merged entries (existing entries preserved, new entries override)

    PlayHistory constructor prunes entries older than 30 days.

    FreshnessMode enum: keepItFresh, optimizeForTaste

    PlayHistoryPreferences (follows SongFeedbackPreferences pattern):
    - static const _key = 'play_history'
    - load(): deserialize Map<String, DateTime> from JSON string, return PlayHistory
    - save(PlayHistory): serialize entries map as JSON string

    FreshnessPreferences (follows OnboardingPreferences pattern):
    - static const _modeKey = 'freshness_mode'
    - loadMode(): read string, parse to FreshnessMode, default to keepItFresh
    - saveMode(FreshnessMode): write mode.name as string

    PlayHistoryNotifier (follows SongFeedbackNotifier pattern):
    - extends StateNotifier<PlayHistory>
    - Constructor calls _load(), has Completer-based ensureLoaded()
    - recordPlaylist(Playlist): update state with recordPlaylist(), persist via PlayHistoryPreferences.save()

    FreshnessModeNotifier:
    - extends StateNotifier<FreshnessMode>
    - Constructor calls _load(), has Completer-based ensureLoaded()
    - setMode(FreshnessMode): update state, persist via FreshnessPreferences.saveMode()

    Providers:
    - playHistoryProvider: StateNotifierProvider<PlayHistoryNotifier, PlayHistory>
    - freshnessModeProvider: StateNotifierProvider<FreshnessModeNotifier, FreshnessMode>
  </behavior>
  <implementation>
    1. RED: Create test file with tests for PlayHistory.freshnessPenalty (all 5 tiers), PlayHistory.recordPlaylist (merges entries, uses playlist.createdAt), 30-day pruning, and FreshnessMode enum values. Tests should fail because domain model doesn't exist yet.

    2. GREEN: Create domain model (playlist_freshness.dart) with PlayHistory class and FreshnessMode enum. Implement freshnessPenalty with tiered int returns. Implement recordPlaylist using Playlist.songs[].lookupKey and playlist.createdAt. Add 30-day pruning in constructor. Run tests -- all pass.

    3. Create persistence layer (playlist_freshness_preferences.dart):
    - PlayHistoryPreferences: encode entries as Map<String, String> where values are ISO8601 date strings. Decode back. Follow SongFeedbackPreferences pattern exactly.
    - FreshnessPreferences: getString/setString with mode.name. Default keepItFresh.

    4. Create providers (playlist_freshness_providers.dart):
    - PlayHistoryNotifier: StateNotifier<PlayHistory>, Completer-based ensureLoaded, _load from PlayHistoryPreferences, recordPlaylist method updates state then persists.
    - FreshnessModeNotifier: StateNotifier<FreshnessMode>, Completer-based ensureLoaded, _load from FreshnessPreferences, setMode method updates state then persists.
    - Export both providers.

    Import PlayHistory and use SongKey.normalize pattern from song_feedback domain. Import Playlist from playlist domain for recordPlaylist parameter type.
  </implementation>
</feature>

<verification>
- `dart test test/features/playlist_freshness/` passes all tests
- `dart analyze --no-fatal-infos` produces no errors in new files
- PlayHistory.freshnessPenalty returns correct tiers for all 5 boundary conditions
- PlayHistory.recordPlaylist correctly merges entries from a Playlist
- Entries older than 30 days are pruned on PlayHistory construction
</verification>

<success_criteria>
- All TDD tests pass (RED -> GREEN confirmed)
- PlayHistory, FreshnessMode, persistence, and providers exist and compile
- Domain model is pure Dart with no Flutter dependencies
- Providers follow established SongFeedbackNotifier pattern (Completer-based ensureLoaded)
</success_criteria>

<output>
After completion, create `.planning/phases/25-freshness/25-01-SUMMARY.md`
</output>
