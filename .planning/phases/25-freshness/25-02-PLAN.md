---
phase: 25-freshness
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - lib/features/song_quality/domain/song_quality_scorer.dart
  - lib/features/playlist/domain/playlist_generator.dart
  - lib/features/playlist/providers/playlist_providers.dart
  - lib/features/playlist/presentation/playlist_screen.dart
autonomous: true

must_haves:
  truths:
    - "After generating a playlist, the app records which songs were included and when"
    - "In keep-it-fresh mode, songs from a playlist generated yesterday rank lower than songs not played recently"
    - "User can toggle between keep-it-fresh and optimize-for-taste modes in the playlist screen"
    - "The freshness mode toggle persists across app restarts"
    - "In optimize-for-taste mode, recently played songs receive no freshness penalty"
    - "Freshness penalty is applied in all three generation paths: generate, shuffle, regenerate"
  artifacts:
    - path: "lib/features/song_quality/domain/song_quality_scorer.dart"
      provides: "freshnessPenalty parameter in score()"
      contains: "freshnessPenalty"
    - path: "lib/features/playlist/domain/playlist_generator.dart"
      provides: "playHistory parameter in generate()"
      contains: "playHistory"
    - path: "lib/features/playlist/providers/playlist_providers.dart"
      provides: "Play history recording + freshness wiring in all 3 paths"
      contains: "playHistoryProvider"
    - path: "lib/features/playlist/presentation/playlist_screen.dart"
      provides: "Freshness mode toggle UI"
      contains: "FreshnessMode"
  key_links:
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/playlist_freshness/providers/playlist_freshness_providers.dart"
      via: "ref.read(playHistoryProvider) and ref.read(freshnessModeProvider)"
      pattern: "playHistoryProvider"
    - from: "lib/features/playlist/domain/playlist_generator.dart"
      to: "lib/features/song_quality/domain/song_quality_scorer.dart"
      via: "SongQualityScorer.score(freshnessPenalty: penalty)"
      pattern: "freshnessPenalty"
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "lib/features/playlist/domain/playlist_generator.dart"
      via: "PlaylistGenerator.generate(playHistory: ...)"
      pattern: "playHistory"
---

<objective>
Wire freshness scoring into the playlist generation pipeline and add a freshness mode toggle to the playlist screen UI.

Purpose: Connects the PlayHistory data layer (Plan 01) to the scoring algorithm, all three generation paths, and the user-facing toggle. This completes FRSH-01 (recording), FRSH-02 (ranking penalty), and FRSH-03 (mode toggle).

Output: Freshness-aware playlist generation with user-controllable mode toggle.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-freshness/25-01-SUMMARY.md
@lib/features/song_quality/domain/song_quality_scorer.dart
@lib/features/playlist/domain/playlist_generator.dart
@lib/features/playlist/providers/playlist_providers.dart
@lib/features/playlist/presentation/playlist_screen.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add freshnessPenalty to SongQualityScorer and PlaylistGenerator</name>
  <files>
    lib/features/song_quality/domain/song_quality_scorer.dart
    lib/features/playlist/domain/playlist_generator.dart
  </files>
  <action>
    **SongQualityScorer.score():**
    Add `int freshnessPenalty = 0` as an optional named parameter (follows the `isLiked` pattern from Phase 23). Add `total += freshnessPenalty;` after the isLiked line. Update the doc comment to mention the freshness dimension and adjust the max score comment (freshnessPenalty is 0 or negative, so max score stays the same).

    **PlaylistGenerator.generate():**
    Add `Map<String, DateTime>? playHistory` as an optional named parameter. In `_scoreAndRank`, add a `Map<String, DateTime>? playHistory` parameter. Inside `_scoreAndRank`, for each song, compute the freshness penalty:
    ```dart
    final freshPenalty = playHistory != null
        ? PlayHistory(entries: playHistory).freshnessPenalty(song.lookupKey)
        : 0;
    ```
    Pass `freshnessPenalty: freshPenalty` to `SongQualityScorer.score()`.

    Import `PlayHistory` from `playlist_freshness/domain/playlist_freshness.dart`.

    This keeps both SongQualityScorer and PlaylistGenerator as pure Dart with no Flutter dependency. PlayHistory is instantiated inline since it's a lightweight value object.
  </action>
  <verify>
    `dart analyze --no-fatal-infos lib/features/song_quality/ lib/features/playlist/domain/` passes with no errors.
  </verify>
  <done>
    SongQualityScorer.score() accepts freshnessPenalty int parameter. PlaylistGenerator.generate() accepts playHistory map and computes per-song freshness penalties during scoring.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire freshness into all 3 generation paths and record play history</name>
  <files>lib/features/playlist/providers/playlist_providers.dart</files>
  <action>
    In PlaylistGenerationNotifier:

    **1. Add import** for `playlist_freshness_providers.dart`.

    **2. Create helper method `_readPlayHistory()`:**
    ```dart
    Map<String, DateTime>? _readPlayHistory() {
      final mode = ref.read(freshnessModeProvider);
      if (mode == FreshnessMode.optimizeForTaste) return null;
      final history = ref.read(playHistoryProvider);
      return history.entries.isNotEmpty ? history.entries : null;
    }
    ```
    This returns null in optimize-for-taste mode (no penalty applied) or when history is empty.

    **3. Wire into generatePlaylist():**
    - After `await ref.read(songFeedbackProvider.notifier).ensureLoaded();`, add:
      ```dart
      await ref.read(playHistoryProvider.notifier).ensureLoaded();
      await ref.read(freshnessModeProvider.notifier).ensureLoaded();
      ```
    - Before calling `PlaylistGenerator.generate()`, call `final playHistory = _readPlayHistory();`
    - Add `playHistory: playHistory,` to the `PlaylistGenerator.generate()` call.
    - After the `unawaited(ref.read(playlistHistoryProvider.notifier).addPlaylist(playlist))` call, add:
      ```dart
      ref.read(playHistoryProvider.notifier).recordPlaylist(playlist);
      ```
      (No unawaited needed -- StateNotifier update is sync, persistence is fire-and-forget inside the notifier.)

    **4. Wire into shufflePlaylist():**
    - Before calling `PlaylistGenerator.generate()`, call `final playHistory = _readPlayHistory();`
    - Add `playHistory: playHistory,` to the generate call.
    - After the `unawaited(ref.read(playlistHistoryProvider.notifier).addPlaylist(playlist))` call, add play history recording (same as generatePlaylist).

    **5. Wire into regeneratePlaylist():**
    - After `await ref.read(songFeedbackProvider.notifier).ensureLoaded();`, add ensureLoaded for playHistory and freshnessMode providers.
    - Before calling `PlaylistGenerator.generate()`, call `final playHistory = _readPlayHistory();`
    - Add `playHistory: playHistory,` to the generate call.
    - After history save, add play history recording.

    **Critical: all 3 paths must have both the playHistory parameter AND the recordPlaylist call.** This was the lesson from Phase 23 (decision 23-01) -- forgetting one path causes inconsistent behavior.
  </action>
  <verify>
    `dart analyze --no-fatal-infos lib/features/playlist/providers/` passes with no errors.
  </verify>
  <done>
    All three generation methods (generatePlaylist, shufflePlaylist, regeneratePlaylist) pass play history to PlaylistGenerator.generate() when in keepItFresh mode, and record play history after successful generation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add freshness mode toggle to playlist screen UI</name>
  <files>lib/features/playlist/presentation/playlist_screen.dart</files>
  <action>
    Add a freshness mode toggle in both `_IdleView` and the `_PlaylistView` selector row.

    **In _IdleView:**
    Add a `_FreshnessToggle()` widget between `_TasteProfileSelector()` and the Generate button, with `const SizedBox(height: 8)` spacing.

    **In _PlaylistView:**
    Add `_FreshnessToggle()` as a new row below the existing selectors + Generate row (inside the Padding), or as a separate Padding widget between the selectors row and the cadence nudge row. Use `const SizedBox(height: 4)` spacing.

    **Create _FreshnessToggle widget:**
    ```dart
    class _FreshnessToggle extends ConsumerWidget {
      @override
      Widget build(BuildContext context, WidgetRef ref) {
        final mode = ref.watch(freshnessModeProvider);
        final theme = Theme.of(context);

        return SegmentedButton<FreshnessMode>(
          segments: const [
            ButtonSegment(
              value: FreshnessMode.keepItFresh,
              label: Text('Keep it Fresh'),
              icon: Icon(Icons.auto_awesome),
            ),
            ButtonSegment(
              value: FreshnessMode.optimizeForTaste,
              label: Text('Best Taste'),
              icon: Icon(Icons.favorite),
            ),
          ],
          selected: {mode},
          onSelectionChanged: (selected) {
            ref.read(freshnessModeProvider.notifier).setMode(selected.first);
          },
          style: SegmentedButton.styleFrom(
            visualDensity: VisualDensity.compact,
          ),
        );
      }
    }
    ```

    Add imports for `FreshnessMode` and `freshnessModeProvider` from `playlist_freshness/providers/playlist_freshness_providers.dart`, and `FreshnessMode` from `playlist_freshness/domain/playlist_freshness.dart`.

    The SegmentedButton uses Material 3 styling and is consistent with the existing selector pattern (compact, in the control area above the song list).
  </action>
  <verify>
    `dart analyze --no-fatal-infos lib/features/playlist/presentation/playlist_screen.dart` passes with no errors.
  </verify>
  <done>
    Freshness mode toggle (SegmentedButton) appears in both idle and loaded playlist views. Toggling updates the provider state which persists across restarts and affects the next playlist generation.
  </done>
</task>

</tasks>

<verification>
1. `dart analyze --no-fatal-infos` passes across all modified files
2. `dart test test/features/playlist_freshness/` passes (tests from Plan 01)
3. Freshness mode toggle visible in playlist idle view and loaded view
4. In keepItFresh mode, PlaylistGenerator receives playHistory map
5. In optimizeForTaste mode, PlaylistGenerator receives null playHistory (no penalty)
6. After generation, play history is recorded via PlayHistoryNotifier.recordPlaylist()
7. All three paths (generate, shuffle, regenerate) wire freshness consistently
</verification>

<success_criteria>
- SongQualityScorer.score() accepts and applies freshnessPenalty parameter
- PlaylistGenerator.generate() accepts playHistory map and computes per-song penalties
- All 3 generation paths in PlaylistGenerationNotifier pass play history and record results
- Freshness mode toggle persists via SharedPreferences and affects generation behavior
- No analyzer warnings or errors
</success_criteria>

<output>
After completion, create `.planning/phases/25-freshness/25-02-SUMMARY.md`
</output>
