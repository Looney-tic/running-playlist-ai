---
phase: 27-taste-learning
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/features/taste_learning/domain/taste_suggestion.dart
  - lib/features/taste_learning/domain/taste_pattern_analyzer.dart
  - lib/features/taste_learning/data/taste_suggestion_preferences.dart
  - lib/features/taste_learning/providers/taste_learning_providers.dart
  - lib/features/curated_songs/providers/curated_song_providers.dart
  - test/features/taste_learning/domain/taste_pattern_analyzer_test.dart
autonomous: true

must_haves:
  truths:
    - "TastePatternAnalyzer detects genre patterns in liked songs using curated metadata enrichment"
    - "TastePatternAnalyzer detects artist patterns in liked songs"
    - "TastePatternAnalyzer detects disliked-artist patterns"
    - "Patterns already present in the active taste profile are excluded from suggestions"
    - "Dismissed suggestions do not reappear until evidence count grows by +3"
    - "Minimum thresholds prevent small-sample false positives (genre: 3 liked, 30% ratio; artist: 2 liked; disliked: 2)"
    - "TasteSuggestionNotifier reactively recomputes when feedback changes"
  artifacts:
    - path: "lib/features/taste_learning/domain/taste_suggestion.dart"
      provides: "TasteSuggestion model with SuggestionType enum and deterministic IDs"
      contains: "SuggestionType"
    - path: "lib/features/taste_learning/domain/taste_pattern_analyzer.dart"
      provides: "Pure Dart analyzer with static analyze() method"
      contains: "TastePatternAnalyzer"
    - path: "lib/features/taste_learning/data/taste_suggestion_preferences.dart"
      provides: "SharedPreferences persistence for dismissed suggestions with evidence counts"
      contains: "TasteSuggestionPreferences"
    - path: "lib/features/taste_learning/providers/taste_learning_providers.dart"
      provides: "TasteSuggestionNotifier and tasteSuggestionProvider"
      contains: "tasteSuggestionProvider"
    - path: "lib/features/curated_songs/providers/curated_song_providers.dart"
      provides: "curatedGenreLookupProvider for genre enrichment"
      contains: "curatedGenreLookupProvider"
    - path: "test/features/taste_learning/domain/taste_pattern_analyzer_test.dart"
      provides: "Unit tests for analyzer thresholds, edge cases, and genre enrichment"
      min_lines: 80
  key_links:
    - from: "lib/features/taste_learning/domain/taste_pattern_analyzer.dart"
      to: "lib/features/song_feedback/domain/song_feedback.dart"
      via: "reads SongFeedback.songKey, .isLiked, .songArtist"
      pattern: "SongFeedback"
    - from: "lib/features/taste_learning/domain/taste_pattern_analyzer.dart"
      to: "lib/features/taste_profile/domain/taste_profile.dart"
      via: "checks genres, artists, dislikedArtists already in profile"
      pattern: "TasteProfile"
    - from: "lib/features/taste_learning/providers/taste_learning_providers.dart"
      to: "lib/features/song_feedback/providers/song_feedback_providers.dart"
      via: "ref.watch(songFeedbackProvider)"
      pattern: "songFeedbackProvider"
---

<objective>
Build the taste pattern detection engine: domain model, pure-Dart analyzer with genre enrichment from curated metadata, SharedPreferences persistence for dismissed suggestions, reactive Riverpod provider, and TDD test suite proving all threshold and filtering logic.

Purpose: This is the backend brain of taste learning -- it transforms raw feedback data into actionable suggestions without any UI. Plan 27-02 will consume the provider to render suggestion cards.

Output: TasteSuggestion model, TastePatternAnalyzer, TasteSuggestionPreferences, TasteSuggestionNotifier + provider, curatedGenreLookupProvider, and unit tests.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-taste-learning/27-RESEARCH.md

@lib/features/song_feedback/domain/song_feedback.dart
@lib/features/song_feedback/providers/song_feedback_providers.dart
@lib/features/taste_profile/domain/taste_profile.dart
@lib/features/taste_profile/providers/taste_profile_providers.dart
@lib/features/curated_songs/domain/curated_song.dart
@lib/features/curated_songs/providers/curated_song_providers.dart
@lib/features/curated_songs/data/curated_song_repository.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: TasteSuggestion model, TastePatternAnalyzer, and TDD test suite</name>
  <files>
    lib/features/taste_learning/domain/taste_suggestion.dart
    lib/features/taste_learning/domain/taste_pattern_analyzer.dart
    test/features/taste_learning/domain/taste_pattern_analyzer_test.dart
  </files>
  <action>
**RED phase first, then GREEN.**

**1. Create `lib/features/taste_learning/domain/taste_suggestion.dart`:**

Pure Dart, no Flutter imports.

```dart
enum SuggestionType { addGenre, addArtist, removeArtist }

class TasteSuggestion {
  const TasteSuggestion({
    required this.type,
    required this.displayText,
    required this.value,
    required this.confidence,
    required this.evidenceCount,
  });

  final SuggestionType type;
  final String displayText; // e.g. "Add Hip-Hop to your genres?"
  final String value;       // e.g. "hipHop" or "Eminem"
  final double confidence;  // 0.0-1.0
  final int evidenceCount;

  /// Deterministic ID: 'type.name:value' for stable dismissed-set keying.
  String get id => '${type.name}:$value';
}
```

**2. Create `lib/features/taste_learning/domain/taste_pattern_analyzer.dart`:**

Pure Dart class with a single static `analyze()` method. Inputs:
- `Map<String, SongFeedback> feedback` -- all feedback entries
- `Map<String, String> curatedGenreLookup` -- lookupKey -> genre enum name (from curated dataset)
- `TasteProfile activeProfile` -- current taste profile to exclude existing preferences
- `Map<String, int> dismissedSuggestions` -- suggestionId -> evidenceCount at dismissal time

Returns `List<TasteSuggestion>` sorted by evidenceCount descending, capped at 3 suggestions max.

**Analysis logic:**

a) **Genre analysis:**
   - For each liked feedback entry, look up `curatedGenreLookup[entry.songKey]` to get genre.
   - Skip entries with no genre match (API-only songs).
   - Count genre frequencies. Track total liked entries with known genre.
   - For each genre NOT already in `activeProfile.genres`:
     - Require count >= 3 AND ratio >= 0.30 (30% of liked songs with known genre)
     - If minimum 5 liked songs with genre data total
   - Confidence = ratio (count / totalLikedWithGenre)
   - DisplayText: "Add {genre.displayName} to your genres?"

b) **Artist analysis (liked):**
   - For each liked feedback entry, count by `entry.songArtist` (display case).
   - Skip artists already in `activeProfile.artists` (case-insensitive compare).
   - Require count >= 2.
   - Confidence = count / totalLiked.
   - DisplayText: "Add {artistName} to your favorites?"

c) **Disliked artist analysis:**
   - For each disliked feedback entry, count by `entry.songArtist`.
   - Skip artists already in `activeProfile.dislikedArtists` (case-insensitive compare).
   - Require count >= 2.
   - Confidence = count / totalDisliked.
   - DisplayText: "Block {artistName} from playlists?"

d) **Dismissed filtering:**
   - For each candidate suggestion, check `dismissedSuggestions[suggestion.id]`.
   - If present, only include if `suggestion.evidenceCount >= dismissedAtCount + 3`.

e) Sort by evidenceCount descending, take top 3.

**3. Create test file `test/features/taste_learning/domain/taste_pattern_analyzer_test.dart`:**

Write tests FIRST (RED), then implement analyzer to pass (GREEN). Test cases:

- **Genre detection:** 5 liked songs, 3 in "rock" genre via curated lookup, rock not in profile -> suggests addGenre:rock
- **Genre below threshold:** 5 liked songs, 1 in "rock" -> no suggestion (count < 3)
- **Genre already in profile:** 3 liked rock songs but rock already in profile.genres -> no suggestion
- **Genre ratio below threshold:** 10 liked songs with genre data, 2 in rock (20% < 30%) -> no suggestion even though count >= 3
- **Insufficient genre data:** Only 3 liked songs total with genre data -> no genre suggestions (< 5 minimum)
- **Artist detection:** 2 liked songs by "Eminem", Eminem not in profile.artists -> suggests addArtist
- **Artist already in profile:** 2 liked songs by Eminem, Eminem already in profile -> no suggestion
- **Disliked artist detection:** 2 disliked songs by "Nickelback" -> suggests removeArtist
- **Dismissed suggestion not resurfaced:** suggestion dismissed at evidenceCount=3, current evidenceCount=4 (delta < 3) -> filtered out
- **Dismissed suggestion resurfaced:** suggestion dismissed at evidenceCount=3, current evidenceCount=6 (delta >= 3) -> included
- **Max 3 suggestions returned:** create enough data for 5+ suggestions, verify only 3 returned
- **API-only songs gracefully skipped for genre:** feedback entries not in curatedGenreLookup are skipped for genre analysis but counted for artist analysis
- **Empty feedback returns empty suggestions**

Use an empty TasteProfile (`TasteProfile(genres: [], artists: [])`) as the baseline profile. Build feedback maps inline in each test.

Do NOT use mocks -- TastePatternAnalyzer is a pure function taking all inputs explicitly.
  </action>
  <verify>
Run `cd /Users/tijmen/running-playlist-ai && flutter test test/features/taste_learning/domain/taste_pattern_analyzer_test.dart` -- all tests pass.
  </verify>
  <done>TasteSuggestion model exists with SuggestionType enum and deterministic id getter. TastePatternAnalyzer.analyze() correctly detects genre patterns (via curated lookup enrichment), artist patterns, and disliked-artist patterns with all thresholds enforced. Dismissed suggestions are filtered by evidence delta. All unit tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Persistence, providers, and curatedGenreLookupProvider</name>
  <files>
    lib/features/taste_learning/data/taste_suggestion_preferences.dart
    lib/features/taste_learning/providers/taste_learning_providers.dart
    lib/features/curated_songs/providers/curated_song_providers.dart
  </files>
  <action>
**1. Add `curatedGenreLookupProvider` to `lib/features/curated_songs/providers/curated_song_providers.dart`:**

Add a new FutureProvider below the existing providers:

```dart
/// Provides a lookup map from song lookupKey to genre enum name.
///
/// Used by the taste pattern analyzer to enrich feedback entries
/// (which lack genre data) with genre from the curated dataset.
final curatedGenreLookupProvider =
    FutureProvider<Map<String, String>>((ref) async {
  final songs = await CuratedSongRepository.loadCuratedSongs();
  return {
    for (final s in songs) s.lookupKey: s.genre,
  };
});
```

**2. Create `lib/features/taste_learning/data/taste_suggestion_preferences.dart`:**

SharedPreferences persistence for dismissed suggestions. Store as JSON map: `{suggestionId: evidenceCountAtDismissal}`.

```dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';

class TasteSuggestionPreferences {
  static const _key = 'dismissed_taste_suggestions';

  /// Loads the dismissed suggestion map: {suggestionId: evidenceCountAtDismissal}.
  static Future<Map<String, int>> loadDismissed() async {
    final prefs = await SharedPreferences.getInstance();
    final json = prefs.getString(_key);
    if (json == null) return {};
    final decoded = jsonDecode(json) as Map<String, dynamic>;
    return decoded.map((k, v) => MapEntry(k, v as int));
  }

  /// Saves the dismissed suggestion map.
  static Future<void> saveDismissed(Map<String, int> dismissed) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_key, jsonEncode(dismissed));
  }
}
```

**3. Create `lib/features/taste_learning/providers/taste_learning_providers.dart`:**

TasteSuggestionNotifier following the established Completer + ensureLoaded pattern from SongFeedbackNotifier and PostRunReviewNotifier.

```dart
import 'dart:async';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:running_playlist_ai/features/curated_songs/providers/curated_song_providers.dart';
import 'package:running_playlist_ai/features/song_feedback/providers/song_feedback_providers.dart';
import 'package:running_playlist_ai/features/taste_learning/data/taste_suggestion_preferences.dart';
import 'package:running_playlist_ai/features/taste_learning/domain/taste_pattern_analyzer.dart';
import 'package:running_playlist_ai/features/taste_learning/domain/taste_suggestion.dart';
import 'package:running_playlist_ai/features/taste_profile/providers/taste_profile_providers.dart';

class TasteSuggestionNotifier extends StateNotifier<List<TasteSuggestion>> {
  TasteSuggestionNotifier({required this.ref}) : super([]) {
    _load();
  }

  final Ref ref;
  final Completer<void> _loadCompleter = Completer<void>();
  Map<String, int> _dismissedSuggestions = {};

  Future<void> ensureLoaded() => _loadCompleter.future;

  Future<void> _load() async {
    try {
      _dismissedSuggestions = await TasteSuggestionPreferences.loadDismissed();
      await _reanalyze();
    } finally {
      if (!_loadCompleter.isCompleted) _loadCompleter.complete();
    }
  }

  /// Re-runs the pattern analyzer against current feedback and profile state.
  Future<void> _reanalyze() async {
    final feedback = ref.read(songFeedbackProvider);
    final profileState = ref.read(tasteProfileLibraryProvider);
    final profile = profileState.selectedProfile;
    if (profile == null || feedback.isEmpty) {
      if (mounted) state = [];
      return;
    }

    // Load curated genre lookup (async)
    final genreLookupAsync = ref.read(curatedGenreLookupProvider);
    final genreLookup = genreLookupAsync.valueOrNull ?? {};

    final suggestions = TastePatternAnalyzer.analyze(
      feedback: feedback,
      curatedGenreLookup: genreLookup,
      activeProfile: profile,
      dismissedSuggestions: _dismissedSuggestions,
    );

    if (mounted) state = suggestions;
  }

  /// Accept a suggestion: mutate taste profile, add to dismissed, re-analyze.
  Future<void> acceptSuggestion(TasteSuggestion suggestion) async {
    final profileState = ref.read(tasteProfileLibraryProvider);
    final profile = profileState.selectedProfile;
    if (profile == null) return;

    final notifier = ref.read(tasteProfileLibraryProvider.notifier);

    switch (suggestion.type) {
      case SuggestionType.addGenre:
        final genre = RunningGenre.tryFromJson(suggestion.value);
        if (genre == null || profile.genres.contains(genre)) return;
        await notifier.updateProfile(
          profile.copyWith(genres: [...profile.genres, genre]),
        );
      case SuggestionType.addArtist:
        if (profile.artists.any(
            (a) => a.toLowerCase() == suggestion.value.toLowerCase())) return;
        await notifier.updateProfile(
          profile.copyWith(artists: [...profile.artists, suggestion.value]),
        );
      case SuggestionType.removeArtist:
        if (profile.dislikedArtists.any(
            (a) => a.toLowerCase() == suggestion.value.toLowerCase())) return;
        await notifier.updateProfile(
          profile.copyWith(
            dislikedArtists: [...profile.dislikedArtists, suggestion.value],
          ),
        );
    }

    // Add to dismissed so it doesn't reappear
    _dismissedSuggestions[suggestion.id] = suggestion.evidenceCount;
    await TasteSuggestionPreferences.saveDismissed(_dismissedSuggestions);
    await _reanalyze();
  }

  /// Dismiss a suggestion: store evidence count at dismissal, re-analyze.
  Future<void> dismissSuggestion(TasteSuggestion suggestion) async {
    _dismissedSuggestions[suggestion.id] = suggestion.evidenceCount;
    await TasteSuggestionPreferences.saveDismissed(_dismissedSuggestions);
    await _reanalyze();
  }
}

final tasteSuggestionProvider =
    StateNotifierProvider<TasteSuggestionNotifier, List<TasteSuggestion>>(
  (ref) => TasteSuggestionNotifier(ref: ref),
);
```

Import `RunningGenre` from taste_profile domain. The notifier takes `Ref` so it can read feedback and profile providers.

Note: The notifier does an initial load on construction. The UI (Plan 27-02) will call `ref.watch(tasteSuggestionProvider)` to get the current suggestions, and Plan 27-02 will also add a listener to re-trigger analysis when feedback changes. For this plan, the notifier runs analysis once on load and on accept/dismiss -- that's sufficient for the provider contract.
  </action>
  <verify>
Run `cd /Users/tijmen/running-playlist-ai && flutter analyze lib/features/taste_learning/ lib/features/curated_songs/providers/curated_song_providers.dart` -- no errors. Run `flutter test test/features/taste_learning/` -- all tests still pass.
  </verify>
  <done>curatedGenreLookupProvider exists in curated_song_providers.dart. TasteSuggestionPreferences persists dismissed suggestions as {id: evidenceCount} map. TasteSuggestionNotifier loads dismissed state, runs TastePatternAnalyzer, exposes suggestions via tasteSuggestionProvider, and supports acceptSuggestion (mutates profile via TasteProfileLibraryNotifier.updateProfile) and dismissSuggestion (persists evidence count). All files compile without errors.</done>
</task>

</tasks>

<verification>
1. `flutter test test/features/taste_learning/` -- all analyzer unit tests pass
2. `flutter analyze lib/features/taste_learning/ lib/features/curated_songs/providers/curated_song_providers.dart` -- no errors
3. TastePatternAnalyzer.analyze() is a pure function with no Flutter imports
4. TasteSuggestion.id produces deterministic IDs for dismissed-set keying
5. Genre enrichment uses curated metadata lookup, NOT SongFeedback.genre field
6. Thresholds match research recommendations: genre 3/30%/5min, artist 2, disliked 2, re-emergence +3
</verification>

<success_criteria>
- TastePatternAnalyzer detects genre, artist, and disliked-artist patterns with configurable thresholds
- Suggestions exclude patterns already in the active taste profile
- Dismissed suggestions use evidence-count-delta logic (not simple set membership)
- All unit tests pass with realistic test scenarios
- Provider chain compiles: tasteSuggestionProvider -> songFeedbackProvider + tasteProfileLibraryProvider + curatedGenreLookupProvider
</success_criteria>

<output>
After completion, create `.planning/phases/27-taste-learning/27-01-SUMMARY.md`
</output>
