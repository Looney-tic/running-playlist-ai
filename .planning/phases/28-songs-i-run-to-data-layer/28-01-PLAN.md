---
phase: 28-songs-i-run-to-data-layer
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/running_songs/domain/running_song.dart
  - lib/features/running_songs/data/running_song_preferences.dart
  - lib/features/running_songs/providers/running_song_providers.dart
  - test/features/running_songs/running_song_test.dart
  - test/features/running_songs/running_song_lifecycle_test.dart
autonomous: true

must_haves:
  truths:
    - "RunningSong model round-trips through JSON without data loss including optional fields"
    - "RunningSongPreferences persists and loads a Map<String, RunningSong> via SharedPreferences key 'running_songs'"
    - "RunningSongNotifier supports addSong, removeSong, containsSong with immediate state updates"
    - "State survives dispose and reload (persistence lifecycle)"
    - "Corrupt entries in SharedPreferences are silently skipped during load"
  artifacts:
    - path: "lib/features/running_songs/domain/running_song.dart"
      provides: "RunningSong model and RunningSongSource enum"
      contains: "class RunningSong"
    - path: "lib/features/running_songs/data/running_song_preferences.dart"
      provides: "SharedPreferences persistence for running songs map"
      contains: "class RunningSongPreferences"
    - path: "lib/features/running_songs/providers/running_song_providers.dart"
      provides: "RunningSongNotifier StateNotifier and runningSongProvider"
      contains: "runningSongProvider"
    - path: "test/features/running_songs/running_song_test.dart"
      provides: "Domain model unit tests"
      contains: "RunningSong"
    - path: "test/features/running_songs/running_song_lifecycle_test.dart"
      provides: "Provider lifecycle integration tests"
      contains: "survives dispose"
  key_links:
    - from: "lib/features/running_songs/providers/running_song_providers.dart"
      to: "lib/features/running_songs/data/running_song_preferences.dart"
      via: "RunningSongNotifier calls RunningSongPreferences.load/save"
      pattern: "RunningSongPreferences\\.(load|save)"
    - from: "lib/features/running_songs/domain/running_song.dart"
      to: "lib/features/song_feedback/domain/song_feedback.dart"
      via: "import SongKey for normalize()"
      pattern: "SongKey\\.normalize"
---

<objective>
Create the RunningSong domain model, SharedPreferences persistence layer, RunningSongNotifier StateNotifier with Completer-based async init, and unit/lifecycle tests.

Purpose: Establishes the data foundation for the "Songs I Run To" feature. Plan 28-02 (UI layer) depends on these artifacts to display and mutate the running songs collection.

Output: RunningSong model, RunningSongSource enum, RunningSongPreferences, RunningSongNotifier, runningSongProvider, domain tests, lifecycle tests.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-songs-i-run-to-data-layer/28-RESEARCH.md

@lib/features/song_feedback/domain/song_feedback.dart
@lib/features/song_feedback/data/song_feedback_preferences.dart
@lib/features/song_feedback/providers/song_feedback_providers.dart
@test/features/song_feedback/domain/song_feedback_test.dart
@test/features/song_feedback/song_feedback_lifecycle_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: RunningSong domain model and RunningSongPreferences persistence</name>
  <files>
    lib/features/running_songs/domain/running_song.dart
    lib/features/running_songs/data/running_song_preferences.dart
  </files>
  <action>
**Create `lib/features/running_songs/domain/running_song.dart`:**

1. Define `RunningSongSource` enum with values: `curated`, `spotify`, `manual`. This tracks how the song was added. Include `orElse: () => RunningSongSource.curated` fallback in deserialization for forward-compatibility.

2. Define `RunningSong` immutable class with fields:
   - `songKey` (String, required) -- must equal `SongKey.normalize(artist, title)`
   - `artist` (String, required)
   - `title` (String, required)
   - `addedDate` (DateTime, required)
   - `bpm` (int?, optional) -- known BPM at time of addition
   - `genre` (String?, optional) -- genre if known from curated data
   - `source` (RunningSongSource, default `curated`)

3. Implement `factory RunningSong.fromJson(Map<String, dynamic> json)`:
   - Parse `songKey`, `artist`, `title` as `String`
   - Parse `addedDate` via `DateTime.parse(json['addedDate'] as String)`
   - Parse `bpm` as `(json['bpm'] as num?)?.toInt()`
   - Parse `genre` as `json['genre'] as String?`
   - Parse `source` via `RunningSongSource.values.firstWhere((s) => s.name == json['source'], orElse: () => RunningSongSource.curated)`

4. Implement `Map<String, dynamic> toJson()`:
   - Include `songKey`, `artist`, `title`, `addedDate` (as ISO 8601 string), `source` (as `.name`)
   - Conditionally include `bpm` and `genre` only if non-null (use `if (bpm != null) 'bpm': bpm` pattern)

5. Import `SongKey` from `package:running_playlist_ai/features/song_feedback/domain/song_feedback.dart` for the normalize reference. The model itself does NOT call normalize -- callers must provide a pre-normalized key. Document this in a comment.

Pure Dart -- no Flutter imports.

**Create `lib/features/running_songs/data/running_song_preferences.dart`:**

Follow `SongFeedbackPreferences` pattern exactly:

1. Static class with private constructor `RunningSongPreferences._()` to prevent instantiation.

2. `static const _key = 'running_songs'` -- unique SharedPreferences key.

3. `static Future<Map<String, RunningSong>> load()`:
   - Get SharedPreferences instance
   - Read JSON string from `_key`, return empty map if null
   - `jsonDecode` to `Map<String, dynamic>`
   - Iterate entries with try/catch per entry using `catch(_)` (NOT `catch(e)`) to skip corrupt entries
   - Return `Map<String, RunningSong>` result

4. `static Future<void> save(Map<String, RunningSong> songs)`:
   - Serialize via `songs.map((k, v) => MapEntry(k, v.toJson()))`
   - `jsonEncode` and `prefs.setString(_key, ...)`

5. `static Future<void> clear()`:
   - `prefs.remove(_key)`

Import `dart:convert` and `shared_preferences`.
  </action>
  <verify>Run `dart analyze lib/features/running_songs/domain/running_song.dart lib/features/running_songs/data/running_song_preferences.dart` with zero errors.</verify>
  <done>RunningSong model with fromJson/toJson exists. RunningSongSource enum with orElse fallback exists. RunningSongPreferences with load/save/clear exists using 'running_songs' key. Both files compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: RunningSongNotifier provider and tests</name>
  <files>
    lib/features/running_songs/providers/running_song_providers.dart
    test/features/running_songs/running_song_test.dart
    test/features/running_songs/running_song_lifecycle_test.dart
  </files>
  <action>
**Create `lib/features/running_songs/providers/running_song_providers.dart`:**

Follow `SongFeedbackNotifier` pattern exactly:

1. Define `RunningSongNotifier extends StateNotifier<Map<String, RunningSong>>`:
   - Constructor calls `_load()` in body (fire-and-forget)
   - `final Completer<void> _loadCompleter = Completer<void>()`
   - `Future<void> ensureLoaded() => _loadCompleter.future`
   - `Future<void> _load() async` with try/finally:
     - try: `final songs = await RunningSongPreferences.load(); if (mounted) state = songs;`
     - finally: `if (!_loadCompleter.isCompleted) _loadCompleter.complete();`
   - `Future<void> addSong(RunningSong song) async`:
     - `state = {...state, song.songKey: song};`
     - `await RunningSongPreferences.save(state);`
   - `Future<void> removeSong(String songKey) async`:
     - `state = Map.from(state)..remove(songKey);`
     - `await RunningSongPreferences.save(state);`
   - `bool containsSong(String songKey) => state.containsKey(songKey);`

2. Define provider:
   ```dart
   final runningSongProvider =
       StateNotifierProvider<RunningSongNotifier, Map<String, RunningSong>>(
     (ref) => RunningSongNotifier(),
   );
   ```

Import `dart:async` for Completer, the domain model, and the preferences class.

**Create `test/features/running_songs/running_song_test.dart`:**

Follow `test/features/song_feedback/domain/song_feedback_test.dart` pattern:

1. Test `RunningSong` JSON round-trip with all fields populated (including bpm, genre, source).
2. Test `RunningSong` JSON round-trip with optional fields null (bpm=null, genre=null).
3. Test `RunningSongSource` deserialization with unknown value falls back to `curated`.
4. Test `toJson` excludes null optional fields from output.

**Create `test/features/running_songs/running_song_lifecycle_test.dart`:**

Follow `test/features/song_feedback/song_feedback_lifecycle_test.dart` pattern:

1. setUp: `SharedPreferences.setMockInitialValues({})` + create `ProviderContainer`.
2. tearDown: `container.dispose()`.
3. Test "add a running song and read it back":
   - Get notifier via `container.read(runningSongProvider.notifier)`
   - `await notifier.ensureLoaded()`
   - Create a test `RunningSong` with `songKey: SongKey.normalize('Test Artist', 'Test Song')`
   - `await notifier.addSong(song)`
   - Verify `container.read(runningSongProvider)` has length 1 and contains the song key
4. Test "remove a running song":
   - Add then remove, verify empty map
5. Test "containsSong returns correct result":
   - Add a song, verify `containsSong` returns true for that key and false for another
6. Test "state survives dispose and reload":
   - Add a song, dispose container, create new container
   - Get notifier, ensureLoaded, verify song still present (persistence round-trip)
7. Test "corrupt entries are skipped on load":
   - Use `SharedPreferences.setMockInitialValues` with a JSON string containing one valid and one corrupt entry
   - Verify only the valid entry loads
  </action>
  <verify>Run `flutter test test/features/running_songs/` -- all tests pass.</verify>
  <done>RunningSongNotifier with addSong/removeSong/containsSong/ensureLoaded exists. runningSongProvider is registered. Domain model tests pass. Lifecycle tests (add, remove, contains, persistence round-trip, corrupt entry skip) pass.</done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/running_songs/` -- zero errors on all new files
2. `flutter test test/features/running_songs/` -- all domain + lifecycle tests pass
3. `flutter test` -- no regressions in existing test suite (pre-existing failures excepted: widget_test.dart, 2 playlist error message tests)
</verification>

<success_criteria>
- RunningSong('Test Artist', 'Test Song') round-trips through toJson/fromJson without data loss
- RunningSongSource.values.firstWhere with unknown value returns curated (not throws)
- RunningSongPreferences.save then load returns identical map content
- RunningSongNotifier.addSong updates state immediately and persists to SharedPreferences
- RunningSongNotifier.removeSong removes from state and persists
- State survives container dispose and reload (persistence lifecycle)
- Corrupt JSON entries do not crash load, are silently skipped
</success_criteria>

<output>
After completion, create `.planning/phases/28-songs-i-run-to-data-layer/28-01-SUMMARY.md`
</output>
