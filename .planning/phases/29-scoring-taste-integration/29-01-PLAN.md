---
phase: 29-scoring-taste-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/playlist/providers/playlist_providers.dart
  - lib/features/taste_learning/providers/taste_learning_providers.dart
autonomous: true

must_haves:
  truths:
    - "Running songs receive the same +5 scoring boost as liked songs during playlist generation"
    - "Genre and artist patterns from running songs appear as taste suggestions on the home screen"
    - "Real feedback takes precedence over synthetic running-song feedback for taste analysis"
  artifacts:
    - path: "lib/features/playlist/providers/playlist_providers.dart"
      provides: "Running songs merged into liked set for scoring boost"
      contains: "runningSongProvider"
    - path: "lib/features/taste_learning/providers/taste_learning_providers.dart"
      provides: "Synthetic feedback from running songs merged into taste analysis"
      contains: "_syntheticFeedbackFromRunningSongs"
  key_links:
    - from: "lib/features/playlist/providers/playlist_providers.dart"
      to: "runningSongProvider"
      via: "ref.read in _readFeedbackSets()"
      pattern: "liked\\.addAll\\(runningSongs\\.keys\\)"
    - from: "lib/features/taste_learning/providers/taste_learning_providers.dart"
      to: "runningSongProvider"
      via: "ref.listen + ref.read in _reanalyze()"
      pattern: "ref\\.listen\\(runningSongProvider"
---

<objective>
Wire "Songs I Run To" data into playlist scoring and taste learning so running songs boost playlist ranking and feed taste pattern analysis.

Purpose: Running songs are the user's strongest signal of music preference. Integrating them into scoring and taste learning makes the system smarter with every song the user adds.
Output: Modified playlist_providers.dart and taste_learning_providers.dart with running song integration.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-scoring-taste-integration/29-RESEARCH.md

@lib/features/playlist/providers/playlist_providers.dart
@lib/features/running_songs/providers/running_song_providers.dart
@lib/features/taste_learning/providers/taste_learning_providers.dart
@lib/features/song_feedback/domain/song_feedback.dart
@lib/features/running_songs/domain/running_song.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Merge running songs into liked set for scoring boost (SONGS-03)</name>
  <files>lib/features/playlist/providers/playlist_providers.dart</files>
  <action>
    Integrate running songs into the playlist scoring pipeline so they receive the existing `likedSongWeight (+5)` boost.

    1. Add import for `running_song_providers.dart`:
       ```dart
       import 'package:running_playlist_ai/features/running_songs/providers/running_song_providers.dart';
       ```

    2. In `_readFeedbackSets()`, after the existing feedback loop and before the return statement, add:
       ```dart
       // Merge "Songs I Run To" keys into liked set for scoring boost
       final runningSongs = ref.read(runningSongProvider);
       liked.addAll(runningSongs.keys);
       ```
       This uses `Set.addAll()` which is idempotent -- songs already in the liked set (from explicit feedback) are not duplicated.

    3. In `generatePlaylist()`, add `ensureLoaded()` for running songs alongside the other ensureLoaded calls (after the existing `freshnessModeProvider` ensureLoaded, around line 139):
       ```dart
       await ref.read(runningSongProvider.notifier).ensureLoaded();
       ```

    4. In `regeneratePlaylist()`, add the same `ensureLoaded()` call alongside the other ensureLoaded calls (after `freshnessModeProvider` ensureLoaded, around line 295):
       ```dart
       await ref.read(runningSongProvider.notifier).ensureLoaded();
       ```

    Note: `shufflePlaylist()` is synchronous and does NOT get an ensureLoaded. It relies on the provider being loaded from a prior `generatePlaylist()` call, which is consistent with the existing pattern.
  </action>
  <verify>
    Run `dart analyze lib/features/playlist/providers/playlist_providers.dart` -- no errors.
    Verify the import is present and `runningSongProvider` is used in `_readFeedbackSets()`.
    Verify `ensureLoaded()` calls exist in both `generatePlaylist()` and `regeneratePlaylist()`.
  </verify>
  <done>
    `_readFeedbackSets()` returns a liked set that includes both explicitly liked songs AND running song keys. The `ensureLoaded()` call in `generatePlaylist()` and `regeneratePlaylist()` ensures running songs are loaded before reading state on cold start.
  </done>
</task>

<task type="auto">
  <name>Task 2: Feed running songs into taste pattern analysis (SONGS-04)</name>
  <files>lib/features/taste_learning/providers/taste_learning_providers.dart</files>
  <action>
    Integrate running songs into the taste learning pipeline so genre/artist patterns from running songs appear as taste suggestions.

    1. Add imports for running song types:
       ```dart
       import 'package:running_playlist_ai/features/running_songs/domain/running_song.dart';
       import 'package:running_playlist_ai/features/running_songs/providers/running_song_providers.dart';
       import 'package:running_playlist_ai/features/song_feedback/domain/song_feedback.dart';
       ```

    2. Add a private helper function inside `TasteSuggestionNotifier` (before `_reanalyze()`):
       ```dart
       /// Converts running songs to synthetic liked [SongFeedback] entries
       /// for taste pattern analysis. Real feedback takes precedence via
       /// merge order in [_reanalyze].
       Map<String, SongFeedback> _syntheticFeedbackFromRunningSongs(
         Map<String, RunningSong> runningSongs,
       ) {
         return {
           for (final entry in runningSongs.entries)
             entry.key: SongFeedback(
               songKey: entry.key,
               isLiked: true,
               feedbackDate: entry.value.addedDate,
               songTitle: entry.value.title,
               songArtist: entry.value.artist,
               genre: entry.value.genre,
             ),
         };
       }
       ```

    3. In the constructor, add a reactive listener for running songs alongside the existing listeners:
       ```dart
       ref.listen(runningSongProvider, (_, __) => _reanalyze());
       ```

    4. Modify `_reanalyze()` to merge running songs as synthetic feedback:
       - Read running songs: `final runningSongs = ref.read(runningSongProvider);`
       - Update the early-return guard to also check running songs:
         `if (profile == null || (feedback.isEmpty && runningSongs.isEmpty))`
       - Create synthetic feedback: `final syntheticFeedback = _syntheticFeedbackFromRunningSongs(runningSongs);`
       - Merge with real feedback taking precedence: `final mergedFeedback = {...syntheticFeedback, ...feedback};`
       - Pass `mergedFeedback` (instead of `feedback`) to `TastePatternAnalyzer.analyze()`.

    IMPORTANT: The merge order `{...syntheticFeedback, ...feedback}` ensures real feedback entries overwrite synthetic ones. If a user disliked a song but it's also in "Songs I Run To", the real dislike feedback drives taste learning.
  </action>
  <verify>
    Run `dart analyze lib/features/taste_learning/providers/taste_learning_providers.dart` -- no errors.
    Verify the `_syntheticFeedbackFromRunningSongs` helper exists.
    Verify `ref.listen(runningSongProvider, ...)` is in the constructor.
    Verify `_reanalyze()` reads running songs and passes merged feedback to the analyzer.
  </verify>
  <done>
    `TasteSuggestionNotifier` converts running songs to synthetic `SongFeedback` entries, merges them with real feedback (real takes precedence), and passes the combined feedback to `TastePatternAnalyzer.analyze()`. Changes in running songs trigger re-analysis reactively.
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/playlist/providers/ lib/features/taste_learning/providers/` -- zero errors
2. `flutter test` -- existing tests pass (no regressions)
3. Code review: `_readFeedbackSets()` unions running song keys into the liked set
4. Code review: `_reanalyze()` merges synthetic feedback from running songs before analysis
5. Code review: Merge order is `{...syntheticFeedback, ...feedback}` (real feedback wins)
</verification>

<success_criteria>
- Running songs are treated as liked songs in playlist scoring via `liked.addAll(runningSongs.keys)`
- Running songs produce synthetic `SongFeedback(isLiked: true)` entries for taste pattern analysis
- Real feedback takes precedence over synthetic running-song feedback
- Adding/removing running songs triggers taste re-analysis reactively
- `ensureLoaded()` prevents cold-start race condition for running songs provider
</success_criteria>

<output>
After completion, create `.planning/phases/29-scoring-taste-integration/29-01-SUMMARY.md`
</output>
