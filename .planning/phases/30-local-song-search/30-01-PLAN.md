---
phase: 30-local-song-search
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - lib/features/song_search/domain/song_search_service.dart
  - lib/features/song_search/providers/song_search_providers.dart
  - test/features/song_search/domain/song_search_service_test.dart
autonomous: true

must_haves:
  truths:
    - "CuratedSongSearchService returns matching songs for queries >= 2 chars"
    - "Search matches against both title and artist name (case-insensitive)"
    - "Results are capped at 20 items"
    - "Abstract SongSearchService interface exists for backend extensibility"
    - "Provider wires curated songs list to search service"
  artifacts:
    - path: "lib/features/song_search/domain/song_search_service.dart"
      provides: "SongSearchResult model, SongSearchService interface, CuratedSongSearchService"
      contains: "abstract class SongSearchService"
    - path: "lib/features/song_search/providers/song_search_providers.dart"
      provides: "curatedSongsListProvider, songSearchServiceProvider"
      contains: "songSearchServiceProvider"
    - path: "test/features/song_search/domain/song_search_service_test.dart"
      provides: "Unit tests for search service"
      contains: "CuratedSongSearchService"
  key_links:
    - from: "lib/features/song_search/providers/song_search_providers.dart"
      to: "CuratedSongRepository.loadCuratedSongs"
      via: "FutureProvider loading song list"
      pattern: "CuratedSongRepository\\.loadCuratedSongs"
    - from: "lib/features/song_search/providers/song_search_providers.dart"
      to: "lib/features/song_search/domain/song_search_service.dart"
      via: "Provider creating CuratedSongSearchService with song list"
      pattern: "CuratedSongSearchService"
---

<objective>
Create the search service domain layer with abstract interface and curated catalog implementation, plus Riverpod providers.

Purpose: SEARCH-03 requires an abstract interface extensible to Spotify. SEARCH-01 requires curated catalog search with substring matching.
Output: `SongSearchResult` model, `SongSearchService` interface, `CuratedSongSearchService` implementation, providers, and unit tests.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@lib/features/curated_songs/domain/curated_song.dart
@lib/features/curated_songs/data/curated_song_repository.dart
@lib/features/curated_songs/providers/curated_song_providers.dart
@lib/features/song_feedback/domain/song_feedback.dart
</context>

<feature>
  <name>Song Search Service</name>
  <files>
    lib/features/song_search/domain/song_search_service.dart
    lib/features/song_search/providers/song_search_providers.dart
    test/features/song_search/domain/song_search_service_test.dart
  </files>
  <behavior>
    SongSearchResult is a simple value class with fields: title (String), artist (String), bpm (int?), genre (String?), source (String).

    SongSearchService is an abstract class with one method:
    - Future&lt;List&lt;SongSearchResult&gt;&gt; search(String query)

    CuratedSongSearchService implements SongSearchService:
    - Constructor takes List&lt;CuratedSong&gt;
    - search(query) returns empty list if query.trim().length < 2
    - Matches case-insensitively against both title and artistName using String.contains()
    - Returns at most 20 results
    - Maps CuratedSong to SongSearchResult with source='curated'

    Test cases (TDD RED phase):
    1. Empty query returns []
    2. Single char query returns []
    3. Query matching one title returns that song
    4. Query matching artist returns that song
    5. Case-insensitive match works ("LOSE" matches "Lose Yourself")
    6. Query matching nothing returns []
    7. Results capped at 20 when more matches exist
    8. Partial substring match works ("run" matches "Running")
    9. Both title and artist matches appear in results
    10. Source field is 'curated' for all results
  </behavior>
  <implementation>
    RED: Create test file with 10 test cases using a small fixture list of CuratedSong objects (5-6 songs). Import the domain file (will fail to compile initially). Use descriptive test names. For the cap test, create a fixture list of 25 songs all matching a common term.

    GREEN: Implement SongSearchResult, SongSearchService, CuratedSongSearchService in the domain file. Implementation is straightforward:
    - Lowercase the query, trim it
    - If length < 2, return []
    - Filter _songs where title.toLowerCase().contains(lowerQuery) OR artistName.toLowerCase().contains(lowerQuery)
    - .take(20)
    - Map to SongSearchResult
    - Return as List

    Then create providers file:
    - curatedSongsListProvider: FutureProvider that calls CuratedSongRepository.loadCuratedSongs()
    - songSearchServiceProvider: FutureProvider that awaits curatedSongsListProvider, creates CuratedSongSearchService

    Run tests, all should pass.

    REFACTOR: Not expected to be needed -- implementation is simple.
  </implementation>
</feature>

<verification>
```bash
cd /Users/tijmen/running-playlist-ai && flutter test test/features/song_search/
```
All tests pass. No regressions in existing tests.
</verification>

<success_criteria>
- SongSearchService abstract interface exists with search() method
- CuratedSongSearchService correctly filters curated songs
- 10 unit tests pass covering edge cases
- Providers wire CuratedSongRepository data to search service
- No new package dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/30-local-song-search/30-01-SUMMARY.md`
</output>
