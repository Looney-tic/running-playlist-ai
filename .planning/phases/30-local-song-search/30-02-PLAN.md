---
phase: 30-local-song-search
plan: 02
type: execute
wave: 2
depends_on: ["30-01"]
files_modified:
  - lib/features/song_search/presentation/song_search_screen.dart
  - lib/features/song_search/presentation/highlight_match.dart
  - lib/app/router.dart
  - lib/features/running_songs/presentation/running_songs_screen.dart
autonomous: true

must_haves:
  truths:
    - "User types 2+ characters and sees matching songs updating as they type"
    - "Matching text in title and artist is visually highlighted (bold + primary color)"
    - "User can tap a search result to add it to Songs I Run To"
    - "Songs already in the collection show a checkmark instead of add icon"
    - "Search is accessible from the running songs screen app bar"
  artifacts:
    - path: "lib/features/song_search/presentation/song_search_screen.dart"
      provides: "Search screen with Autocomplete widget"
      contains: "SongSearchScreen"
    - path: "lib/features/song_search/presentation/highlight_match.dart"
      provides: "Text highlight utility for search results"
      contains: "highlightMatches"
    - path: "lib/app/router.dart"
      provides: "/song-search route"
      contains: "song-search"
    - path: "lib/features/running_songs/presentation/running_songs_screen.dart"
      provides: "Search icon in app bar"
      contains: "Icons.search"
  key_links:
    - from: "lib/features/song_search/presentation/song_search_screen.dart"
      to: "lib/features/song_search/providers/song_search_providers.dart"
      via: "ref.watch(songSearchServiceProvider) for search service access"
      pattern: "songSearchServiceProvider"
    - from: "lib/features/song_search/presentation/song_search_screen.dart"
      to: "lib/features/running_songs/providers/running_song_providers.dart"
      via: "ref.read(runningSongProvider.notifier) for adding songs"
      pattern: "runningSongProvider"
    - from: "lib/features/running_songs/presentation/running_songs_screen.dart"
      to: "/song-search"
      via: "context.push('/song-search') from search icon"
      pattern: "song-search"
---

<objective>
Build the search UI screen with Autocomplete widget, match highlighting, router wiring, and entry point from the running songs screen.

Purpose: SEARCH-01 (typeahead search), SEARCH-02 (highlight matching), and wiring search results to "Songs I Run To" via tapping.
Output: Song search screen, highlight utility, router route, search icon entry point.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/30-local-song-search/30-01-SUMMARY.md
@.planning/phases/30-local-song-search/30-RESEARCH.md
@lib/features/running_songs/presentation/running_songs_screen.dart
@lib/features/running_songs/providers/running_song_providers.dart
@lib/features/running_songs/domain/running_song.dart
@lib/features/song_feedback/domain/song_feedback.dart
@lib/app/router.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Highlight utility and search screen</name>
  <files>
    lib/features/song_search/presentation/highlight_match.dart
    lib/features/song_search/presentation/song_search_screen.dart
  </files>
  <action>
    **highlight_match.dart:**
    Create a `highlightMatches(String source, String query, TextStyle? baseStyle)` function returning `List<TextSpan>`.
    - If query is empty, return single TextSpan with source text
    - Find all occurrences of query (case-insensitive) in source using indexOf on lowercased strings
    - Non-matching segments get baseStyle
    - Matching segments get `baseStyle?.copyWith(fontWeight: FontWeight.bold, color: Theme primary color)` -- accept a `Color highlightColor` parameter (caller passes `theme.colorScheme.primary`)
    - Extract substrings from ORIGINAL case source at positions found via lowercase matching (prevents case drift per Pitfall 4 from research)

    **song_search_screen.dart:**
    Create `SongSearchScreen` as a `ConsumerStatefulWidget`. This needs StatefulWidget because the debounce function and `_lastOptions` must persist across rebuilds.

    State setup:
    - `_Debounceable<List<SongSearchResult>?, String>? _debouncedSearch` -- initialized in initState or on first use
    - `Iterable<SongSearchResult> _lastOptions = const []` -- cache for stale debounce results
    - Use the official Flutter debounce pattern from research (Pattern 4): `_DebounceTimer` class using `Timer` + `Completer`, `_CancelException`, `_debounce<S, T>()` function. Debounce duration: 300ms.

    Layout:
    - Scaffold with AppBar title "Search Songs"
    - Body: Padding with `Autocomplete<SongSearchResult>` widget
    - `optionsBuilder`: if text.length < 2 return empty. Otherwise call `_debouncedSearch!(text)`. If result is null (stale), return `_lastOptions`. Otherwise update `_lastOptions` and return result.
    - `displayStringForOption`: `'${result.artist} - ${result.title}'`
    - `fieldViewBuilder`: default TextField with search icon prefix, "Search by song or artist..." hint text, `autofocus: true`
    - `optionsViewBuilder`: Wrap in `Align(alignment: Alignment.topLeft)` → `Material(elevation: 4, borderRadius: BorderRadius.circular(8))` → `ConstrainedBox(constraints: BoxConstraints(maxHeight: 300))` → `ListView.builder(shrinkWrap: true, padding: EdgeInsets.zero)`.

    Each list item:
    - Use `ListTile` with `leading: Icon` (music_note or check if already in collection)
    - `title`: `RichText` with `TextSpan(children: highlightMatches(option.title, query, theme.textTheme.titleSmall))` -- pass `theme.colorScheme.primary` as highlightColor
    - `subtitle`: `RichText` with `TextSpan(children: highlightMatches(option.artist, query, theme.textTheme.bodySmall?.copyWith(color: theme.colorScheme.onSurfaceVariant)))` -- same highlightColor
    - `trailing`: if song.bpm != null, show BPM text label
    - Check if song is already in collection: `ref.read(runningSongProvider).containsKey(SongKey.normalize(option.artist, option.title))` -- if yes, show `Icons.check_circle` in leading, if no, show `Icons.add_circle_outline`
    - `onTap`: if not already added, call `_addToRunningSongs(ref, option)` then show SnackBar "${option.title} added to Songs I Run To". If already added, no-op or show "Already in your collection" SnackBar.

    `_addToRunningSongs` helper method:
    - Compute `songKey` via `SongKey.normalize(result.artist, result.title)`
    - Call `ref.read(runningSongProvider.notifier).addSong(RunningSong(...))` with source `RunningSongSource.curated`, addedDate `DateTime.now()`, bpm/genre from result

    Access the search service: In build(), do `final searchServiceAsync = ref.watch(songSearchServiceProvider)`. Handle the AsyncValue:
    - loading: show CircularProgressIndicator centered
    - error: show error message
    - data: render the Autocomplete with the search service

    The `_debouncedSearch` should capture the `SongSearchService` from the provider and call its `search()` method.
  </action>
  <verify>
    `flutter analyze lib/features/song_search/presentation/` reports no errors.
    Manual review: Autocomplete wrapped in Align, debounce pattern matches Flutter SDK pattern.
  </verify>
  <done>
    Search screen renders Autocomplete with debounced search, highlighted results, and add-to-collection functionality.
  </done>
</task>

<task type="auto">
  <name>Task 2: Router wiring and search entry point</name>
  <files>
    lib/app/router.dart
    lib/features/running_songs/presentation/running_songs_screen.dart
  </files>
  <action>
    **router.dart:**
    - Add import: `import 'package:running_playlist_ai/features/song_search/presentation/song_search_screen.dart';`
    - Add GoRoute after the `/running-songs` route:
      ```dart
      GoRoute(
        path: '/song-search',
        builder: (context, state) => const SongSearchScreen(),
      ),
      ```

    **running_songs_screen.dart:**
    - Add import for `go_router`: `import 'package:go_router/go_router.dart';`
    - In BOTH Scaffold AppBar instances (empty state and list state), add an `actions` list with a search IconButton:
      ```dart
      actions: [
        IconButton(
          icon: const Icon(Icons.search),
          tooltip: 'Search songs',
          onPressed: () => context.push('/song-search'),
        ),
      ],
      ```
    - The empty state Scaffold (line ~21) and the list state Scaffold (line ~32) both need this action.
    - Update the empty state guidance text to mention search: change "Add songs from your generated playlists to build your personal running music collection." to "Search the song catalog or add songs from your generated playlists to build your running music collection."
  </action>
  <verify>
    `flutter analyze lib/app/router.dart lib/features/running_songs/presentation/running_songs_screen.dart` reports no errors.
    Route `/song-search` exists in the router. Running songs screen has search icon in both empty and list states.
  </verify>
  <done>
    `/song-search` route is wired. Running songs screen shows search icon in app bar. Tapping it navigates to the search screen.
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/tijmen/running-playlist-ai && flutter analyze
cd /Users/tijmen/running-playlist-ai && flutter test test/features/song_search/
```
- No analysis errors
- Search service tests still pass
- App builds successfully
</verification>

<success_criteria>
- User can navigate from running songs screen to search via search icon
- Typing 2+ characters shows matching songs with highlighted text
- Tapping a result adds it to "Songs I Run To" with SnackBar confirmation
- Already-added songs show checkmark icon
- Autocomplete dropdown renders correctly (Align wrapper, Material elevation, constrained height)
</success_criteria>

<output>
After completion, create `.planning/phases/30-local-song-search/30-02-SUMMARY.md`
</output>
