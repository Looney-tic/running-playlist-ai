---
phase: 31-spotify-auth-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/spotify_auth/domain/spotify_auth_service.dart
  - lib/features/spotify_auth/data/spotify_token_storage.dart
  - lib/features/spotify_auth/data/mock_spotify_auth_repository.dart
  - test/features/spotify_auth/data/mock_spotify_auth_repository_test.dart
  - test/features/spotify_auth/data/spotify_token_storage_test.dart
autonomous: true

must_haves:
  truths:
    - "SpotifyAuthService abstract class defines connect(), disconnect(), getAccessToken(), status, statusStream, and isConnected"
    - "SpotifyConnectionStatus enum has disconnected, connecting, connected, and error states"
    - "SpotifyTokenStorage saves and restores SpotifyCredentials using flutter_secure_storage (not SharedPreferences)"
    - "MockSpotifyAuthRepository simulates full auth lifecycle without real Spotify credentials"
    - "Unit tests pass for token storage round-trip and mock auth lifecycle"
  artifacts:
    - path: "lib/features/spotify_auth/domain/spotify_auth_service.dart"
      provides: "Abstract SpotifyAuthService interface and SpotifyConnectionStatus enum"
      exports: ["SpotifyAuthService", "SpotifyConnectionStatus"]
    - path: "lib/features/spotify_auth/data/spotify_token_storage.dart"
      provides: "Secure credential persistence via flutter_secure_storage"
      exports: ["SpotifyTokenStorage", "SpotifyCredentials"]
    - path: "lib/features/spotify_auth/data/mock_spotify_auth_repository.dart"
      provides: "Mock implementation for development and testing"
      exports: ["MockSpotifyAuthRepository"]
    - path: "test/features/spotify_auth/data/spotify_token_storage_test.dart"
      provides: "Token storage unit tests"
    - path: "test/features/spotify_auth/data/mock_spotify_auth_repository_test.dart"
      provides: "Mock auth repository unit tests"
  key_links:
    - from: "lib/features/spotify_auth/data/mock_spotify_auth_repository.dart"
      to: "lib/features/spotify_auth/domain/spotify_auth_service.dart"
      via: "implements SpotifyAuthService"
      pattern: "class MockSpotifyAuthRepository implements SpotifyAuthService"
    - from: "lib/features/spotify_auth/data/spotify_token_storage.dart"
      to: "flutter_secure_storage"
      via: "FlutterSecureStorage instance"
      pattern: "FlutterSecureStorage"
---

<objective>
Create the Spotify auth domain layer: abstract service interface, secure token storage, and mock implementation for development without Spotify credentials.

Purpose: Establishes the SpotifyAuthService contract that all auth consumers depend on, plus SpotifyTokenStorage for secure credential persistence and a MockSpotifyAuthRepository for mock-first development (Spotify Dashboard unavailable). This foundation enables Plan 02 to wire providers and UI against a working mock.

Output: 3 production files (interface, storage, mock), 2 test files
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-spotify-auth-foundation/31-RESEARCH.md
@lib/core/constants/spotify_constants.dart
@lib/features/song_search/domain/song_search_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SpotifyAuthService interface, SpotifyCredentials model, and SpotifyTokenStorage</name>
  <files>
    lib/features/spotify_auth/domain/spotify_auth_service.dart
    lib/features/spotify_auth/data/spotify_token_storage.dart
    test/features/spotify_auth/data/spotify_token_storage_test.dart
  </files>
  <action>
**File 1: `lib/features/spotify_auth/domain/spotify_auth_service.dart`**

Create an enum and abstract class:

```dart
enum SpotifyConnectionStatus { disconnected, connecting, connected, error }
```

Abstract class `SpotifyAuthService` with these members:
- `Future<void> connect()` -- Initiate OAuth PKCE flow (open browser)
- `Future<void> disconnect()` -- Clear tokens, set status to disconnected
- `Future<void> handleCallback(Uri callbackUri)` -- Handle the OAuth redirect callback
- `Future<String?> getAccessToken()` -- Return a valid access token, refreshing if needed. Returns null if not connected or refresh fails (graceful degradation).
- `SpotifyConnectionStatus get status` -- Current connection status
- `Stream<SpotifyConnectionStatus> get statusStream` -- Stream of status changes
- `Future<bool> get isConnected` -- Convenience: status == connected AND token is valid
- `Future<void> restoreSession()` -- Attempt to restore from saved credentials on app start

Follow the same interface pattern as `SongSearchService` (abstract class, not abstract interface class, since Riverpod 2.x manual providers don't need code-gen).

**File 2: `lib/features/spotify_auth/data/spotify_token_storage.dart`**

Create a `SpotifyCredentials` value class (NOT using freezed, just a plain immutable class like SongSearchResult):
- `accessToken` (String)
- `refreshToken` (String?)
- `expiration` (DateTime?)
- `scopes` (List<String>?)
- `codeVerifier` (String?) -- CRITICAL: must persist for token refresh per research Pitfall 5

Create `SpotifyTokenStorage` class using `FlutterSecureStorage`:
- Constructor takes optional `FlutterSecureStorage` parameter for testability (defaults to `const FlutterSecureStorage()`)
- `Future<void> saveCredentials(SpotifyCredentials creds)` -- Write each field to secure storage with `spotify_` prefixed keys
- `Future<SpotifyCredentials?> loadCredentials()` -- Read and reconstruct. Returns null if accessToken not found.
- `Future<void> clearAll()` -- Delete all spotify-prefixed keys (use explicit key deletion, NOT `deleteAll()` which would wipe other secure storage data)
- `Future<bool> get hasCredentials` -- Quick check if accessToken exists

Key constants for storage keys:
```dart
static const _accessTokenKey = 'spotify_access_token';
static const _refreshTokenKey = 'spotify_refresh_token';
static const _expirationKey = 'spotify_token_expiration';
static const _scopesKey = 'spotify_scopes';
static const _codeVerifierKey = 'spotify_code_verifier';
```

Expiration is stored as ISO 8601 string, parsed back to DateTime on load.

**File 3: `test/features/spotify_auth/data/spotify_token_storage_test.dart`**

Unit tests using a mock FlutterSecureStorage (create a simple in-memory `Map<String, String>` fake that implements read/write/delete).

Test cases:
1. saveCredentials + loadCredentials round-trip returns same values
2. loadCredentials returns null when nothing saved
3. clearAll removes all spotify keys
4. hasCredentials returns true after save, false after clear
5. Handles null optional fields (refreshToken, expiration, scopes, codeVerifier)
  </action>
  <verify>
Run `dart analyze lib/features/spotify_auth/domain/spotify_auth_service.dart lib/features/spotify_auth/data/spotify_token_storage.dart` -- no errors.
Run `flutter test test/features/spotify_auth/data/spotify_token_storage_test.dart` -- all tests pass.
  </verify>
  <done>
SpotifyAuthService abstract class exists with all 7 members. SpotifyCredentials value class includes codeVerifier field. SpotifyTokenStorage uses FlutterSecureStorage (not SharedPreferences). Token storage tests pass with round-trip, null handling, and clear verification.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MockSpotifyAuthRepository with simulated auth lifecycle</name>
  <files>
    lib/features/spotify_auth/data/mock_spotify_auth_repository.dart
    test/features/spotify_auth/data/mock_spotify_auth_repository_test.dart
  </files>
  <action>
**File 1: `lib/features/spotify_auth/data/mock_spotify_auth_repository.dart`**

Create `MockSpotifyAuthRepository implements SpotifyAuthService`:

This mock simulates the full auth lifecycle without real Spotify credentials. It is the DEFAULT implementation used during development (Spotify Dashboard unavailable).

Constructor takes `SpotifyTokenStorage` (for testing credential persistence).

State:
- `SpotifyConnectionStatus _status = SpotifyConnectionStatus.disconnected`
- `final StreamController<SpotifyConnectionStatus> _statusController = StreamController<SpotifyConnectionStatus>.broadcast()`
- Simulated token: `_mockAccessToken` (a UUID-like string, refreshed on each "auth")
- Simulated expiration: 1 hour from connect time

Behavior:
- `connect()`: Set status to connecting, wait 500ms (simulate network), generate mock credentials, save to SpotifyTokenStorage, set status to connected. This simulates the entire flow (no browser involved).
- `disconnect()`: Clear SpotifyTokenStorage, set status to disconnected.
- `handleCallback(Uri)`: No-op for mock (connect() does everything).
- `getAccessToken()`: Load from SpotifyTokenStorage. If expiration is past, simulate refresh (generate new token, save). If no credentials, return null. Use a Completer-based lock to prevent concurrent refresh (per research Pitfall 2).
- `status`: Return `_status`.
- `statusStream`: Return `_statusController.stream`.
- `isConnected`: Return `_status == SpotifyConnectionStatus.connected && (await getAccessToken()) != null`.
- `restoreSession()`: Load credentials from SpotifyTokenStorage. If found, set status to connected. If not, stay disconnected.
- `dispose()`: Close _statusController.

The mock generates tokens using `DateTime.now().microsecondsSinceEpoch.toRadixString(36)` -- no crypto needed for mock.

**File 2: `test/features/spotify_auth/data/mock_spotify_auth_repository_test.dart`**

Tests using the same FlutterSecureStorage fake from Task 1 (extract the fake into a shared test helper, or create inline).

Test cases:
1. Initial status is disconnected
2. connect() transitions: disconnected -> connecting -> connected
3. After connect(), getAccessToken() returns non-null token
4. disconnect() clears token and sets status to disconnected
5. After disconnect(), getAccessToken() returns null
6. restoreSession() with saved credentials sets status to connected
7. restoreSession() without credentials stays disconnected
8. getAccessToken() with expired token simulates refresh (returns new token)
9. statusStream emits status changes in order
  </action>
  <verify>
Run `dart analyze lib/features/spotify_auth/data/mock_spotify_auth_repository.dart` -- no errors.
Run `flutter test test/features/spotify_auth/data/mock_spotify_auth_repository_test.dart` -- all tests pass.
Run `flutter test test/features/spotify_auth/` -- all tests in the directory pass.
  </verify>
  <done>
MockSpotifyAuthRepository implements SpotifyAuthService with simulated connect/disconnect/refresh lifecycle. All 9 test cases pass. Mock is usable as drop-in replacement for real Spotify auth during development.
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/spotify_auth/` -- no lint errors
2. `flutter test test/features/spotify_auth/` -- all tests pass
3. SpotifyAuthService is abstract and mockable
4. SpotifyTokenStorage uses flutter_secure_storage (grep for FlutterSecureStorage)
5. SpotifyCredentials includes codeVerifier field
6. MockSpotifyAuthRepository transitions through correct status states
</verification>

<success_criteria>
- SpotifyAuthService abstract class defines the complete auth contract (connect, disconnect, handleCallback, getAccessToken, restoreSession, status, statusStream, isConnected)
- SpotifyTokenStorage persists credentials in flutter_secure_storage with all 5 fields including codeVerifier
- MockSpotifyAuthRepository simulates full auth lifecycle with proper status transitions
- All unit tests pass for both storage and mock repository
- No dependency on the `spotify` package yet (that comes in Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/31-spotify-auth-foundation/31-01-SUMMARY.md`
</output>
