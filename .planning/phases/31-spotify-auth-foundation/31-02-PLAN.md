---
phase: 31-spotify-auth-foundation
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - pubspec.yaml
  - lib/features/spotify_auth/data/spotify_auth_repository.dart
  - lib/features/spotify_auth/providers/spotify_auth_providers.dart
  - lib/features/settings/presentation/settings_screen.dart
  - lib/core/constants/spotify_constants.dart
  - .env
autonomous: true

must_haves:
  truths:
    - "spotifyAuthServiceProvider returns MockSpotifyAuthRepository by default (real impl swappable later)"
    - "spotifyConnectionStatusProvider exposes reactive connection status to UI"
    - "Settings screen shows 'Connect Spotify' button when disconnected and 'Disconnect' when connected"
    - "Tapping Connect triggers auth flow via the SpotifyAuthService provider"
    - "SpotifyAuthRepository exists as scaffold for real PKCE flow using spotify package"
    - "SPOTIFY_CLIENT_ID placeholder exists in .env"
    - "spotify package is added to pubspec.yaml"
  artifacts:
    - path: "lib/features/spotify_auth/data/spotify_auth_repository.dart"
      provides: "Real Spotify PKCE auth implementation scaffold"
      exports: ["SpotifyAuthRepository"]
    - path: "lib/features/spotify_auth/providers/spotify_auth_providers.dart"
      provides: "Riverpod providers for Spotify auth state"
      exports: ["spotifyAuthServiceProvider", "spotifyConnectionStatusProvider"]
    - path: "lib/features/settings/presentation/settings_screen.dart"
      provides: "Settings UI with Spotify connect/disconnect section"
    - path: "lib/core/constants/spotify_constants.dart"
      provides: "Updated constants with SPOTIFY_CLIENT_ID env key and spotify-callback redirect"
    - path: "pubspec.yaml"
      provides: "spotify package dependency"
      contains: "spotify:"
  key_links:
    - from: "lib/features/spotify_auth/providers/spotify_auth_providers.dart"
      to: "lib/features/spotify_auth/data/mock_spotify_auth_repository.dart"
      via: "provider returns MockSpotifyAuthRepository"
      pattern: "MockSpotifyAuthRepository"
    - from: "lib/features/settings/presentation/settings_screen.dart"
      to: "lib/features/spotify_auth/providers/spotify_auth_providers.dart"
      via: "ref.watch(spotifyConnectionStatusProvider)"
      pattern: "spotifyConnectionStatusProvider"
    - from: "lib/features/spotify_auth/data/spotify_auth_repository.dart"
      to: "lib/features/spotify_auth/domain/spotify_auth_service.dart"
      via: "implements SpotifyAuthService"
      pattern: "class SpotifyAuthRepository implements SpotifyAuthService"
---

<objective>
Wire Spotify auth into the app: Riverpod providers, real auth repository scaffold using the `spotify` package, and Settings UI for connect/disconnect.

Purpose: Makes Spotify auth accessible throughout the app via providers, gives users a UI to manage their Spotify connection, and scaffolds the real SpotifyAuthRepository so it's ready when Spotify Dashboard credentials become available. The mock is the active default; the real implementation is structurally complete but not yet the default provider.

Output: 4 production files (repository, providers, settings UI, constants update), 1 config update (.env), 1 dependency addition (pubspec.yaml)
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-spotify-auth-foundation/31-RESEARCH.md
@.planning/phases/31-spotify-auth-foundation/31-01-SUMMARY.md
@lib/core/constants/spotify_constants.dart
@lib/features/settings/presentation/settings_screen.dart
@lib/features/auth/providers/auth_providers.dart
@pubspec.yaml
@.env
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add spotify package, create real SpotifyAuthRepository scaffold, and Riverpod providers</name>
  <files>
    pubspec.yaml
    lib/features/spotify_auth/data/spotify_auth_repository.dart
    lib/features/spotify_auth/providers/spotify_auth_providers.dart
    lib/core/constants/spotify_constants.dart
    .env
  </files>
  <action>
**Step 1: Add spotify package**

Run `flutter pub add spotify` to add the `spotify` package to pubspec.yaml.

**Step 2: Update `lib/core/constants/spotify_constants.dart`**

Add:
- `const String spotifyClientIdKey = 'SPOTIFY_CLIENT_ID';` -- env var key name
- `const String spotifyCallbackUrl = 'io.runplaylist.app://spotify-callback';` -- Distinct from the existing `spotifyRedirectUrl` (which is `login-callback` for Supabase). The Spotify PKCE flow uses its own callback path to avoid conflicts.

Leave existing constants (spotifyScopes, spotifyRedirectScheme, spotifyRedirectUrl) unchanged -- they're used by the existing Supabase auth flow.

**Step 3: Add `SPOTIFY_CLIENT_ID` to `.env`**

Add line: `SPOTIFY_CLIENT_ID=your_spotify_client_id_here` -- placeholder until Dashboard is available.

**Step 4: Create `lib/features/spotify_auth/data/spotify_auth_repository.dart`**

Create `SpotifyAuthRepository implements SpotifyAuthService`:

This is the REAL implementation using the `spotify` package's PKCE flow. It is structurally complete but NOT the default provider yet (MockSpotifyAuthRepository is default). When Spotify Dashboard credentials are available, the provider switches to this.

Constructor takes:
- `String clientId` (from env)
- `SpotifyTokenStorage tokenStorage` (from Plan 01)

State:
- `SpotifyConnectionStatus _status = SpotifyConnectionStatus.disconnected`
- `final StreamController<SpotifyConnectionStatus> _statusController = StreamController<SpotifyConnectionStatus>.broadcast()`
- `AuthorizationCodeGrant? _currentGrant` -- held between connect() and handleCallback()
- `SpotifyApi? _spotifyApi` -- the authenticated API client
- `Completer<String?>? _refreshCompleter` -- prevents concurrent refresh (Pitfall 2)

Implement all SpotifyAuthService methods:

`connect()`:
1. Set status to connecting, emit
2. Generate PKCE verifier: `SpotifyApi.generateCodeVerifier()`
3. Create credentials: `SpotifyApiCredentials.pkce(clientId, codeVerifier: verifier)`
4. Create grant: `SpotifyApi.authorizationCodeGrant(credentials)`
5. Store grant in `_currentGrant`
6. Get auth URL: `grant.getAuthorizationUrl(Uri.parse(spotifyCallbackUrl), scopes: spotifyScopes.split(' '))`
7. Launch URL: `await launchUrl(authUri, mode: LaunchMode.externalApplication)`
8. Note: status stays `connecting` until `handleCallback()` completes

`handleCallback(Uri callbackUri)`:
1. Extract query parameters from callbackUri
2. If `_currentGrant` is null, set error status and return
3. Exchange code: `final client = await _currentGrant!.handleAuthorizationResponse(params)`
4. Create API: `_spotifyApi = SpotifyApi.fromClient(client)`
5. Get credentials: `final creds = await _spotifyApi!.getCredentials()`
6. Save to token storage as SpotifyCredentials (map SpotifyApiCredentials fields to SpotifyCredentials)
7. Set status to connected, emit
8. Catch errors -> set status to error, emit

`disconnect()`:
1. Clear token storage
2. Nullify _spotifyApi and _currentGrant
3. Set status to disconnected, emit

`getAccessToken()`:
1. Load credentials from token storage
2. If null, return null
3. If expiration is in the future (with 5-minute buffer), return accessToken directly
4. If expired or no expiration: attempt refresh using `SpotifyApi.asyncFromCredentials()` with `onCredentialsRefreshed` callback to save new creds
5. Use _refreshCompleter lock to prevent concurrent refresh attempts
6. On refresh failure: clear storage, set disconnected, return null

`restoreSession()`:
1. Load credentials from token storage
2. If null, status stays disconnected
3. If found, try to create SpotifyApi from saved credentials
4. On success: set connected, emit
5. On failure: clear storage, set disconnected, emit

`isConnected`: `_status == SpotifyConnectionStatus.connected && (await getAccessToken()) != null`

Import `url_launcher` for `launchUrl`. Import `spotify` package types. Import spotify_constants for `spotifyScopes` and `spotifyCallbackUrl`.

**Step 5: Create `lib/features/spotify_auth/providers/spotify_auth_providers.dart`**

Create Riverpod providers (manual, not code-gen per project conventions):

```dart
/// The active SpotifyAuthService implementation.
///
/// Returns MockSpotifyAuthRepository by default (Spotify Dashboard unavailable).
/// Swap to SpotifyAuthRepository when real credentials are available.
final spotifyAuthServiceProvider = Provider<SpotifyAuthService>((ref) {
  final storage = SpotifyTokenStorage();
  final service = MockSpotifyAuthRepository(storage);
  // Attempt session restoration on creation
  service.restoreSession();
  return service;
});

/// Reactive Spotify connection status.
///
/// Rebuilds when status changes (connected, disconnected, etc.).
final spotifyConnectionStatusProvider = StreamProvider<SpotifyConnectionStatus>((ref) {
  final service = ref.watch(spotifyAuthServiceProvider);
  return service.statusStream;
});

/// Current Spotify connection status (synchronous snapshot).
///
/// Defaults to disconnected if stream hasn't emitted yet.
final spotifyConnectionStatusSyncProvider = Provider<SpotifyConnectionStatus>((ref) {
  final asyncStatus = ref.watch(spotifyConnectionStatusProvider);
  return asyncStatus.valueOrNull ?? SpotifyConnectionStatus.disconnected;
});
```

Follow the existing provider pattern from `auth_providers.dart` -- manual Provider, no code-gen.
  </action>
  <verify>
Run `flutter pub get` -- succeeds (spotify package resolves).
Run `dart analyze lib/features/spotify_auth/data/spotify_auth_repository.dart lib/features/spotify_auth/providers/spotify_auth_providers.dart lib/core/constants/spotify_constants.dart` -- no errors.
Verify `spotify` appears in pubspec.yaml dependencies.
Verify `SPOTIFY_CLIENT_ID` appears in .env.
  </verify>
  <done>
spotify package added to pubspec.yaml. SpotifyAuthRepository implements full PKCE flow with connect/handleCallback/disconnect/getAccessToken/restoreSession using the spotify package. Riverpod providers expose SpotifyAuthService (mock by default) and reactive connection status. SPOTIFY_CLIENT_ID placeholder in .env. spotify_constants.dart updated with spotifyCallbackUrl and spotifyClientIdKey.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build Settings screen with Spotify connect/disconnect UI</name>
  <files>
    lib/features/settings/presentation/settings_screen.dart
  </files>
  <action>
Replace the placeholder SettingsScreen with a real implementation that includes a Spotify connection section.

Make SettingsScreen a ConsumerWidget (needs ref for Riverpod providers).

Structure:
```
Scaffold
  AppBar: "Settings"
  body: ListView
    Section: "Spotify"
      - SpotifyConnectionTile (custom ListTile)
```

**SpotifyConnectionTile** (can be a private widget within the file):

Watch `spotifyConnectionStatusSyncProvider` for current status.

Display states:
- `disconnected`: ListTile with leading Spotify icon (Icons.music_note or a custom green circle), title "Spotify", subtitle "Not connected", trailing ElevatedButton "Connect". On tap: `ref.read(spotifyAuthServiceProvider).connect()`.
- `connecting`: ListTile with title "Spotify", subtitle "Connecting...", trailing CircularProgressIndicator.adaptive(). No tap action.
- `connected`: ListTile with title "Spotify", subtitle "Connected", trailing OutlinedButton "Disconnect". On tap: show confirmation dialog, then `ref.read(spotifyAuthServiceProvider).disconnect()`.
- `error`: ListTile with title "Spotify", subtitle "Connection failed", trailing ElevatedButton "Retry". On tap: same as connect.

Use the app's Material 3 theme (surfaceContainerHighest for cards per MEMORY.md).

Wrap the Spotify section in a Card with a header:
```dart
Padding(
  padding: EdgeInsets.all(16),
  child: Text('Spotify', style: Theme.of(context).textTheme.titleMedium),
),
```

Keep the overall Settings screen extensible -- other sections can be added below the Spotify section later. Use a `ListView` with children, not `ListView.builder`.

Note: The Settings screen is already routed in the app (it exists at `lib/features/settings/presentation/settings_screen.dart` and presumably has a route). Just replace its body -- do not change routing.
  </action>
  <verify>
Run `dart analyze lib/features/settings/presentation/settings_screen.dart` -- no errors.
Run `flutter build apk --debug 2>&1 | tail -5` -- build succeeds (verifies all imports resolve).
  </verify>
  <done>
Settings screen shows Spotify connection section with dynamic state display. "Connect" button visible when disconnected, "Disconnect" when connected, loading indicator during connecting, retry on error. UI reads from spotifyConnectionStatusSyncProvider and actions go through spotifyAuthServiceProvider.
  </done>
</task>

</tasks>

<verification>
1. `flutter pub get` -- succeeds with spotify package
2. `dart analyze lib/features/spotify_auth/ lib/features/settings/ lib/core/constants/spotify_constants.dart` -- no lint errors
3. `flutter test test/features/spotify_auth/` -- all tests from Plan 01 still pass
4. `flutter build apk --debug` -- full build succeeds
5. Settings screen imports resolve correctly
6. Provider chain: SettingsScreen -> spotifyConnectionStatusSyncProvider -> spotifyConnectionStatusProvider -> spotifyAuthServiceProvider -> MockSpotifyAuthRepository -> SpotifyTokenStorage -> FlutterSecureStorage
</verification>

<success_criteria>
- spotify package in pubspec.yaml and pub get resolves
- SpotifyAuthRepository scaffolds the full PKCE flow (structurally complete, not tested with real credentials)
- Riverpod providers wire mock auth service to UI
- Settings screen shows Spotify connection state with connect/disconnect actions
- SPOTIFY_CLIENT_ID placeholder in .env
- spotifyCallbackUrl distinct from existing Supabase login-callback
- Full build succeeds (no compile errors)
</success_criteria>

<output>
After completion, create `.planning/phases/31-spotify-auth-foundation/31-02-SUMMARY.md`
</output>
