---
phase: 32-spotify-search
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/features/song_search/domain/song_search_service.dart
  - lib/features/song_search/data/mock_spotify_search_service.dart
  - lib/features/song_search/providers/song_search_providers.dart
  - lib/features/song_search/presentation/song_search_screen.dart
  - test/features/song_search/domain/song_search_service_test.dart
autonomous: true

must_haves:
  truths:
    - "When Spotify is connected, search results include both curated and Spotify songs"
    - "Spotify search results can be added to Songs I Run To with source=spotify"
    - "When Spotify is not connected, search returns only curated results (no errors)"
    - "Source badges distinguish Spotify results from curated catalog results"
    - "Duplicate songs appearing in both curated and Spotify are deduplicated (curated takes priority)"
  artifacts:
    - path: "lib/features/song_search/domain/song_search_service.dart"
      provides: "SongSearchResult.spotifyUri, SpotifySongSearchService, CompositeSongSearchService"
      contains: "class SpotifySongSearchService implements SongSearchService"
    - path: "lib/features/song_search/data/mock_spotify_search_service.dart"
      provides: "MockSpotifySongSearchService with hardcoded results"
      contains: "class MockSpotifySongSearchService implements SongSearchService"
    - path: "lib/features/song_search/providers/song_search_providers.dart"
      provides: "Conditional composite/curated provider based on Spotify status"
      contains: "spotifyConnectionStatusSyncProvider"
    - path: "lib/features/song_search/presentation/song_search_screen.dart"
      provides: "Source badges on result tiles, Spotify source in RunningSong"
      contains: "_buildSourceBadge"
    - path: "test/features/song_search/domain/song_search_service_test.dart"
      provides: "Tests for composite service and mock Spotify service"
      contains: "CompositeSongSearchService"
  key_links:
    - from: "lib/features/song_search/providers/song_search_providers.dart"
      to: "lib/features/spotify_auth/providers/spotify_auth_providers.dart"
      via: "spotifyConnectionStatusSyncProvider check"
      pattern: "spotifyConnectionStatusSyncProvider"
    - from: "lib/features/song_search/domain/song_search_service.dart"
      to: "lib/features/song_search/data/mock_spotify_search_service.dart"
      via: "SongSearchService interface implementation"
      pattern: "implements SongSearchService"
    - from: "lib/features/song_search/presentation/song_search_screen.dart"
      to: "lib/features/running_songs/domain/running_song.dart"
      via: "RunningSongSource.spotify set from search result source"
      pattern: "RunningSongSource\\.spotify"
---

<objective>
Extend the song search system with Spotify catalog search when the user has Spotify connected. Create SpotifySongSearchService (real + mock), CompositeSongSearchService for merged results with deduplication, update the provider to conditionally return composite vs curated-only, and add source badges to the search result tiles.

Purpose: Users with Spotify connected can discover songs beyond the curated catalog. This is the core value of the Spotify integration -- expanding the available song library from ~200 curated songs to Spotify's entire catalog.

Output: SpotifySongSearchService, MockSpotifySongSearchService, CompositeSongSearchService, updated provider, source badges in UI, unit tests.
</objective>

<execution_context>
@/Users/tijmen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tijmen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-spotify-search/32-RESEARCH.md
@.planning/phases/30-local-song-search/30-01-SUMMARY.md
@.planning/phases/31-spotify-auth-foundation/31-02-SUMMARY.md

# Key source files
@lib/features/song_search/domain/song_search_service.dart
@lib/features/song_search/providers/song_search_providers.dart
@lib/features/song_search/presentation/song_search_screen.dart
@lib/features/spotify_auth/providers/spotify_auth_providers.dart
@lib/features/spotify_auth/domain/spotify_auth_service.dart
@lib/features/running_songs/domain/running_song.dart
@lib/features/song_feedback/domain/song_feedback.dart
@test/features/song_search/domain/song_search_service_test.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Spotify and composite search services with provider wiring and tests</name>
  <files>
    lib/features/song_search/domain/song_search_service.dart
    lib/features/song_search/data/mock_spotify_search_service.dart
    lib/features/song_search/providers/song_search_providers.dart
    test/features/song_search/domain/song_search_service_test.dart
  </files>
  <action>
**1. Extend SongSearchResult with spotifyUri field** in `song_search_service.dart`:
- Add `this.spotifyUri` as optional named parameter to the constructor
- Add `final String? spotifyUri;` field with doc comment: "Spotify track URI (e.g. 'spotify:track:abc123'), null for curated results"
- Do NOT change CuratedSongSearchService (it passes `spotifyUri: null` implicitly)

**2. Add SpotifySongSearchService** at the bottom of `song_search_service.dart`:
- Class `SpotifySongSearchService implements SongSearchService`
- Constructor takes `SpotifyApi _spotifyApi`
- `static const _maxResults = 20;`
- `search(String query)`:
  - Trim query, return `[]` if `< 2` chars
  - Call `_spotifyApi.search.get(trimmed, types: [SearchType.track]).first(_maxResults)`
  - This returns `List<Page<dynamic>>` -- take `pages.first.items?.cast<Track>() ?? []`
  - Map each Track to SongSearchResult:
    - `title: track.name ?? ''`
    - `artist: track.artists?.map((a) => a.name ?? '').join(', ') ?? 'Unknown Artist'`
    - `bpm: null` (Spotify search does not return BPM; Audio Features deprecated)
    - `genre: null`
    - `source: 'spotify'`
    - `spotifyUri: track.uri`
  - Filter out results where both title AND artist are empty
  - Wrap entire search in try-catch: on `Exception catch (_)` return `[]` (graceful degradation)
  - Return `.toList()`
- Import `package:spotify/spotify.dart` (Track, SearchType, SpotifyApi, Page are all from this package)

**3. Add CompositeSongSearchService** at the bottom of `song_search_service.dart`:
- Class `CompositeSongSearchService implements SongSearchService`
- Constructor: `CompositeSongSearchService({required this.curatedService, required this.spotifyService})`
- Both fields typed as `SongSearchService`
- `search(String query)`:
  - Always run curated search: `final curatedResults = await curatedService.search(query);`
  - Try Spotify in a try-catch block:
    ```dart
    List<SongSearchResult> spotifyResults;
    try {
      spotifyResults = await spotifyService.search(query);
    } on Exception catch (_) {
      return curatedResults; // Spotify failed, degrade gracefully
    }
    ```
  - Deduplicate using SongKey.normalize (import from song_feedback.dart):
    ```dart
    final seen = <String>{};
    final merged = <SongSearchResult>[];
    for (final result in curatedResults) {
      seen.add(SongKey.normalize(result.artist, result.title));
      merged.add(result);
    }
    for (final result in spotifyResults) {
      final key = SongKey.normalize(result.artist, result.title);
      if (!seen.contains(key)) {
        seen.add(key);
        merged.add(result);
      }
    }
    return merged.take(20).toList();
    ```
  - Curated results first (they have BPM data), then unique Spotify results, capped at 20

**4. Create MockSpotifySongSearchService** in new file `lib/features/song_search/data/mock_spotify_search_service.dart`:
- Class `MockSpotifySongSearchService implements SongSearchService`
- Import `SongSearchResult` and `SongSearchService` from domain
- `search(String query)`:
  - `await Future.delayed(const Duration(milliseconds: 200))` to simulate network latency
  - Trim and lowercase query, return `[]` if `< 2` chars
  - Filter `_mockCatalog` by case-insensitive substring match on title or artist
  - Return `.take(10).toList()`
- `static final _mockCatalog` list containing 10 songs:
  - 3 songs that ARE in the curated catalog (for dedup testing): "Lose Yourself" by Eminem (spotify:track:mock_lose), "Blinding Lights" by The Weeknd (spotify:track:mock_blinding), "Run the World" by Beyonce (spotify:track:mock_run)
  - 7 songs that are NOT in curated catalog (Spotify-only):
    - "HUMBLE." by Kendrick Lamar (spotify:track:mock_humble)
    - "Levitating" by Dua Lipa (spotify:track:mock_levitating)
    - "Physical" by Dua Lipa (spotify:track:mock_physical)
    - "Shivers" by Ed Sheeran (spotify:track:mock_shivers)
    - "Heat Waves" by Glass Animals (spotify:track:mock_heat)
    - "As It Was" by Harry Styles (spotify:track:mock_asit)
    - "Anti-Hero" by Taylor Swift (spotify:track:mock_antihero)
  - All mock songs have: `source: 'spotify'`, `spotifyUri: 'spotify:track:mock_xxx'`, `bpm: null`, `genre: null`

**5. Update songSearchServiceProvider** in `song_search_providers.dart`:
- Import `spotifyConnectionStatusSyncProvider` and `SpotifyConnectionStatus` from spotify_auth providers
- Import `spotifyAuthServiceProvider` from spotify_auth providers
- Import `CompositeSongSearchService` from domain
- Import `MockSpotifySongSearchService` from data
- Import `SpotifyApi` from spotify package
- Update `songSearchServiceProvider` body:
  ```dart
  final songs = await ref.watch(curatedSongsListProvider.future);
  final curatedService = CuratedSongSearchService(songs);

  final spotifyStatus = ref.watch(spotifyConnectionStatusSyncProvider);
  if (spotifyStatus != SpotifyConnectionStatus.connected) {
    return curatedService;
  }

  // Spotify is connected -- build composite service
  final authService = ref.read(spotifyAuthServiceProvider);
  final token = await authService.getAccessToken();
  if (token == null) return curatedService;

  // For now, use mock since Spotify Dashboard is unavailable.
  // When real credentials are available, replace with:
  //   final spotifyApi = SpotifyApi.withAccessToken(token);
  //   final spotifyService = SpotifySongSearchService(spotifyApi);
  final spotifyService = MockSpotifySongSearchService();

  return CompositeSongSearchService(
    curatedService: curatedService,
    spotifyService: spotifyService,
  );
  ```
- Keep existing `curatedSongsListProvider` unchanged
- Update doc comment on `songSearchServiceProvider` to describe conditional behavior

**6. Add tests** to `test/features/song_search/domain/song_search_service_test.dart`:
- Add a new `group('MockSpotifySongSearchService', ...)` with 3 tests:
  - `'returns empty for short query'` (length < 2 returns [])
  - `'returns matching mock results for valid query'` (search 'dua' returns Levitating and Physical)
  - `'all results have source=spotify and spotifyUri set'`
- Add a new `group('CompositeSongSearchService', ...)` with 4 tests:
  - Create a simple mock curated service (extend SongSearchService, return fixed list) and use MockSpotifySongSearchService as the Spotify backend
  - `'returns curated results when no Spotify overlap'` (query matching only curated returns curated source)
  - `'deduplicates when same song in both sources'` (query "Lose" matches curated "Lose Yourself" and mock "Lose Yourself" -- result should have only 1 entry with source=curated)
  - `'appends unique Spotify results after curated'` (query matching both sources shows curated first then unique Spotify entries)
  - `'caps results at 20'` (use a large mock fixture to verify the cap)
- Import `MockSpotifySongSearchService` and `CompositeSongSearchService`
  </action>
  <verify>
Run `dart analyze lib/features/song_search/ lib/features/song_search/data/` -- no errors.
Run `flutter test test/features/song_search/domain/song_search_service_test.dart` -- all tests pass (original 10 + new 7 = 17 tests).
  </verify>
  <done>
- SongSearchResult has spotifyUri field
- SpotifySongSearchService wraps SpotifyApi.search.get with graceful failure
- CompositeSongSearchService merges curated+Spotify with dedup (curated priority, 20 cap)
- MockSpotifySongSearchService returns 10 hardcoded results (3 overlapping curated, 7 unique)
- songSearchServiceProvider returns composite when Spotify connected, curated-only when disconnected
- All 17 tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add source badges and Spotify source to search result UI</name>
  <files>
    lib/features/song_search/presentation/song_search_screen.dart
  </files>
  <action>
**1. Add source badge to _SearchResultTile** in `song_search_screen.dart`:
- Add a private function `_buildSourceBadge` at the top level (outside the class) or as a static method:
  ```dart
  Widget _buildSourceBadge(String source, ThemeData theme) {
    final isSpotify = source == 'spotify';
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: isSpotify
            ? const Color(0xFF1DB954).withValues(alpha: 0.15)
            : theme.colorScheme.primaryContainer,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        isSpotify ? 'Spotify' : 'Catalog',
        style: theme.textTheme.labelSmall?.copyWith(
          color: isSpotify
              ? const Color(0xFF1DB954)
              : theme.colorScheme.onPrimaryContainer,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }
  ```

**2. Update the trailing section of _SearchResultTile.build:**
- Replace the current `trailing:` (which only shows BPM) with a `Row` that shows both source badge and optional BPM:
  ```dart
  trailing: Row(
    mainAxisSize: MainAxisSize.min,
    children: [
      _buildSourceBadge(option.source, theme),
      if (option.bpm != null) ...[
        const SizedBox(width: 8),
        Text(
          '${option.bpm} BPM',
          style: theme.textTheme.labelSmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    ],
  ),
  ```
- This shows: "[Spotify/Catalog] [BPM if known]" on every result tile

**3. Update _addToRunningSongs to set RunningSongSource from search result:**
- Change the `_addToRunningSongs` method to use the result's source for the RunningSong:
  ```dart
  void _addToRunningSongs(WidgetRef ref, SongSearchResult result) {
    final songKey = SongKey.normalize(result.artist, result.title);
    ref.read(runningSongProvider.notifier).addSong(
          RunningSong(
            songKey: songKey,
            artist: result.artist,
            title: result.title,
            addedDate: DateTime.now(),
            bpm: result.bpm,
            genre: result.genre,
            source: result.source == 'spotify'
                ? RunningSongSource.spotify
                : RunningSongSource.curated,
          ),
        );
  }
  ```
- This ensures Spotify-sourced songs are tracked with `RunningSongSource.spotify` in the running songs collection

**4. Verify imports:**
- `RunningSongSource` is already imported via `running_song.dart` import (already present at top of file)
- No new imports needed -- all types already available
  </action>
  <verify>
Run `dart analyze lib/features/song_search/presentation/song_search_screen.dart` -- no errors.
Run `flutter build web --no-pub` to verify full app compiles without errors.
  </verify>
  <done>
- Every search result tile shows a source badge ("Spotify" in green, "Catalog" in theme primary)
- BPM label still shows alongside badge when available
- Adding a Spotify search result to "Songs I Run To" sets source=RunningSongSource.spotify
- Adding a curated search result still sets source=RunningSongSource.curated
  </done>
</task>

</tasks>

<verification>
1. `dart analyze lib/features/song_search/ lib/features/spotify_auth/` -- zero errors
2. `flutter test test/features/song_search/` -- all tests pass
3. `flutter build web --no-pub` -- compiles successfully
4. Manual check: songSearchServiceProvider returns CuratedSongSearchService when Spotify disconnected
5. Manual check: songSearchServiceProvider returns CompositeSongSearchService when Spotify connected
</verification>

<success_criteria>
- SongSearchResult.spotifyUri field exists (nullable String)
- SpotifySongSearchService wraps SpotifyApi.search.get() with graceful failure
- MockSpotifySongSearchService provides hardcoded test data including curated overlaps
- CompositeSongSearchService merges curated + Spotify with dedup and 20-result cap
- songSearchServiceProvider conditionally returns composite (connected) or curated-only (disconnected)
- Source badges visible on all search result tiles
- Spotify results added to "Songs I Run To" have source=spotify
- All existing tests continue to pass
- 7 new tests pass for mock and composite services
</success_criteria>

<output>
After completion, create `.planning/phases/32-spotify-search/32-01-SUMMARY.md`
</output>
